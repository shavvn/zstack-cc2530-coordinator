###############################################################################
#                                                                             #
# IAR C/C++ Compiler V7.60.1.40026 for 8051             09/Apr/2014  09:37:29 #
# Copyright (C) 2004-2010 IAR Systems AB.                                     #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  banked                                             #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data_rom                                           #
#    Dptr setup         =  1,16                                               #
#    Source file        =  D:\zigbee\projects\zstack-cc2530-coordinator\Compo #
#                          nents\hal\target\CC2530EB\hal_key.c                #
#    Command line       =  -f D:\zigbee\projects\zstack-cc2530-coordinator\Pr #
#                          ojects\zstack\Samples\GenericApp\CC2530DB\..\..\.. #
#                          \Tools\CC2530DB\f8wCoord.cfg (-DCPU32MHZ           #
#                          -DROOT=__near_func -DMAC_CFG_APP_PENDING_QUEUE=TRU #
#                          E -DMAC_CFG_TX_DATA_MAX=5 -DMAC_CFG_TX_MAX=8       #
#                          -DMAC_CFG_RX_MAX=5 -DZDO_COORDINATOR -DRTR_NWK)    #
#                          -f D:\zigbee\projects\zstack-cc2530-coordinator\Pr #
#                          ojects\zstack\Samples\GenericApp\CC2530DB\..\..\.. #
#                          \Tools\CC2530DB\f8wConfig.cfg (-DZIGBEEPRO         #
#                          -DSECURE=0 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR       #
#                          -DDEFAULT_CHANLIST=0x00000800                      #
#                          -DZDAPP_CONFIG_PAN_ID=0x1111                       #
#                          -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MA #
#                          SK=0x007F -DBEACON_REQUEST_DELAY=100               #
#                          -DBEACON_REQ_DELAY_MASK=0x00FF                     #
#                          -DLINK_STATUS_JITTER_MASK=0x007F                   #
#                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_PO #
#                          LLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7             #
#                          -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3    #
#                          -DNWK_MAX_DATA_RETRIES=2                           #
#                          -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9         #
#                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40           #
#                          -DNWK_MAX_BINDING_ENTRIES=4                        #
#                          -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01,  #
#                          0x03, 0x05, 0x07, 0x09, 0x0B, 0x0D, 0x0F, 0x00,    #
#                          0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0D}"         #
#                          -DMAC_MAX_FRAME_SIZE=116                           #
#                          -DZDNWKMGR_MIN_TRANSMISSIONS=20 "-DCONST=const     #
#                          __code" -DGENERIC=__generic                        #
#                          -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=1000        #
#                          -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100)   #
#                          -DREJOIN_POLL_RATE=440 D:\zigbee\projects\zstack-c #
#                          c2530-coordinator\Components\hal\target\CC2530EB\h #
#                          al_key.c -D ZAPP_P1 -D MT_TASK -D MT_SYS_FUNC -D   #
#                          MT_ZDO_FUNC -D HAL_UART -D HAL_UART=TRUE -D        #
#                          HAL_DMA=TRUE -D HAL_LCD=FALSE -D HAL_KEY=FALSE     #
#                          -lC D:\zigbee\projects\zstack-cc2530-coordinator\P #
#                          rojects\zstack\Samples\GenericApp\CC2530DB\Coordin #
#                          atorEB\List\ -lA D:\zigbee\projects\zstack-cc2530- #
#                          coordinator\Projects\zstack\Samples\GenericApp\CC2 #
#                          530DB\CoordinatorEB\List\ --diag_suppress          #
#                          Pe001,Pa010 -o D:\zigbee\projects\zstack-cc2530-co #
#                          ordinator\Projects\zstack\Samples\GenericApp\CC253 #
#                          0DB\CoordinatorEB\Obj\ -e --require_prototypes     #
#                          --no_code_motion --debug --core=plain --dptr=16,1  #
#                          --data_model=large --code_model=banked             #
#                          --calling_convention=xdata_reentrant               #
#                          --place_constants=data_rom --nr_virtual_regs 16    #
#                          -I D:\zigbee\projects\zstack-cc2530-coordinator\Pr #
#                          ojects\zstack\Samples\GenericApp\CC2530DB\ -I      #
#                          D:\zigbee\projects\zstack-cc2530-coordinator\Proje #
#                          cts\zstack\Samples\GenericApp\CC2530DB\..\Source\  #
#                          -I D:\zigbee\projects\zstack-cc2530-coordinator\Pr #
#                          ojects\zstack\Samples\GenericApp\CC2530DB\..\..\.. #
#                          \ZMain\TI2530DB\ -I D:\zigbee\projects\zstack-cc25 #
#                          30-coordinator\Projects\zstack\Samples\GenericApp\ #
#                          CC2530DB\..\..\..\..\..\Components\hal\include\    #
#                          -I D:\zigbee\projects\zstack-cc2530-coordinator\Pr #
#                          ojects\zstack\Samples\GenericApp\CC2530DB\..\..\.. #
#                          \..\..\Components\hal\target\CC2530EB\ -I          #
#                          D:\zigbee\projects\zstack-cc2530-coordinator\Proje #
#                          cts\zstack\Samples\GenericApp\CC2530DB\..\..\..\.. #
#                          \..\Components\mac\include\ -I                     #
#                          D:\zigbee\projects\zstack-cc2530-coordinator\Proje #
#                          cts\zstack\Samples\GenericApp\CC2530DB\..\..\..\.. #
#                          \..\Components\mac\high_level\ -I                  #
#                          D:\zigbee\projects\zstack-cc2530-coordinator\Proje #
#                          cts\zstack\Samples\GenericApp\CC2530DB\..\..\..\.. #
#                          \..\Components\mac\low_level\srf04\ -I             #
#                          D:\zigbee\projects\zstack-cc2530-coordinator\Proje #
#                          cts\zstack\Samples\GenericApp\CC2530DB\..\..\..\.. #
#                          \..\Components\mac\low_level\srf04\single_chip\    #
#                          -I D:\zigbee\projects\zstack-cc2530-coordinator\Pr #
#                          ojects\zstack\Samples\GenericApp\CC2530DB\..\..\.. #
#                          \..\..\Components\mt\ -I                           #
#                          D:\zigbee\projects\zstack-cc2530-coordinator\Proje #
#                          cts\zstack\Samples\GenericApp\CC2530DB\..\..\..\.. #
#                          \..\Components\osal\include\ -I                    #
#                          D:\zigbee\projects\zstack-cc2530-coordinator\Proje #
#                          cts\zstack\Samples\GenericApp\CC2530DB\..\..\..\.. #
#                          \..\Components\osal\mcu\ccsoc\ -I                  #
#                          D:\zigbee\projects\zstack-cc2530-coordinator\Proje #
#                          cts\zstack\Samples\GenericApp\CC2530DB\..\..\..\.. #
#                          \..\Components\services\saddr\ -I                  #
#                          D:\zigbee\projects\zstack-cc2530-coordinator\Proje #
#                          cts\zstack\Samples\GenericApp\CC2530DB\..\..\..\.. #
#                          \..\Components\services\sdata\ -I                  #
#                          D:\zigbee\projects\zstack-cc2530-coordinator\Proje #
#                          cts\zstack\Samples\GenericApp\CC2530DB\..\..\..\.. #
#                          \..\Components\stack\af\ -I                        #
#                          D:\zigbee\projects\zstack-cc2530-coordinator\Proje #
#                          cts\zstack\Samples\GenericApp\CC2530DB\..\..\..\.. #
#                          \..\Components\stack\nwk\ -I                       #
#                          D:\zigbee\projects\zstack-cc2530-coordinator\Proje #
#                          cts\zstack\Samples\GenericApp\CC2530DB\..\..\..\.. #
#                          \..\Components\stack\sapi\ -I                      #
#                          D:\zigbee\projects\zstack-cc2530-coordinator\Proje #
#                          cts\zstack\Samples\GenericApp\CC2530DB\..\..\..\.. #
#                          \..\Components\stack\sec\ -I                       #
#                          D:\zigbee\projects\zstack-cc2530-coordinator\Proje #
#                          cts\zstack\Samples\GenericApp\CC2530DB\..\..\..\.. #
#                          \..\Components\stack\sys\ -I                       #
#                          D:\zigbee\projects\zstack-cc2530-coordinator\Proje #
#                          cts\zstack\Samples\GenericApp\CC2530DB\..\..\..\.. #
#                          \..\Components\stack\zdo\ -I                       #
#                          D:\zigbee\projects\zstack-cc2530-coordinator\Proje #
#                          cts\zstack\Samples\GenericApp\CC2530DB\..\..\..\.. #
#                          \..\Components\zmac\ -I D:\zigbee\projects\zstack- #
#                          cc2530-coordinator\Projects\zstack\Samples\Generic #
#                          App\CC2530DB\..\..\..\..\..\Components\zmac\f8w\   #
#                          -I "C:\Program Files (x86)\IAR Systems\Embedded    #
#                          Workbench 5.4\8051\INC\" -I "C:\Program Files      #
#                          (x86)\IAR Systems\Embedded Workbench               #
#                          5.4\8051\INC\CLIB\" -Ohz                           #
#    List file          =  D:\zigbee\projects\zstack-cc2530-coordinator\Proje #
#                          cts\zstack\Samples\GenericApp\CC2530DB\Coordinator #
#                          EB\List\hal_key.lst                                #
#    Object file        =  D:\zigbee\projects\zstack-cc2530-coordinator\Proje #
#                          cts\zstack\Samples\GenericApp\CC2530DB\Coordinator #
#                          EB\Obj\hal_key.r51                                 #
#                                                                             #
#                                                                             #
###############################################################################

D:\zigbee\projects\zstack-cc2530-coordinator\Components\hal\target\CC2530EB\hal_key.c
      1          /**************************************************************************************************
      2            Filename:       hal_key.c
      3            Revised:        $Date: 2010-09-15 19:02:45 -0700 (Wed, 15 Sep 2010) $
      4            Revision:       $Revision: 23815 $
      5          
      6            Description:    This file contains the interface to the HAL KEY Service.
      7          
      8          
      9            Copyright 2006-2010 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License").  You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product.  Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED “AS IS?WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com.
     38          **************************************************************************************************/
     39          /*********************************************************************
     40           NOTE: If polling is used, the hal_driver task schedules the KeyRead()
     41                 to occur every 100ms.  This should be long enough to naturally
     42                 debounce the keys.  The KeyRead() function remembers the key
     43                 state of the previous poll and will only return a non-zero
     44                 value if the key state changes.
     45          
     46           NOTE: If interrupts are used, the KeyRead() function is scheduled
     47                 25ms after the interrupt occurs by the ISR.  This delay is used
     48                 for key debouncing.  The ISR disables any further Key interrupt
     49                 until KeyRead() is executed.  KeyRead() will re-enable Key
     50                 interrupts after executing.  Unlike polling, when interrupts
     51                 are enabled, the previous key state is not remembered.  This
     52                 means that KeyRead() will return the current state of the keys
     53                 (not a change in state of the keys).
     54          
     55           NOTE: If interrupts are used, the KeyRead() fucntion is scheduled by
     56                 the ISR.  Therefore, the joystick movements will only be detected
     57                 during a pushbutton interrupt caused by S1 or the center joystick
     58                 pushbutton.
     59          
     60           NOTE: When a switch like S1 is pushed, the S1 signal goes from a normally
     61                 high state to a low state.  This transition is typically clean.  The
     62                 duration of the low state is around 200ms.  When the signal returns
     63                 to the high state, there is a high likelihood of signal bounce, which
     64                 causes a unwanted interrupts.  Normally, we would set the interrupt
     65                 edge to falling edge to generate an interrupt when S1 is pushed, but
     66                 because of the signal bounce, it is better to set the edge to rising
     67                 edge to generate an interrupt when S1 is released.  The debounce logic
     68                 can then filter out the signal bounce.  The result is that we typically
     69                 get only 1 interrupt per button push.  This mechanism is not totally
     70                 foolproof because occasionally, signal bound occurs during the falling
     71                 edge as well.  A similar mechanism is used to handle the joystick
     72                 pushbutton on the DB.  For the EB, we do not have independent control
     73                 of the interrupt edge for the S1 and center joystick pushbutton.  As
     74                 a result, only one or the other pushbuttons work reasonably well with
     75                 interrupts.  The default is the make the S1 switch on the EB work more
     76                 reliably.
     77          
     78          *********************************************************************/
     79          
     80          /**************************************************************************************************
     81           *                                            INCLUDES
     82           **************************************************************************************************/
     83          #include "hal_mcu.h"
     84          #include "hal_defs.h"
     85          #include "hal_types.h"
     86          #include "hal_board.h"
     87          #include "hal_drivers.h"
     88          #include "hal_adc.h"
     89          #include "hal_key.h"
     90          #include "osal.h"
     91          
     92          #if (defined HAL_KEY) && (HAL_KEY == TRUE)
     93          
     94          /**************************************************************************************************
     95           *                                              MACROS
     96           **************************************************************************************************/
     97          
     98          /**************************************************************************************************
     99           *                                            CONSTANTS
    100           **************************************************************************************************/
    101          #define HAL_KEY_RISING_EDGE   0
    102          #define HAL_KEY_FALLING_EDGE  1
    103          
    104          #define HAL_KEY_DEBOUNCE_VALUE  25
    105          
    106          /* CPU port interrupt */
    107          #define HAL_KEY_CPU_PORT_0_IF P0IF
    108          #define HAL_KEY_CPU_PORT_2_IF P2IF
    109          
    110          /* SW_6 is at P0.1 */
    111          #define HAL_KEY_SW_6_PORT   P0
    112          #define HAL_KEY_SW_6_BIT    BV(4)
    113          #define HAL_KEY_SW_6_SEL    P0SEL
    114          #define HAL_KEY_SW_6_DIR    P0DIR
    115          
    116          /* edge interrupt */
    117          #define HAL_KEY_SW_6_EDGEBIT  BV(0)
    118          #define HAL_KEY_SW_6_EDGE     HAL_KEY_FALLING_EDGE
    119          
    120          
    121          /* SW_6 interrupts */
    122          #define HAL_KEY_SW_6_IEN      IEN1  /* CPU interrupt mask register */
    123          #define HAL_KEY_SW_6_IENBIT   BV(5) /* Mask bit for all of Port_0 */
    124          
    125          #define HAL_KEY_SW_6_ICTL     P0IEN /* Port Interrupt Control register */
    126          #define HAL_KEY_SW_6_ICTLBIT  BV(4) /* P0IEN - P0.1 enable/disable bit */
    127          #define HAL_KEY_SW_6_PXIFG    P0IFG /* Interrupt flag at source */
    128          
    129          /* Joy stick move at P2.0 */
    130          #define HAL_KEY_JOY_MOVE_PORT   P0
    131          #define HAL_KEY_JOY_MOVE_BIT    BV(5)
    132          #define HAL_KEY_JOY_MOVE_SEL    P0SEL
    133          #define HAL_KEY_JOY_MOVE_DIR    P0DIR
    134          
    135          /* edge interrupt */
    136          #define HAL_KEY_JOY_MOVE_EDGEBIT  BV(3)
    137          #define HAL_KEY_JOY_MOVE_EDGE     HAL_KEY_FALLING_EDGE
    138          
    139          /* Joy move interrupts */
    140          #define HAL_KEY_JOY_MOVE_IEN      IEN2  /* CPU interrupt mask register */
    141          #define HAL_KEY_JOY_MOVE_IENBIT   BV(1) /* Mask bit for all of Port_2 */
    142          #define HAL_KEY_JOY_MOVE_ICTL     P2IEN /* Port Interrupt Control register */
    143          
    144          #define HAL_KEY_JOY_MOVE_ICTLBIT  BV(0) /* P2IENL - P2.0<->P2.3 enable/disable bit */
    145          #define HAL_KEY_JOY_MOVE_PXIFG    P2IFG /* Interrupt flag at source */
    146          
    147          #define HAL_KEY_JOY_CHN   HAL_ADC_CHANNEL_6
    148          
    149          
    150          /**************************************************************************************************
    151           *                                            TYPEDEFS
    152           **************************************************************************************************/
    153          
    154          
    155          /**************************************************************************************************
    156           *                                        GLOBAL VARIABLES
    157           **************************************************************************************************/
    158          static uint8 halKeySavedKeys;     /* used to store previous key state in polling mode */
    159          static halKeyCBack_t pHalKeyProcessFunction;
    160          static uint8 HalKeyConfigured;
    161          bool Hal_KeyIntEnable;            /* interrupt enable/disable flag */
    162          
    163          /**************************************************************************************************
    164           *                                        FUNCTIONS - Local
    165           **************************************************************************************************/
    166          void halProcessKeyInterrupt(void);
    167          uint8 halGetJoyKeyInput(void);
    168          
    169          
    170          
    171          /**************************************************************************************************
    172           *                                        FUNCTIONS - API
    173           **************************************************************************************************/
    174          
    175          
    176          /**************************************************************************************************
    177           * @fn      HalKeyInit
    178           *
    179           * @brief   Initilize Key Service
    180           *
    181           * @param   none
    182           *
    183           * @return  None
    184           **************************************************************************************************/
    185          void HalKeyInit( void )
    186          {
    187            /* Initialize previous key to 0 */
    188            halKeySavedKeys = 0;
    189          
    190            HAL_KEY_SW_6_SEL &= ~(HAL_KEY_SW_6_BIT);    /* Set pin function to GPIO */
    191            HAL_KEY_SW_6_DIR &= ~(HAL_KEY_SW_6_BIT);    /* Set pin direction to Input */
    192          
    193            HAL_KEY_JOY_MOVE_SEL &= ~(HAL_KEY_JOY_MOVE_BIT); /* Set pin function to GPIO */
    194            HAL_KEY_JOY_MOVE_DIR &= ~(HAL_KEY_JOY_MOVE_BIT); /* Set pin direction to Input */
    195          
    196          
    197            /* Initialize callback function */
    198            pHalKeyProcessFunction  = NULL;
    199          
    200            /* Start with key is not configured */
    201            HalKeyConfigured = FALSE;
    202          }
    203          
    204          
    205          /**************************************************************************************************
    206           * @fn      HalKeyConfig
    207           *
    208           * @brief   Configure the Key serivce
    209           *
    210           * @param   interruptEnable - TRUE/FALSE, enable/disable interrupt
    211           *          cback - pointer to the CallBack function
    212           *
    213           * @return  None
    214           **************************************************************************************************/
    215          void HalKeyConfig (bool interruptEnable, halKeyCBack_t cback)
    216          {
    217            /* Enable/Disable Interrupt or */
    218            Hal_KeyIntEnable = interruptEnable;
    219          
    220            /* Register the callback fucntion */
    221            pHalKeyProcessFunction = cback;
    222          
    223            /* Determine if interrupt is enable or not */
    224            if (Hal_KeyIntEnable)
    225            {
    226              /* Rising/Falling edge configuratinn */
    227          
    228              PICTL &= ~(HAL_KEY_SW_6_EDGEBIT);    /* Clear the edge bit */
    229              /* For falling edge, the bit must be set. */
    230            #if (HAL_KEY_SW_6_EDGE == HAL_KEY_FALLING_EDGE)
    231              PICTL |= HAL_KEY_SW_6_EDGEBIT;
    232            #endif
    233          
    234          
    235              /* Interrupt configuration:
    236               * - Enable interrupt generation at the port
    237               * - Enable CPU interrupt
    238               * - Clear any pending interrupt
    239               */
    240              HAL_KEY_SW_6_ICTL |= HAL_KEY_SW_6_ICTLBIT;
    241              HAL_KEY_SW_6_IEN |= HAL_KEY_SW_6_IENBIT;
    242              HAL_KEY_SW_6_PXIFG = ~(HAL_KEY_SW_6_BIT);
    243          
    244          
    245          
    246              /* Rising/Falling edge configuratinn */
    247          
    248              HAL_KEY_JOY_MOVE_ICTL &= ~(HAL_KEY_JOY_MOVE_EDGEBIT);    /* Clear the edge bit */
    249              /* For falling edge, the bit must be set. */
    250            #if (HAL_KEY_JOY_MOVE_EDGE == HAL_KEY_FALLING_EDGE)
    251              HAL_KEY_JOY_MOVE_ICTL |= HAL_KEY_JOY_MOVE_EDGEBIT;
    252            #endif
    253          
    254          
    255              /* Interrupt configuration:
    256               * - Enable interrupt generation at the port
    257               * - Enable CPU interrupt
    258               * - Clear any pending interrupt
    259               */
    260              HAL_KEY_JOY_MOVE_ICTL |= HAL_KEY_JOY_MOVE_ICTLBIT;
    261              HAL_KEY_JOY_MOVE_IEN |= HAL_KEY_JOY_MOVE_IENBIT;
    262              HAL_KEY_JOY_MOVE_PXIFG = ~(HAL_KEY_JOY_MOVE_BIT);
    263          
    264          
    265              /* Do this only after the hal_key is configured - to work with sleep stuff */
    266              if (HalKeyConfigured == TRUE)
    267              {
    268                osal_stop_timerEx(Hal_TaskID, HAL_KEY_EVENT);  /* Cancel polling if active */
    269              }
    270            }
    271            else    /* Interrupts NOT enabled */
    272            {
    273              HAL_KEY_SW_6_ICTL &= ~(HAL_KEY_SW_6_ICTLBIT); /* don't generate interrupt */
    274              HAL_KEY_SW_6_IEN &= ~(HAL_KEY_SW_6_IENBIT);   /* Clear interrupt enable bit */
    275          
    276              osal_set_event(Hal_TaskID, HAL_KEY_EVENT);
    277            }
    278          
    279            /* Key now is configured */
    280            HalKeyConfigured = TRUE;
    281          }
    282          
    283          
    284          /**************************************************************************************************
    285           * @fn      HalKeyRead
    286           *
    287           * @brief   Read the current value of a key
    288           *
    289           * @param   None
    290           *
    291           * @return  keys - current keys status
    292           **************************************************************************************************/
    293          uint8 HalKeyRead ( void )
    294          {
    295            uint8 keys = 0;
    296          
    297            if (HAL_PUSH_BUTTON1())
    298            {
    299              keys |= HAL_KEY_SW_6;
    300            }
    301          
    302            if ((HAL_KEY_JOY_MOVE_PORT & HAL_KEY_JOY_MOVE_BIT))  /* Key is active low */
    303            {
    304              keys |= halGetJoyKeyInput();
    305            }
    306          
    307            return keys;
    308          }
    309          
    310          
    311          /**************************************************************************************************
    312           * @fn      HalKeyPoll
    313           *
    314           * @brief   Called by hal_driver to poll the keys
    315           *
    316           * @param   None
    317           *
    318           * @return  None
    319           **************************************************************************************************/
    320          void HalKeyPoll (void)
    321          {
    322            uint8 keys = 0;
    323          
    324            if ((HAL_KEY_JOY_MOVE_PORT & HAL_KEY_JOY_MOVE_BIT))  /* Key is active HIGH */
    325            {
    326              keys = halGetJoyKeyInput();
    327            }
    328          
    329            /* If interrupts are not enabled, previous key status and current key status
    330             * are compared to find out if a key has changed status.
    331             */
    332            if (!Hal_KeyIntEnable)
    333            {
    334              if (keys == halKeySavedKeys)
    335              {
    336                /* Exit - since no keys have changed */
    337                return;
    338              }
    339              /* Store the current keys for comparation next time */
    340              halKeySavedKeys = keys;
    341            }
    342            else
    343            {
    344              /* Key interrupt handled here */
    345            }
    346          
    347            if (HAL_PUSH_BUTTON1())
    348            {
    349              keys |= HAL_KEY_SW_6;
    350            }
    351          
    352            /* Invoke Callback if new keys were depressed */
    353            if (keys && (pHalKeyProcessFunction))
    354            {
    355              (pHalKeyProcessFunction) (keys, HAL_KEY_STATE_NORMAL);
    356            }
    357          }
    358          
    359          /**************************************************************************************************
    360           * @fn      halGetJoyKeyInput
    361           *
    362           * @brief   Map the ADC value to its corresponding key.
    363           *
    364           * @param   None
    365           *
    366           * @return  keys - current joy key status
    367           **************************************************************************************************/
    368          uint8 halGetJoyKeyInput(void)
    369          {
    370            /* The joystick control is encoded as an analog voltage.
    371             * Read the JOY_LEVEL analog value and map it to joy movement.
    372             */
    373            uint8 adc;
    374            uint8 ksave0 = 0;
    375            uint8 ksave1;
    376          
    377            /* Keep on reading the ADC until two consecutive key decisions are the same. */
    378            do
    379            {
    380              ksave1 = ksave0;    /* save previouse key reading */
    381          
    382              adc = HalAdcRead (HAL_KEY_JOY_CHN, HAL_ADC_RESOLUTION_8);
    383          
    384              if ((adc >= 2) && (adc <= 38))
    385              {
    386                 ksave0 |= HAL_KEY_UP;
    387              }
    388              else if ((adc >= 74) && (adc <= 88))
    389              {
    390                ksave0 |= HAL_KEY_RIGHT;
    391              }
    392              else if ((adc >= 60) && (adc <= 73))
    393              {
    394                ksave0 |= HAL_KEY_LEFT;
    395              }
    396              else if ((adc >= 39) && (adc <= 59))
    397              {
    398                ksave0 |= HAL_KEY_DOWN;
    399              }
    400              else if ((adc >= 89) && (adc <= 100))
    401              {
    402                ksave0 |= HAL_KEY_CENTER;
    403              }
    404            } while (ksave0 != ksave1);
    405          
    406            return ksave0;
    407          }
    408          
    409          
    410          
    411          
    412          
    413          /**************************************************************************************************
    414           * @fn      halProcessKeyInterrupt
    415           *
    416           * @brief   Checks to see if it's a valid key interrupt, saves interrupt driven key states for
    417           *          processing by HalKeyRead(), and debounces keys by scheduling HalKeyRead() 25ms later.
    418           *
    419           * @param
    420           *
    421           * @return
    422           **************************************************************************************************/
    423          void halProcessKeyInterrupt (void)
    424          {
    425            bool valid=FALSE;
    426          
    427            if (HAL_KEY_SW_6_PXIFG & HAL_KEY_SW_6_BIT)  /* Interrupt Flag has been set */
    428            {
    429              HAL_KEY_SW_6_PXIFG = ~(HAL_KEY_SW_6_BIT); /* Clear Interrupt Flag */
    430              valid = TRUE;
    431            }
    432          
    433            if (HAL_KEY_JOY_MOVE_PXIFG & HAL_KEY_JOY_MOVE_BIT)  /* Interrupt Flag has been set */
    434            {
    435              HAL_KEY_JOY_MOVE_PXIFG = ~(HAL_KEY_JOY_MOVE_BIT); /* Clear Interrupt Flag */
    436              valid = TRUE;
    437            }
    438          
    439            if (valid)
    440            {
    441              osal_start_timerEx (Hal_TaskID, HAL_KEY_EVENT, HAL_KEY_DEBOUNCE_VALUE);
    442            }
    443          }
    444          
    445          /**************************************************************************************************
    446           * @fn      HalKeyEnterSleep
    447           *
    448           * @brief  - Get called to enter sleep mode
    449           *
    450           * @param
    451           *
    452           * @return
    453           **************************************************************************************************/
    454          void HalKeyEnterSleep ( void )
    455          {
    456          }
    457          
    458          /**************************************************************************************************
    459           * @fn      HalKeyExitSleep
    460           *
    461           * @brief   - Get called when sleep is over
    462           *
    463           * @param
    464           *
    465           * @return  - return saved keys
    466           **************************************************************************************************/
    467          uint8 HalKeyExitSleep ( void )
    468          {
    469            /* Wake up and read keys */
    470            return ( HalKeyRead () );
    471          }
    472          
    473          /***************************************************************************************************
    474           *                                    INTERRUPT SERVICE ROUTINE
    475           ***************************************************************************************************/
    476          
    477          /**************************************************************************************************
    478           * @fn      halKeyPort0Isr
    479           *
    480           * @brief   Port0 ISR
    481           *
    482           * @param
    483           *
    484           * @return
    485           **************************************************************************************************/
    486          HAL_ISR_FUNCTION( halKeyPort0Isr, P0INT_VECTOR )
    487          {
    488            HAL_ENTER_ISR();
    489          
    490            if (HAL_KEY_SW_6_PXIFG & HAL_KEY_SW_6_BIT)
    491            {
    492              halProcessKeyInterrupt();
    493            }
    494          
    495            /*
    496              Clear the CPU interrupt flag for Port_0
    497              PxIFG has to be cleared before PxIF
    498            */
    499            HAL_KEY_SW_6_PXIFG = 0;
    500            HAL_KEY_CPU_PORT_0_IF = 0;
    501            
    502            CLEAR_SLEEP_MODE();
    503            HAL_EXIT_ISR();
    504          }
    505          
    506          
    507          /**************************************************************************************************
    508           * @fn      halKeyPort2Isr
    509           *
    510           * @brief   Port2 ISR
    511           *
    512           * @param
    513           *
    514           * @return
    515           **************************************************************************************************/
    516          HAL_ISR_FUNCTION( halKeyPort2Isr, P2INT_VECTOR )
    517          {
    518            HAL_ENTER_ISR();
    519            
    520            if (HAL_KEY_JOY_MOVE_PXIFG & HAL_KEY_JOY_MOVE_BIT)
    521            {
    522              halProcessKeyInterrupt();
    523            }
    524          
    525            /*
    526              Clear the CPU interrupt flag for Port_2
    527              PxIFG has to be cleared before PxIF
    528              Notes: P2_1 and P2_2 are debug lines.
    529            */
    530            HAL_KEY_JOY_MOVE_PXIFG = 0;
    531            HAL_KEY_CPU_PORT_2_IF = 0;
    532          
    533            CLEAR_SLEEP_MODE();
    534            HAL_EXIT_ISR();
    535          }
    536          
    537          #else
    538          
    539          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    540          void HalKeyInit(void){}
   \                     HalKeyInit:
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   \   000000   02....       LJMP    ?BRET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    541          void HalKeyConfig(bool interruptEnable, halKeyCBack_t cback){}
   \                     HalKeyConfig:
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   \   000000   02....       LJMP    ?BRET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    542          uint8 HalKeyRead(void){ return 0;}
   \                     HalKeyRead:
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   \   000000   7900         MOV     R1,#0x0
   \   000002   02....       LJMP    ?BRET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    543          void HalKeyPoll(void){}
   \                     HalKeyPoll:
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   \   000000   02....       LJMP    ?BRET

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalKeyInit?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalKeyInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalKeyConfig?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalKeyConfig

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalKeyRead?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalKeyRead

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalKeyPoll?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalKeyPoll
    544          
    545          #endif /* HAL_KEY */
    546          
    547          
    548          
    549          
    550          
    551          /**************************************************************************************************
    552          **************************************************************************************************/
    553          
    554          
    555          

   Maximum stack usage in bytes:

     Function     ISTACK PSTACK XSTACK
     --------     ------ ------ ------
     HalKeyConfig     0      0      0
     HalKeyInit       0      0      0
     HalKeyPoll       0      0      0
     HalKeyRead       0      0      0


   Segment part sizes:

     Function/Label       Bytes
     --------------       -----
     HalKeyInit              3
     HalKeyConfig            3
     HalKeyRead              5
     HalKeyPoll              3
     ??HalKeyInit?relay      6
     ??HalKeyConfig?relay    6
     ??HalKeyRead?relay      6
     ??HalKeyPoll?relay      6

 
 14 bytes in segment BANKED_CODE
 24 bytes in segment BANK_RELAYS
 
 38 bytes of CODE memory

Errors: none
Warnings: none
