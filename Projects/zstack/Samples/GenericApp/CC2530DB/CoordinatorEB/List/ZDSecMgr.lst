###############################################################################
#                                                                             #
# IAR C/C++ Compiler V7.60.1.40026 for 8051             09/Apr/2014  09:37:43 #
# Copyright (C) 2004-2010 IAR Systems AB.                                     #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  banked                                             #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data_rom                                           #
#    Dptr setup         =  1,16                                               #
#    Source file        =  D:\zigbee\projects\zstack-cc2530-coordinator\Compo #
#                          nents\stack\zdo\ZDSecMgr.c                         #
#    Command line       =  -f D:\zigbee\projects\zstack-cc2530-coordinator\Pr #
#                          ojects\zstack\Samples\GenericApp\CC2530DB\..\..\.. #
#                          \Tools\CC2530DB\f8wCoord.cfg (-DCPU32MHZ           #
#                          -DROOT=__near_func -DMAC_CFG_APP_PENDING_QUEUE=TRU #
#                          E -DMAC_CFG_TX_DATA_MAX=5 -DMAC_CFG_TX_MAX=8       #
#                          -DMAC_CFG_RX_MAX=5 -DZDO_COORDINATOR -DRTR_NWK)    #
#                          -f D:\zigbee\projects\zstack-cc2530-coordinator\Pr #
#                          ojects\zstack\Samples\GenericApp\CC2530DB\..\..\.. #
#                          \Tools\CC2530DB\f8wConfig.cfg (-DZIGBEEPRO         #
#                          -DSECURE=0 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR       #
#                          -DDEFAULT_CHANLIST=0x00000800                      #
#                          -DZDAPP_CONFIG_PAN_ID=0x1111                       #
#                          -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MA #
#                          SK=0x007F -DBEACON_REQUEST_DELAY=100               #
#                          -DBEACON_REQ_DELAY_MASK=0x00FF                     #
#                          -DLINK_STATUS_JITTER_MASK=0x007F                   #
#                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_PO #
#                          LLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7             #
#                          -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3    #
#                          -DNWK_MAX_DATA_RETRIES=2                           #
#                          -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9         #
#                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40           #
#                          -DNWK_MAX_BINDING_ENTRIES=4                        #
#                          -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01,  #
#                          0x03, 0x05, 0x07, 0x09, 0x0B, 0x0D, 0x0F, 0x00,    #
#                          0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0D}"         #
#                          -DMAC_MAX_FRAME_SIZE=116                           #
#                          -DZDNWKMGR_MIN_TRANSMISSIONS=20 "-DCONST=const     #
#                          __code" -DGENERIC=__generic                        #
#                          -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=1000        #
#                          -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100)   #
#                          -DREJOIN_POLL_RATE=440 D:\zigbee\projects\zstack-c #
#                          c2530-coordinator\Components\stack\zdo\ZDSecMgr.c  #
#                          -D ZAPP_P1 -D MT_TASK -D MT_SYS_FUNC -D            #
#                          MT_ZDO_FUNC -D HAL_UART -D HAL_UART=TRUE -D        #
#                          HAL_DMA=TRUE -D HAL_LCD=FALSE -D HAL_KEY=FALSE     #
#                          -lC D:\zigbee\projects\zstack-cc2530-coordinator\P #
#                          rojects\zstack\Samples\GenericApp\CC2530DB\Coordin #
#                          atorEB\List\ -lA D:\zigbee\projects\zstack-cc2530- #
#                          coordinator\Projects\zstack\Samples\GenericApp\CC2 #
#                          530DB\CoordinatorEB\List\ --diag_suppress          #
#                          Pe001,Pa010 -o D:\zigbee\projects\zstack-cc2530-co #
#                          ordinator\Projects\zstack\Samples\GenericApp\CC253 #
#                          0DB\CoordinatorEB\Obj\ -e --require_prototypes     #
#                          --no_code_motion --debug --core=plain --dptr=16,1  #
#                          --data_model=large --code_model=banked             #
#                          --calling_convention=xdata_reentrant               #
#                          --place_constants=data_rom --nr_virtual_regs 16    #
#                          -I D:\zigbee\projects\zstack-cc2530-coordinator\Pr #
#                          ojects\zstack\Samples\GenericApp\CC2530DB\ -I      #
#                          D:\zigbee\projects\zstack-cc2530-coordinator\Proje #
#                          cts\zstack\Samples\GenericApp\CC2530DB\..\Source\  #
#                          -I D:\zigbee\projects\zstack-cc2530-coordinator\Pr #
#                          ojects\zstack\Samples\GenericApp\CC2530DB\..\..\.. #
#                          \ZMain\TI2530DB\ -I D:\zigbee\projects\zstack-cc25 #
#                          30-coordinator\Projects\zstack\Samples\GenericApp\ #
#                          CC2530DB\..\..\..\..\..\Components\hal\include\    #
#                          -I D:\zigbee\projects\zstack-cc2530-coordinator\Pr #
#                          ojects\zstack\Samples\GenericApp\CC2530DB\..\..\.. #
#                          \..\..\Components\hal\target\CC2530EB\ -I          #
#                          D:\zigbee\projects\zstack-cc2530-coordinator\Proje #
#                          cts\zstack\Samples\GenericApp\CC2530DB\..\..\..\.. #
#                          \..\Components\mac\include\ -I                     #
#                          D:\zigbee\projects\zstack-cc2530-coordinator\Proje #
#                          cts\zstack\Samples\GenericApp\CC2530DB\..\..\..\.. #
#                          \..\Components\mac\high_level\ -I                  #
#                          D:\zigbee\projects\zstack-cc2530-coordinator\Proje #
#                          cts\zstack\Samples\GenericApp\CC2530DB\..\..\..\.. #
#                          \..\Components\mac\low_level\srf04\ -I             #
#                          D:\zigbee\projects\zstack-cc2530-coordinator\Proje #
#                          cts\zstack\Samples\GenericApp\CC2530DB\..\..\..\.. #
#                          \..\Components\mac\low_level\srf04\single_chip\    #
#                          -I D:\zigbee\projects\zstack-cc2530-coordinator\Pr #
#                          ojects\zstack\Samples\GenericApp\CC2530DB\..\..\.. #
#                          \..\..\Components\mt\ -I                           #
#                          D:\zigbee\projects\zstack-cc2530-coordinator\Proje #
#                          cts\zstack\Samples\GenericApp\CC2530DB\..\..\..\.. #
#                          \..\Components\osal\include\ -I                    #
#                          D:\zigbee\projects\zstack-cc2530-coordinator\Proje #
#                          cts\zstack\Samples\GenericApp\CC2530DB\..\..\..\.. #
#                          \..\Components\osal\mcu\ccsoc\ -I                  #
#                          D:\zigbee\projects\zstack-cc2530-coordinator\Proje #
#                          cts\zstack\Samples\GenericApp\CC2530DB\..\..\..\.. #
#                          \..\Components\services\saddr\ -I                  #
#                          D:\zigbee\projects\zstack-cc2530-coordinator\Proje #
#                          cts\zstack\Samples\GenericApp\CC2530DB\..\..\..\.. #
#                          \..\Components\services\sdata\ -I                  #
#                          D:\zigbee\projects\zstack-cc2530-coordinator\Proje #
#                          cts\zstack\Samples\GenericApp\CC2530DB\..\..\..\.. #
#                          \..\Components\stack\af\ -I                        #
#                          D:\zigbee\projects\zstack-cc2530-coordinator\Proje #
#                          cts\zstack\Samples\GenericApp\CC2530DB\..\..\..\.. #
#                          \..\Components\stack\nwk\ -I                       #
#                          D:\zigbee\projects\zstack-cc2530-coordinator\Proje #
#                          cts\zstack\Samples\GenericApp\CC2530DB\..\..\..\.. #
#                          \..\Components\stack\sapi\ -I                      #
#                          D:\zigbee\projects\zstack-cc2530-coordinator\Proje #
#                          cts\zstack\Samples\GenericApp\CC2530DB\..\..\..\.. #
#                          \..\Components\stack\sec\ -I                       #
#                          D:\zigbee\projects\zstack-cc2530-coordinator\Proje #
#                          cts\zstack\Samples\GenericApp\CC2530DB\..\..\..\.. #
#                          \..\Components\stack\sys\ -I                       #
#                          D:\zigbee\projects\zstack-cc2530-coordinator\Proje #
#                          cts\zstack\Samples\GenericApp\CC2530DB\..\..\..\.. #
#                          \..\Components\stack\zdo\ -I                       #
#                          D:\zigbee\projects\zstack-cc2530-coordinator\Proje #
#                          cts\zstack\Samples\GenericApp\CC2530DB\..\..\..\.. #
#                          \..\Components\zmac\ -I D:\zigbee\projects\zstack- #
#                          cc2530-coordinator\Projects\zstack\Samples\Generic #
#                          App\CC2530DB\..\..\..\..\..\Components\zmac\f8w\   #
#                          -I "C:\Program Files (x86)\IAR Systems\Embedded    #
#                          Workbench 5.4\8051\INC\" -I "C:\Program Files      #
#                          (x86)\IAR Systems\Embedded Workbench               #
#                          5.4\8051\INC\CLIB\" -Ohz                           #
#    List file          =  D:\zigbee\projects\zstack-cc2530-coordinator\Proje #
#                          cts\zstack\Samples\GenericApp\CC2530DB\Coordinator #
#                          EB\List\ZDSecMgr.lst                               #
#    Object file        =  D:\zigbee\projects\zstack-cc2530-coordinator\Proje #
#                          cts\zstack\Samples\GenericApp\CC2530DB\Coordinator #
#                          EB\Obj\ZDSecMgr.r51                                #
#                                                                             #
#                                                                             #
###############################################################################

D:\zigbee\projects\zstack-cc2530-coordinator\Components\stack\zdo\ZDSecMgr.c
      1          /**************************************************************************************************
      2            Filename:       ZDSecMgr.c
      3            Revised:        $Date: 2010-08-20 16:29:19 -0700 (Fri, 20 Aug 2010) $
      4            Revision:       $Revision: 23466 $
      5          
      6            Description:    The ZigBee Device Security Manager.
      7          
      8          
      9            Copyright 2005-2010 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License").  You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product.  Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com.
     38          **************************************************************************************************/
     39          
     40          #ifdef __cplusplus
     41          extern "C"
     42          {
     43          #endif
     44          
     45          /******************************************************************************
     46           * INCLUDES
     47           */
     48          #include "ZComdef.h"
     49          #include "OSAL.h"
     50          #include "OSAL_NV.h"
     51          #include "ZGlobals.h"
     52          #include "ssp.h"
     53          #include "nwk_globals.h"
     54          #include "nwk.h"
     55          #include "NLMEDE.h"
     56          #include "AddrMgr.h"
     57          #include "AssocList.h"
     58          #include "APSMEDE.h"
     59          #include "AF.h"
     60          #include "ZDConfig.h"
     61          #include "ZDApp.h"
     62          #include "ZDSecMgr.h"
     63          
     64          
     65          /******************************************************************************
     66           * CONSTANTS
     67           */
     68          // maximum number of devices managed by this Security Manager
     69          #if !defined ( ZDSECMGR_DEVICE_MAX )
     70            #define ZDSECMGR_DEVICE_MAX 3
     71          #endif
     72          
     73          // total number of preconfigured devices (EXT address, MASTER key)
     74          //devtag.pro.security
     75          //#define ZDSECMGR_PRECONFIG_MAX ZDSECMGR_DEVICE_MAX
     76          #define ZDSECMGR_PRECONFIG_MAX 0
     77          
     78          // maximum number of MASTER keys this device may hold
     79          #define ZDSECMGR_MASTERKEY_MAX ZDSECMGR_DEVICE_MAX
     80          
     81          // maximum number of LINK keys this device may store
     82          #define ZDSECMGR_ENTRY_MAX ZDSECMGR_DEVICE_MAX
     83          
     84          // total number of devices under control - authentication, SKKE, etc.
     85          #define ZDSECMGR_CTRL_MAX ZDSECMGR_DEVICE_MAX
     86          
     87          // total number of stored devices
     88          #if !defined ( ZDSECMGR_STORED_DEVICES )
     89            #define ZDSECMGR_STORED_DEVICES 3
     90          #endif
     91            
     92          // Total number of preconfigured trust center link key
     93          #if !defined ( ZDSECMGR_TC_DEVICE_MAX )
     94            #define ZDSECMGR_TC_DEVICE_MAX 1
     95          #endif
     96            
     97          #if ( ZDSECMGR_TC_DEVICE_MAX < 1 ) || ( ZDSECMGR_TC_DEVICE_MAX > 255 )
     98            #error "ZDSECMGR_TC_DEVICE_MAX shall be between 1 and 255 !"
     99          #endif
    100            
    101          #define ZDSECMGR_CTRL_NONE       0
    102          #define ZDSECMGR_CTRL_INIT       1
    103          #define ZDSECMGR_CTRL_TK_MASTER  2
    104          #define ZDSECMGR_CTRL_SKKE_INIT  3
    105          #define ZDSECMGR_CTRL_SKKE_WAIT  4
    106          #define ZDSECMGR_CTRL_SKKE_DONE  5
    107          #define ZDSECMGR_CTRL_SKKE_FAIL  6
    108          #define ZDSECMGR_CTRL_TK_NWK     7
    109          
    110          #define ZDSECMGR_CTRL_BASE_CNTR      1
    111          #define ZDSECMGR_CTRL_SKKE_INIT_CNTR 1
    112          #define ZDSECMGR_CTRL_TK_NWK_CNTR    1
    113          
    114          // set SKA slot maximum
    115          #define ZDSECMGR_SKA_SLOT_MAX 1
    116          
    117          // APSME Stub Implementations
    118          #define ZDSecMgrMasterKeyGet   APSME_MasterKeyGet
    119          #define ZDSecMgrLinkKeySet     APSME_LinkKeySet
    120          #define ZDSecMgrLinkKeyNVIdGet APSME_LinkKeyNVIdGet
    121          #define ZDSecMgrKeyFwdToChild  APSME_KeyFwdToChild
    122          #define ZDSecMgrIsLinkKeyValid APSME_IsLinkKeyValid
    123          
    124          /******************************************************************************
    125           * TYPEDEFS
    126           */
    127          typedef struct
    128          {
    129            uint8 extAddr[Z_EXTADDR_LEN];
    130            uint8 key[SEC_KEY_LEN];
    131          } ZDSecMgrPreConfigData_t;
    132          
    133          typedef struct
    134          {
    135            uint16 ami;
    136            uint8  key[SEC_KEY_LEN];
    137          } ZDSecMgrMasterKeyData_t;
    138          
    139          typedef struct
    140          {
    141            uint16            ami;
    142            uint16            keyNvId;   // index to the Link Key table in NV
    143            ZDSecMgr_Authentication_Option authenticateOption;
    144          } ZDSecMgrEntry_t;
    145          
    146          typedef struct
    147          {
    148            ZDSecMgrEntry_t* entry;
    149            uint16           parentAddr;
    150            uint8            secure;
    151            uint8            state;
    152            uint8            cntr;
    153          } ZDSecMgrCtrl_t;
    154          
    155          typedef struct
    156          {
    157            uint16          nwkAddr;
    158            uint8*          extAddr;
    159            uint16          parentAddr;
    160            uint8           secure;
    161            uint8           devStatus;
    162            ZDSecMgrCtrl_t* ctrl;
    163          } ZDSecMgrDevice_t;
    164          
    165          /******************************************************************************
    166           * LOCAL VARIABLES
    167           */
    168          #if 0 // Taken out because the following functionality is only used for test
    169                // purpose. A more efficient (above) way is used. It can be put
    170                // back in if customers request for a white/black list feature.
    171          uint8 ZDSecMgrStoredDeviceList[ZDSECMGR_STORED_DEVICES][Z_EXTADDR_LEN] =
    172          {
    173            { 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
    174            { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01 },
    175            { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
    176          };
    177          #endif
    178          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    179          uint8 ZDSecMgrTCExtAddr[Z_EXTADDR_LEN]=
   \                     ZDSecMgrTCExtAddr:
   \   000000                DS 8
   \   000008                REQUIRE __INIT_XDATA_Z
    180            { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
    181          
    182          // Key data is put in CONST area for security reasons

   \                                 In  segment CODE_C, align 1
    183          CONST uint8 ZDSecMgrTCMasterKey[SEC_KEY_LEN] =
   \                     ZDSecMgrTCMasterKey:
   \   000000   00000000     DB 0, 0, 0, 0, 0, 0, 0, 0, 137, 103, 69, 35, 1, 239, 205, 171
   \            00000000
   \            89674523
   \            01EFCDAB
    184            {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    185             0x89,0x67,0x45,0x23,0x01,0xEF,0xCD,0xAB};
    186          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    187          uint8 ZDSecMgrTCAuthenticated = FALSE;
   \                     ZDSecMgrTCAuthenticated:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    188          uint8 ZDSecMgrTCDataLoaded    = FALSE;
   \                     ZDSecMgrTCDataLoaded:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    189          
    190          //devtag.pro.security - remove this
    191          #if ( ZDSECMGR_PRECONFIG_MAX != 0 )
    192          const ZDSecMgrPreConfigData_t ZDSecMgrPreConfigData[ZDSECMGR_PRECONFIG_MAX] =
    193          {
    194            //---------------------------------------------------------------------------
    195            // DEVICE A
    196            //---------------------------------------------------------------------------
    197            {
    198              // extAddr
    199              {0x7C,0x01,0x12,0x13,0x14,0x15,0x16,0x17},
    200          
    201              // key
    202              {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    203               0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}
    204            },
    205            //---------------------------------------------------------------------------
    206            // DEVICE B
    207            //---------------------------------------------------------------------------
    208            {
    209              // extAddr
    210              {0x84,0x03,0x00,0x00,0x00,0x4B,0x12,0x00},
    211          
    212              // key
    213              {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    214               0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}
    215            },
    216            //---------------------------------------------------------------------------
    217            // DEVICE C
    218            //---------------------------------------------------------------------------
    219            {
    220              // extAddr
    221              {0x3E,0x01,0x12,0x13,0x14,0x15,0x16,0x17},
    222          
    223              // key
    224              {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    225               0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}
    226            },
    227          };
    228          #endif // ( ZDSECMGR_PRECONFIG_MAX != 0 )
    229          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    230          ZDSecMgrEntry_t* ZDSecMgrEntries  = NULL;
   \                     ZDSecMgrEntries:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    231          ZDSecMgrCtrl_t*  ZDSecMgrCtrlData = NULL;
   \                     ZDSecMgrCtrlData:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    232          void ZDSecMgrAddrMgrUpdate( uint16 ami, uint16 nwkAddr );
    233          void ZDSecMgrAddrMgrCB( uint8 update, AddrMgrEntry_t* newEntry, AddrMgrEntry_t* oldEntry );
    234          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    235          uint8 ZDSecMgrPermitJoiningEnabled;
   \                     ZDSecMgrPermitJoiningEnabled:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    236          uint8 ZDSecMgrPermitJoiningTimed;
   \                     ZDSecMgrPermitJoiningTimed:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    237          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    238          APSME_TCLinkKey_t TrustCenterLinkKey;
   \                     TrustCenterLinkKey:
   \   000000                DS 32
   \   000020                REQUIRE __INIT_XDATA_Z
    239          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    240          APSME_ApsLinkKeyFrmCntr_t ApsLinkKeyFrmCntr[ZDSECMGR_ENTRY_MAX];
   \                     ApsLinkKeyFrmCntr:
   \   000000                DS 27
   \   00001B                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    241          APSME_TCLinkKeyFrmCntr_t TCLinkKeyFrmCntr[ZDSECMGR_TC_DEVICE_MAX];
   \                     TCLinkKeyFrmCntr:
   \   000000                DS 9
   \   000009                REQUIRE __INIT_XDATA_Z
    242          
    243          /******************************************************************************
    244           * PRIVATE FUNCTIONS
    245           *
    246           *   ZDSecMgrMasterKeyInit
    247           *   ZDSecMgrAddrStore
    248           *   ZDSecMgrExtAddrStore
    249           *   ZDSecMgrExtAddrLookup
    250           *   ZDSecMgrMasterKeyLookup
    251           *   ZDSecMgrMasterKeyStore
    252           *   ZDSecMgrEntryInit
    253           *   ZDSecMgrEntryLookup
    254           *   ZDSecMgrEntryLookupAMI
    255           *   ZDSecMgrEntryLookupExt
    256           *   ZDSecMgrEntryLookupExtGetIndex
    257           *   ZDSecMgrEntryFree
    258           *   ZDSecMgrEntryNew
    259           *   ZDSecMgrCtrlInit
    260           *   ZDSecMgrCtrlRelease
    261           *   ZDSecMgrCtrlLookup
    262           *   ZDSecMgrCtrlSet
    263           *   ZDSecMgrCtrlAdd
    264           *   ZDSecMgrCtrlTerm
    265           *   ZDSecMgrCtrlReset
    266           *   ZDSecMgrMasterKeyLoad
    267           *   ZDSecMgrAppKeyGet
    268           *   ZDSecMgrAppKeyReq
    269           *   ZDSecMgrEstablishKey
    270           *   ZDSecMgrSendMasterKey
    271           *   ZDSecMgrSendNwkKey
    272           *   ZDSecMgrDeviceEntryRemove
    273           *   ZDSecMgrDeviceEntryAdd
    274           *   ZDSecMgrDeviceCtrlHandler
    275           *   ZDSecMgrDeviceCtrlSetup
    276           *   ZDSecMgrDeviceCtrlUpdate
    277           *   ZDSecMgrDeviceRemove
    278           *   ZDSecMgrDeviceValidateSKKE
    279           *   ZDSecMgrDeviceValidateRM
    280           *   ZDSecMgrDeviceValidateCM
    281           *   ZDSecMgrDeviceValidate
    282           *   ZDSecMgrDeviceJoin
    283           *   ZDSecMgrDeviceJoinDirect
    284           *   ZDSecMgrDeviceJoinFwd
    285           *   ZDSecMgrDeviceNew
    286           *   ZDSecMgrAssocDeviceAuth
    287           *   ZDSecMgrAuthInitiate
    288           *   ZDSecMgrAuthNwkKey
    289           *   APSME_TCLinkKeyInit
    290           *   APSME_IsDefaultTCLK
    291           */
    292          //-----------------------------------------------------------------------------
    293          // master key data
    294          //-----------------------------------------------------------------------------
    295          void ZDSecMgrMasterKeyInit( void );
    296          
    297          //-----------------------------------------------------------------------------
    298          // address management
    299          //-----------------------------------------------------------------------------
    300          ZStatus_t ZDSecMgrAddrStore( uint16 nwkAddr, uint8* extAddr, uint16* ami );
    301          ZStatus_t ZDSecMgrExtAddrStore( uint16 nwkAddr, uint8* extAddr, uint16* ami );
    302          ZStatus_t ZDSecMgrExtAddrLookup( uint8* extAddr, uint16* ami );
    303          
    304          //-----------------------------------------------------------------------------
    305          // MASTER key data
    306          //-----------------------------------------------------------------------------
    307          ZStatus_t ZDSecMgrMasterKeyLookup( uint16 ami, uint16* pKeyNvId );
    308          ZStatus_t ZDSecMgrMasterKeyStore( uint16 ami, uint8* key );
    309          
    310          //-----------------------------------------------------------------------------
    311          // entry data
    312          //-----------------------------------------------------------------------------
    313          void ZDSecMgrEntryInit(uint8 state);
    314          ZStatus_t ZDSecMgrEntryLookup( uint16 nwkAddr, ZDSecMgrEntry_t** entry );
    315          ZStatus_t ZDSecMgrEntryLookupAMI( uint16 ami, ZDSecMgrEntry_t** entry );
    316          ZStatus_t ZDSecMgrEntryLookupExt( uint8* extAddr, ZDSecMgrEntry_t** entry );
    317          ZStatus_t ZDSecMgrEntryLookupExtGetIndex( uint8* extAddr, ZDSecMgrEntry_t** entry, uint16* entryIndex );
    318          void ZDSecMgrEntryFree( ZDSecMgrEntry_t* entry );
    319          ZStatus_t ZDSecMgrEntryNew( ZDSecMgrEntry_t** entry );
    320          ZStatus_t ZDSecMgrAuthenticationSet( uint8* extAddr, ZDSecMgr_Authentication_Option option );
    321          void ZDSecMgrApsLinkKeyInit(void);
    322          #if defined NV_RESTORE
    323          static void ZDSecMgrWriteNV(void);
    324          static void ZDSecMgrRestoreFromNV(void);
    325          #endif
    326          
    327          //-----------------------------------------------------------------------------
    328          // control data
    329          //-----------------------------------------------------------------------------
    330          void ZDSecMgrCtrlInit( void );
    331          void ZDSecMgrCtrlRelease( ZDSecMgrCtrl_t* ctrl );
    332          void ZDSecMgrCtrlLookup( ZDSecMgrEntry_t* entry, ZDSecMgrCtrl_t** ctrl );
    333          void ZDSecMgrCtrlSet( ZDSecMgrDevice_t* device,
    334                                ZDSecMgrEntry_t*  entry,
    335                                ZDSecMgrCtrl_t*   ctrl );
    336          ZStatus_t ZDSecMgrCtrlAdd( ZDSecMgrDevice_t* device, ZDSecMgrEntry_t*  entry );
    337          void ZDSecMgrCtrlTerm( ZDSecMgrEntry_t* entry );
    338          ZStatus_t ZDSecMgrCtrlReset( ZDSecMgrDevice_t* device,
    339                                       ZDSecMgrEntry_t*  entry );
    340          
    341          //-----------------------------------------------------------------------------
    342          // key support
    343          //-----------------------------------------------------------------------------
    344          ZStatus_t ZDSecMgrMasterKeyLoad( uint8* extAddr, uint8* key );
    345          ZStatus_t ZDSecMgrAppKeyGet( uint16  initNwkAddr,
    346                                       uint8*  initExtAddr,
    347                                       uint16  partNwkAddr,
    348                                       uint8*  partExtAddr,
    349                                       uint8** key,
    350                                       uint8*  keyType );
    351          void ZDSecMgrAppKeyReq( ZDO_RequestKeyInd_t* ind );
    352          ZStatus_t ZDSecMgrEstablishKey( ZDSecMgrDevice_t* device );
    353          ZStatus_t ZDSecMgrSendMasterKey( ZDSecMgrDevice_t* device );
    354          ZStatus_t ZDSecMgrSendNwkKey( ZDSecMgrDevice_t* device );
    355          void ZDSecMgrNwkKeyInit(uint8 setDefault);
    356          
    357          //-----------------------------------------------------------------------------
    358          // device entry
    359          //-----------------------------------------------------------------------------
    360          void ZDSecMgrDeviceEntryRemove( ZDSecMgrEntry_t* entry );
    361          ZStatus_t ZDSecMgrDeviceEntryAdd( ZDSecMgrDevice_t* device, uint16 ami );
    362          
    363          //-----------------------------------------------------------------------------
    364          // device control
    365          //-----------------------------------------------------------------------------
    366          void ZDSecMgrDeviceCtrlHandler( ZDSecMgrDevice_t* device );
    367          void ZDSecMgrDeviceCtrlSetup( ZDSecMgrDevice_t* device );
    368          void ZDSecMgrDeviceCtrlUpdate( uint8* extAddr, uint8 state );
    369          
    370          //-----------------------------------------------------------------------------
    371          // device management
    372          //-----------------------------------------------------------------------------
    373          void ZDSecMgrDeviceRemove( ZDSecMgrDevice_t* device );
    374          ZStatus_t ZDSecMgrDeviceValidateSKKE( ZDSecMgrDevice_t* device );
    375          ZStatus_t ZDSecMgrDeviceValidateRM( ZDSecMgrDevice_t* device );
    376          ZStatus_t ZDSecMgrDeviceValidateCM( ZDSecMgrDevice_t* device );
    377          ZStatus_t ZDSecMgrDeviceValidate( ZDSecMgrDevice_t* device );
    378          ZStatus_t ZDSecMgrDeviceJoin( ZDSecMgrDevice_t* device );
    379          ZStatus_t ZDSecMgrDeviceJoinDirect( ZDSecMgrDevice_t* device );
    380          ZStatus_t ZDSecMgrDeviceJoinFwd( ZDSecMgrDevice_t* device );
    381          ZStatus_t ZDSecMgrDeviceNew( ZDSecMgrDevice_t* device );
    382          
    383          //-----------------------------------------------------------------------------
    384          // association management
    385          //-----------------------------------------------------------------------------
    386          void ZDSecMgrAssocDeviceAuth( associated_devices_t* assoc );
    387          
    388          //-----------------------------------------------------------------------------
    389          // authentication management
    390          //-----------------------------------------------------------------------------
    391          void ZDSecMgrAuthInitiate( uint8* responder );
    392          void ZDSecMgrAuthNwkKey( void );
    393          
    394          //-----------------------------------------------------------------------------
    395          // APSME function
    396          //-----------------------------------------------------------------------------
    397          void APSME_TCLinkKeyInit( uint8 setDefault );
    398          uint8 APSME_IsDefaultTCLK( uint8 *extAddr );
    399          
    400          /******************************************************************************
    401           * @fn          ZDSecMgrMasterKeyInit                     ]
    402           *
    403           * @brief       Initialize master key data in NV
    404           *
    405           * @param       none
    406           *
    407           * @return      none
    408           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    409          void ZDSecMgrMasterKeyInit( void )
   \                     ZDSecMgrMasterKeyInit:
    410          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 18
   \   000005   74EE         MOV     A,#-0x12
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
    411            uint16 index;
    412            ZDSecMgrMasterKeyData_t   masterKeyData;
    413          
    414            masterKeyData.ami = INVALID_NODE_ADDR;
   \   00000A   85..82       MOV     DPL,?XSP + 0
   \   00000D   85..83       MOV     DPH,?XSP + 1
   \   000010   74FE         MOV     A,#-0x2
   \   000012   F0           MOVX    @DPTR,A
   \   000013   A3           INC     DPTR
   \   000014   74FF         MOV     A,#-0x1
   \   000016   F0           MOVX    @DPTR,A
    415          
    416            osal_memset( &masterKeyData.key, 0x00, SEC_KEY_LEN );
   \   000017                ; Setup parameters for call to function osal_memset
   \   000017   7C10         MOV     R4,#0x10
   \   000019   7D00         MOV     R5,#0x0
   \   00001B   7900         MOV     R1,#0x0
   \   00001D   7402         MOV     A,#0x2
   \   00001F   12....       LCALL   ?XSTACK_DISP0_8
   \   000022   12....       LCALL   ?Subroutine39 & 0xFFFF
    417          
    418            for ( index = 0; index < ZDSECMGR_MASTERKEY_MAX; index++ )
    419            {
    420              if ( osal_nv_item_init( (ZCD_NV_MASTER_KEY_DATA_START + index), 
    421                                 sizeof(ZDSecMgrMasterKeyData_t), &masterKeyData) == SUCCESS)
   \                     ??CrossCallReturnLabel_160:
   \   000025                ; Setup parameters for call to function osal_nv_item_init
   \   000025   85..82       MOV     DPL,?XSP + 0
   \   000028   85..83       MOV     DPH,?XSP + 1
   \   00002B   8582..       MOV     ?V0 + 0,DPL
   \   00002E   8583..       MOV     ?V0 + 1,DPH
   \   000031   78..         MOV     R0,#?V0 + 0
   \   000033   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000036   7C12         MOV     R4,#0x12
   \   000038   7D00         MOV     R5,#0x0
   \   00003A   7401         MOV     A,#0x1
   \   00003C   2E           ADD     A,R6
   \   00003D   FA           MOV     R2,A
   \   00003E   7403         MOV     A,#0x3
   \   000040   3F           ADDC    A,R7
   \   000041   FB           MOV     R3,A
   \   000042   12....       LCALL   ??Subroutine146_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_338:
   \   000045   12....       LCALL   ?DEALLOC_XSTACK8
   \   000048   E9           MOV     A,R1
   \   000049   7020         JNZ     ??ZDSecMgrMasterKeyInit_0
    422              {
    423                // the item already exists in NV just needs to be set to default values
    424                osal_nv_write( (ZCD_NV_MASTER_KEY_DATA_START + index), 0, 
    425                                sizeof(ZDSecMgrMasterKeyData_t), &masterKeyData );
   \   00004B                ; Setup parameters for call to function osal_nv_write
   \   00004B   78..         MOV     R0,#?V0 + 0
   \   00004D   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000050   75..12       MOV     ?V0 + 0,#0x12
   \   000053   75..00       MOV     ?V0 + 1,#0x0
   \   000056   78..         MOV     R0,#?V0 + 0
   \   000058   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00005B   7C00         MOV     R4,#0x0
   \   00005D   7D00         MOV     R5,#0x0
   \   00005F   7401         MOV     A,#0x1
   \   000061   2E           ADD     A,R6
   \   000062   FA           MOV     R2,A
   \   000063   7403         MOV     A,#0x3
   \   000065   12....       LCALL   ??Subroutine108_0 & 0xFFFF
    426              }
    427            }
   \                     ??CrossCallReturnLabel_172:
   \   000068   12....       LCALL   ?DEALLOC_XSTACK8
   \                     ??ZDSecMgrMasterKeyInit_0:
   \   00006B   12....       LCALL   ?Subroutine34 & 0xFFFF
   \                     ??CrossCallReturnLabel_45:
   \   00006E   40B5         JC      ??CrossCallReturnLabel_160
    428          }
   \   000070   7412         MOV     A,#0x12
   \   000072   02....       LJMP    ??Subroutine118_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine39:
   \   000000   AA82         MOV     R2,DPL
   \   000002   AB83         MOV     R3,DPH
   \   000004                REQUIRE ??Subroutine105_0
   \   000004                ; // Fall through to label ??Subroutine105_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine105_0:
   \   000000   12....       LCALL   ??osal_memset?relay
   \   000003   7E00         MOV     R6,#0x0
   \   000005   7F00         MOV     R7,#0x0
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine108_0:
   \   000000   3F           ADDC    A,R7
   \   000001                REQUIRE ??Subroutine109_0
   \   000001                ; // Fall through to label ??Subroutine109_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine109_0:
   \   000000   FB           MOV     R3,A
   \   000001                REQUIRE ??Subroutine110_0
   \   000001                ; // Fall through to label ??Subroutine110_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine110_0:
   \   000000   12....       LCALL   ??osal_nv_write?relay
   \   000003   7404         MOV     A,#0x4
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine118_0:
   \   000000   12....       LCALL   ?DEALLOC_XSTACK8
   \   000003                REQUIRE ??Subroutine119_0
   \   000003                ; // Fall through to label ??Subroutine119_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine119_0:
   \   000000   7F02         MOV     R7,#0x2
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine34:
   \   000000   EE           MOV     A,R6
   \   000001   2401         ADD     A,#0x1
   \   000003   0E           INC     R6
   \   000004   EF           MOV     A,R7
   \   000005   3400         ADDC    A,#0x0
   \   000007   FF           MOV     R7,A
   \   000008   C3           CLR     C
   \   000009   EE           MOV     A,R6
   \   00000A   9403         SUBB    A,#0x3
   \   00000C   EF           MOV     A,R7
   \   00000D   9400         SUBB    A,#0x0
   \   00000F   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine146_0:
   \   000000   12....       LCALL   ??osal_nv_item_init?relay
   \   000003   7402         MOV     A,#0x2
   \   000005   22           RET
    429          
    430          /******************************************************************************
    431           * @fn          ZDSecMgrAddrStore
    432           *
    433           * @brief       Store device addresses.
    434           *
    435           * @param       nwkAddr - [in] NWK address
    436           * @param       extAddr - [in] EXT address
    437           * @param       ami     - [out] Address Manager index
    438           *
    439           * @return      ZStatus_t
    440           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    441          ZStatus_t ZDSecMgrAddrStore( uint16 nwkAddr, uint8* extAddr, uint16* ami )
   \                     ZDSecMgrAddrStore:
    442          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 13
   \   000005   74F3         MOV     A,#-0xd
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   7416         MOV     A,#0x16
   \   00000C   12....       LCALL   ?XSTACK_DISP0_8
   \   00000F   12....       LCALL   ?Subroutine49 & 0xFFFF
    443            ZStatus_t      status;
    444            AddrMgrEntry_t entry;
    445          
    446          
    447            // add entry
    448            entry.user    = ADDRMGR_USER_SECURITY;
    449            entry.nwkAddr = nwkAddr;
   \                     ??CrossCallReturnLabel_69:
   \   000012   12....       LCALL   ?XSTACK_DISP0_8
   \   000015   12....       LCALL   ?Subroutine29 & 0xFFFF
    450            AddrMgrExtAddrSet( entry.extAddr, extAddr );
   \                     ??CrossCallReturnLabel_34:
   \   000018                ; Setup parameters for call to function AddrMgrExtAddrSet
   \   000018   7403         MOV     A,#0x3
   \   00001A   12....       LCALL   ?XSTACK_DISP0_8
   \   00001D   12....       LCALL   ?Subroutine74 & 0xFFFF
    451          
    452            if ( AddrMgrEntryUpdate( &entry ) == TRUE )
   \                     ??CrossCallReturnLabel_111:
   \   000020   700A         JNZ     ??ZDSecMgrAddrStore_0
    453            {
    454              // return successful results
    455              *ami   = entry.index;
   \   000022   740B         MOV     A,#0xb
   \   000024   12....       LCALL   ?XSTACK_DISP0_8
   \   000027   12....       LCALL   ?Subroutine12 & 0xFFFF
    456              status = ZSuccess;
    457            }
   \                     ??CrossCallReturnLabel_163:
   \   00002A   8008         SJMP    ??CrossCallReturnLabel_42
    458            else
    459            {
    460              // return failed results
    461              *ami   = entry.index;
   \                     ??ZDSecMgrAddrStore_0:
   \   00002C   740B         MOV     A,#0xb
   \   00002E   12....       LCALL   ?XSTACK_DISP0_8
   \   000031   12....       LCALL   ?Subroutine30 & 0xFFFF
    462              status = ZNwkUnknownDevice;
    463            }
    464          
    465            return status;
   \                     ??CrossCallReturnLabel_42:
   \   000034   02....       LJMP    ?Subroutine8 & 0xFFFF
    466          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine74:
   \   000000   12....       LCALL   ?Subroutine89 & 0xFFFF
   \                     ??CrossCallReturnLabel_135:
   \   000003   12....       LCALL   ??AddrMgrEntryUpdate?relay
   \   000006   E9           MOV     A,R1
   \   000007   6401         XRL     A,#0x1
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine49:
   \   000000   12....       LCALL   ?Subroutine94 & 0xFFFF
   \                     ??CrossCallReturnLabel_323:
   \   000003   E8           MOV     A,R0
   \   000004   FE           MOV     R6,A
   \   000005   E9           MOV     A,R1
   \   000006   FF           MOV     R7,A
   \   000007   7402         MOV     A,#0x2
   \   000009   85..82       MOV     DPL,?XSP + 0
   \   00000C   85..83       MOV     DPH,?XSP + 1
   \   00000F   F0           MOVX    @DPTR,A
   \   000010   7401         MOV     A,#0x1
   \   000012   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine30:
   \   000000   12....       LCALL   ?Subroutine94 & 0xFFFF
   \                     ??CrossCallReturnLabel_322:
   \   000003   8E82         MOV     DPL,R6
   \   000005   8F83         MOV     DPH,R7
   \   000007   12....       LCALL   ?Subroutine87 & 0xFFFF
   \                     ??CrossCallReturnLabel_250:
   \   00000A   79C8         MOV     R1,#-0x38
   \   00000C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine8:
   \   000000   740D         MOV     A,#0xd
   \   000002   02....       LJMP    ??Subroutine132_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine89:
   \   000000   AA82         MOV     R2,DPL
   \   000002   AB83         MOV     R3,DPH
   \   000004   12....       LCALL   ??AddrMgrExtAddrSet?relay
   \   000007                ; Setup parameters for call to function AddrMgrEntryUpdate
   \   000007                ; Setup parameters for call to function AddrMgrEntryUpdate
   \   000007                ; Setup parameters for call to function AddrMgrEntryLookupExt
   \   000007   85..82       MOV     DPL,?XSP + 0
   \   00000A   85..83       MOV     DPH,?XSP + 1
   \   00000D   AA82         MOV     R2,DPL
   \   00000F   AB83         MOV     R3,DPH
   \   000011   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine12:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004                REQUIRE ??Subroutine106_0
   \   000004                ; // Fall through to label ??Subroutine106_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine106_0:
   \   000000   F9           MOV     R1,A
   \   000001   8E82         MOV     DPL,R6
   \   000003   8F83         MOV     DPH,R7
   \   000005                REQUIRE ??Subroutine107_0
   \   000005                ; // Fall through to label ??Subroutine107_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine107_0:
   \   000000   12....       LCALL   ?Subroutine87 & 0xFFFF
   \                     ??CrossCallReturnLabel_251:
   \   000003   7900         MOV     R1,#0x0
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine29:
   \   000000   EA           MOV     A,R2
   \   000001   F0           MOVX    @DPTR,A
   \   000002   A3           INC     DPTR
   \   000003   EB           MOV     A,R3
   \   000004   F0           MOVX    @DPTR,A
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine87:
   \   000000   E8           MOV     A,R0
   \   000001   F0           MOVX    @DPTR,A
   \   000002   A3           INC     DPTR
   \   000003   E9           MOV     A,R1
   \   000004   F0           MOVX    @DPTR,A
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine132_0:
   \   000000   12....       LCALL   ?DEALLOC_XSTACK8
   \   000003                REQUIRE ??Subroutine133_0
   \   000003                ; // Fall through to label ??Subroutine133_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine133_0:
   \   000000   7F01         MOV     R7,#0x1
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine94:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F9           MOV     R1,A
   \   000005   22           RET
    467          
    468          /******************************************************************************
    469           * @fn          ZDSecMgrExtAddrStore
    470           *
    471           * @brief       Store EXT address.
    472           *
    473           * @param       extAddr - [in] EXT address
    474           * @param       ami     - [out] Address Manager index
    475           *
    476           * @return      ZStatus_t
    477           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    478          ZStatus_t ZDSecMgrExtAddrStore( uint16 nwkAddr, uint8* extAddr, uint16* ami )
   \                     ZDSecMgrExtAddrStore:
    479          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 13
   \   000005   74F3         MOV     A,#-0xd
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   7416         MOV     A,#0x16
   \   00000C   12....       LCALL   ?XSTACK_DISP0_8
   \   00000F   12....       LCALL   ?Subroutine49 & 0xFFFF
    480            ZStatus_t      status;
    481            AddrMgrEntry_t entry;
    482          
    483          
    484            // add entry
    485            entry.user    = ADDRMGR_USER_SECURITY;
    486            entry.nwkAddr = nwkAddr;
   \                     ??CrossCallReturnLabel_70:
   \   000012   12....       LCALL   ?XSTACK_DISP0_8
   \   000015   12....       LCALL   ?Subroutine29 & 0xFFFF
    487            AddrMgrExtAddrSet( entry.extAddr, extAddr );
   \                     ??CrossCallReturnLabel_35:
   \   000018                ; Setup parameters for call to function AddrMgrExtAddrSet
   \   000018   7403         MOV     A,#0x3
   \   00001A   12....       LCALL   ?XSTACK_DISP0_8
   \   00001D   12....       LCALL   ?Subroutine74 & 0xFFFF
    488          
    489            if ( AddrMgrEntryUpdate( &entry ) == TRUE )
   \                     ??CrossCallReturnLabel_112:
   \   000020   700A         JNZ     ??ZDSecMgrExtAddrStore_0
    490            {
    491              // return successful results
    492              *ami   = entry.index;
   \   000022   740B         MOV     A,#0xb
   \   000024   12....       LCALL   ?XSTACK_DISP0_8
   \   000027   12....       LCALL   ?Subroutine12 & 0xFFFF
    493              status = ZSuccess;
    494            }
   \                     ??CrossCallReturnLabel_164:
   \   00002A   8008         SJMP    ??CrossCallReturnLabel_43
    495            else
    496            {
    497              // return failed results
    498              *ami   = entry.index;
   \                     ??ZDSecMgrExtAddrStore_0:
   \   00002C   740B         MOV     A,#0xb
   \   00002E   12....       LCALL   ?XSTACK_DISP0_8
   \   000031   12....       LCALL   ?Subroutine30 & 0xFFFF
    499              status = ZNwkUnknownDevice;
    500            }
    501          
    502            return status;
   \                     ??CrossCallReturnLabel_43:
   \   000034   80..         SJMP    ?Subroutine8
    503          }
    504          
    505          /******************************************************************************
    506           * @fn          ZDSecMgrExtAddrLookup
    507           *
    508           * @brief       Lookup index for specified EXT address.
    509           *
    510           * @param       extAddr - [in] EXT address
    511           * @param       ami     - [out] Address Manager index
    512           *
    513           * @return      ZStatus_t
    514           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    515          ZStatus_t ZDSecMgrExtAddrLookup( uint8* extAddr, uint16* ami )
   \                     ZDSecMgrExtAddrLookup:
    516          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 13
   \   000005   74F3         MOV     A,#-0xd
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EC           MOV     A,R4
   \   00000B   FE           MOV     R6,A
   \   00000C   ED           MOV     A,R5
   \   00000D   FF           MOV     R7,A
    517            ZStatus_t      status;
    518            AddrMgrEntry_t entry;
    519          
    520          
    521            // lookup entry
    522            entry.user = ADDRMGR_USER_SECURITY;
   \   00000E   7402         MOV     A,#0x2
   \   000010   85..82       MOV     DPL,?XSP + 0
   \   000013   85..83       MOV     DPH,?XSP + 1
   \   000016   F0           MOVX    @DPTR,A
    523            AddrMgrExtAddrSet( entry.extAddr, extAddr );
   \   000017                ; Setup parameters for call to function AddrMgrExtAddrSet
   \   000017   EA           MOV     A,R2
   \   000018   FC           MOV     R4,A
   \   000019   EB           MOV     A,R3
   \   00001A   FD           MOV     R5,A
   \   00001B   7403         MOV     A,#0x3
   \   00001D   12....       LCALL   ?XSTACK_DISP0_8
   \   000020   12....       LCALL   ?Subroutine89 & 0xFFFF
    524          
    525            if ( AddrMgrEntryLookupExt( &entry ) == TRUE )
   \                     ??CrossCallReturnLabel_136:
   \   000023   12....       LCALL   ??AddrMgrEntryLookupExt?relay
   \   000026   E9           MOV     A,R1
   \   000027   6401         XRL     A,#0x1
   \   000029   700A         JNZ     ??ZDSecMgrExtAddrLookup_0
    526            {
    527              // return successful results
    528              *ami   = entry.index;
   \   00002B   740B         MOV     A,#0xb
   \   00002D   12....       LCALL   ?XSTACK_DISP0_8
   \   000030   12....       LCALL   ?Subroutine12 & 0xFFFF
    529              status = ZSuccess;
    530            }
   \                     ??CrossCallReturnLabel_165:
   \   000033   8008         SJMP    ??CrossCallReturnLabel_44
    531            else
    532            {
    533              // return failed results
    534              *ami   = entry.index;
   \                     ??ZDSecMgrExtAddrLookup_0:
   \   000035   740B         MOV     A,#0xb
   \   000037   12....       LCALL   ?XSTACK_DISP0_8
   \   00003A   12....       LCALL   ?Subroutine30 & 0xFFFF
    535              status = ZNwkUnknownDevice;
    536            }
    537          
    538            return status;
   \                     ??CrossCallReturnLabel_44:
   \   00003D                REQUIRE ?Subroutine8
   \   00003D                ; // Fall through to label ?Subroutine8
    539          }
    540          
    541          /******************************************************************************
    542           * @fn          ZDSecMgrMasterKeyLookup
    543           *
    544           * @brief       Lookup MASTER key for specified address index.
    545           *
    546           * @param       ami - [in] Address Manager index
    547           * @param       pKeyNvId - [out] MASTER key NV ID
    548           *
    549           * @return      ZStatus_t
    550           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    551          ZStatus_t ZDSecMgrMasterKeyLookup( uint16 ami, uint16* pKeyNvId )
   \                     ZDSecMgrMasterKeyLookup:
    552          {
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 18
   \   000005   74EE         MOV     A,#-0x12
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0 + 2,R2
   \   00000C   8B..         MOV     ?V0 + 3,R3
   \   00000E   EC           MOV     A,R4
   \   00000F   FE           MOV     R6,A
   \   000010   ED           MOV     A,R5
   \   000011   FF           MOV     R7,A
    553            uint16 index;
    554            ZDSecMgrMasterKeyData_t masterKeyData;
    555          
    556            
    557            for ( index = 0; index < ZDSECMGR_MASTERKEY_MAX ; index++ )
   \   000012   75..00       MOV     ?V0 + 0,#0x0
   \   000015   75..00       MOV     ?V0 + 1,#0x0
    558            {  
    559              // Read entry index of the Master key table from NV
    560              osal_nv_read( (ZCD_NV_MASTER_KEY_DATA_START + index), 0, 
    561                            sizeof(ZDSecMgrMasterKeyData_t), &masterKeyData );
   \                     ??ZDSecMgrMasterKeyLookup_0:
   \   000018                ; Setup parameters for call to function osal_nv_read
   \   000018   85..82       MOV     DPL,?XSP + 0
   \   00001B   85..83       MOV     DPH,?XSP + 1
   \   00001E   8582..       MOV     ?V0 + 4,DPL
   \   000021   8583..       MOV     ?V0 + 5,DPH
   \   000024   78..         MOV     R0,#?V0 + 4
   \   000026   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000029   75..12       MOV     ?V0 + 4,#0x12
   \   00002C   75..00       MOV     ?V0 + 5,#0x0
   \   00002F   78..         MOV     R0,#?V0 + 4
   \   000031   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000034   12....       LCALL   ?Subroutine79 & 0xFFFF
   \                     ??CrossCallReturnLabel_119:
   \   000037   12....       LCALL   ??Subroutine145_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_331:
   \   00003A   12....       LCALL   ?DEALLOC_XSTACK8
    562              
    563              if ( masterKeyData.ami == ami )
   \   00003D   85..82       MOV     DPL,?XSP + 0
   \   000040   85..83       MOV     DPH,?XSP + 1
   \   000043   E0           MOVX    A,@DPTR
   \   000044   65..         XRL     A,?V0 + 2
   \   000046   7004         JNZ     ??ZDSecMgrMasterKeyLookup_1
   \   000048   A3           INC     DPTR
   \   000049   E0           MOVX    A,@DPTR
   \   00004A   65..         XRL     A,?V0 + 3
   \                     ??ZDSecMgrMasterKeyLookup_1:
   \   00004C   7028         JNZ     ??ZDSecMgrMasterKeyLookup_2
    564              {
    565                // return successful results
    566                *pKeyNvId   = ZCD_NV_MASTER_KEY_DATA_START + index;
   \   00004E   7401         MOV     A,#0x1
   \   000050   25..         ADD     A,?V0 + 0
   \   000052   F8           MOV     R0,A
   \   000053   7403         MOV     A,#0x3
   \   000055   35..         ADDC    A,?V0 + 1
   \   000057   F9           MOV     R1,A
   \   000058   8E82         MOV     DPL,R6
   \   00005A   8F83         MOV     DPH,R7
   \   00005C   12....       LCALL   ??Subroutine113_0 & 0xFFFF
    567                
    568                // clear copy of key in RAM
    569                osal_memset(&masterKeyData, 0x00, sizeof(ZDSecMgrMasterKeyData_t));
   \                     ??CrossCallReturnLabel_188:
   \   00005F                ; Setup parameters for call to function osal_memset
   \   00005F   7C12         MOV     R4,#0x12
   \   000061   7D00         MOV     R5,#0x0
   \   000063   7900         MOV     R1,#0x0
   \   000065   85..82       MOV     DPL,?XSP + 0
   \   000068   85..83       MOV     DPH,?XSP + 1
   \   00006B   AA82         MOV     R2,DPL
   \   00006D   AB83         MOV     R3,DPH
   \   00006F   12....       LCALL   ??osal_memset?relay
    570                
    571                return ZSuccess;
   \   000072   7900         MOV     R1,#0x0
   \   000074   8020         SJMP    ??ZDSecMgrMasterKeyLookup_3
    572              }
    573            }
   \                     ??ZDSecMgrMasterKeyLookup_2:
   \   000076   12....       LCALL   ?Subroutine37 & 0xFFFF
   \                     ??CrossCallReturnLabel_54:
   \   000079   409D         JC      ??ZDSecMgrMasterKeyLookup_0
    574            
    575            *pKeyNvId = SEC_NO_KEY_NV_ID;
   \   00007B   8E82         MOV     DPL,R6
   \   00007D   8F83         MOV     DPH,R7
   \   00007F   E4           CLR     A
   \   000080   F0           MOVX    @DPTR,A
   \   000081   A3           INC     DPTR
   \   000082   F0           MOVX    @DPTR,A
    576          
    577            // clear copy of key in RAM
    578            osal_memset(&masterKeyData, 0x00, sizeof(ZDSecMgrMasterKeyData_t));
   \   000083                ; Setup parameters for call to function osal_memset
   \   000083   7C12         MOV     R4,#0x12
   \   000085   FD           MOV     R5,A
   \   000086   F9           MOV     R1,A
   \   000087   85..82       MOV     DPL,?XSP + 0
   \   00008A   85..83       MOV     DPH,?XSP + 1
   \   00008D   AA82         MOV     R2,DPL
   \   00008F   AB83         MOV     R3,DPH
   \   000091   12....       LCALL   ??osal_memset?relay
    579          
    580            return ZNwkUnknownDevice;
   \   000094   79C8         MOV     R1,#-0x38
   \                     ??ZDSecMgrMasterKeyLookup_3:
   \   000096   7412         MOV     A,#0x12
   \   000098   12....       LCALL   ?DEALLOC_XSTACK8
   \   00009B                REQUIRE ?Subroutine2
   \   00009B                ; // Fall through to label ?Subroutine2
    581          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine2:
   \   000000   7F06         MOV     R7,#0x6
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine79:
   \   000000   7C00         MOV     R4,#0x0
   \   000002   7D00         MOV     R5,#0x0
   \   000004   7401         MOV     A,#0x1
   \   000006   25..         ADD     A,?V0 + 0
   \   000008   FA           MOV     R2,A
   \   000009   7403         MOV     A,#0x3
   \   00000B   35..         ADDC    A,?V0 + 1
   \   00000D   FB           MOV     R3,A
   \   00000E   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine37:
   \   000000   E5..         MOV     A,?V0 + 0
   \   000002   2401         ADD     A,#0x1
   \   000004   F5..         MOV     ?V0 + 0,A
   \   000006   E5..         MOV     A,?V0 + 1
   \   000008   3400         ADDC    A,#0x0
   \   00000A   F5..         MOV     ?V0 + 1,A
   \   00000C   C3           CLR     C
   \   00000D   E5..         MOV     A,?V0 + 0
   \   00000F   9403         SUBB    A,#0x3
   \   000011   E5..         MOV     A,?V0 + 1
   \   000013   9400         SUBB    A,#0x0
   \   000015   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine113_0:
   \   000000   12....       LCALL   ?Subroutine87 & 0xFFFF
   \                     ??CrossCallReturnLabel_253:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine145_0:
   \   000000   12....       LCALL   ??osal_nv_read?relay
   \   000003   7404         MOV     A,#0x4
   \   000005   22           RET
    582          
    583          /******************************************************************************
    584           * @fn          ZDSecMgrMasterKeyStore
    585           *
    586           * @brief       Store MASTER key for specified address index.
    587           *
    588           * @param       ami - [in] Address Manager index
    589           * @param       key - [in] valid key to store
    590           *
    591           * @return      ZStatus_t
    592           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    593          ZStatus_t ZDSecMgrMasterKeyStore( uint16 ami, uint8* key )
   \                     ZDSecMgrMasterKeyStore:
    594          {
   \   000000   74F1         MOV     A,#-0xf
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 15
   \   000005                ; Auto size: 18
   \   000005   74EE         MOV     A,#-0x12
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0 + 2,R2
   \   00000C   8B..         MOV     ?V0 + 3,R3
   \   00000E   EC           MOV     A,R4
   \   00000F   FE           MOV     R6,A
   \   000010   ED           MOV     A,R5
   \   000011   FF           MOV     R7,A
    595            uint16    index;
    596            ZDSecMgrMasterKeyData_t   masterKeyData;
    597            
    598          
    599            for ( index = 0; index < ZDSECMGR_MASTERKEY_MAX ; index++ )
   \   000012   75..00       MOV     ?V0 + 0,#0x0
   \   000015   75..00       MOV     ?V0 + 1,#0x0
    600            {
    601              // Read entry index of the Master key table from NV
    602              osal_nv_read( (ZCD_NV_MASTER_KEY_DATA_START + index), 0, 
    603                             sizeof(ZDSecMgrMasterKeyData_t), &masterKeyData );
   \                     ??ZDSecMgrMasterKeyStore_0:
   \   000018                ; Setup parameters for call to function osal_nv_read
   \   000018   85..82       MOV     DPL,?XSP + 0
   \   00001B   85..83       MOV     DPH,?XSP + 1
   \   00001E   8582..       MOV     ?V0 + 4,DPL
   \   000021   8583..       MOV     ?V0 + 5,DPH
   \   000024   78..         MOV     R0,#?V0 + 4
   \   000026   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000029   75..12       MOV     ?V0 + 4,#0x12
   \   00002C   75..00       MOV     ?V0 + 5,#0x0
   \   00002F   78..         MOV     R0,#?V0 + 4
   \   000031   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000034   12....       LCALL   ?Subroutine79 & 0xFFFF
   \                     ??CrossCallReturnLabel_120:
   \   000037   12....       LCALL   ??Subroutine145_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_332:
   \   00003A   12....       LCALL   ?DEALLOC_XSTACK8
    604          
    605              if ( masterKeyData.ami == INVALID_NODE_ADDR )
   \   00003D   85..82       MOV     DPL,?XSP + 0
   \   000040   85..83       MOV     DPH,?XSP + 1
   \   000043   E0           MOVX    A,@DPTR
   \   000044   64FE         XRL     A,#0xfe
   \   000046   7004         JNZ     ??ZDSecMgrMasterKeyStore_1
   \   000048   A3           INC     DPTR
   \   000049   E0           MOVX    A,@DPTR
   \   00004A   64FF         XRL     A,#0xff
   \                     ??ZDSecMgrMasterKeyStore_1:
   \   00004C   6003         JZ      $+5
   \   00004E   02....       LJMP    ??ZDSecMgrMasterKeyStore_2 & 0xFFFF
    606              {
    607                // store EXT address index
    608                masterKeyData.ami = ami;
   \   000051   85..82       MOV     DPL,?XSP + 0
   \   000054   85..83       MOV     DPH,?XSP + 1
   \   000057   E5..         MOV     A,?V0 + 2
   \   000059   F0           MOVX    @DPTR,A
   \   00005A   A3           INC     DPTR
   \   00005B   E5..         MOV     A,?V0 + 3
   \   00005D   F0           MOVX    @DPTR,A
    609          
    610                if ( key != NULL )
   \   00005E   EE           MOV     A,R6
   \   00005F   7001         JNZ     ??ZDSecMgrMasterKeyStore_3
   \   000061   EF           MOV     A,R7
   \                     ??ZDSecMgrMasterKeyStore_3:
   \   000062   601D         JZ      ??ZDSecMgrMasterKeyStore_4
    611                {
    612                  osal_memcpy( masterKeyData.key, key,  SEC_KEY_LEN );
   \   000064                ; Setup parameters for call to function osal_memcpy
   \   000064   8E..         MOV     ?V0 + 4,R6
   \   000066   8F..         MOV     ?V0 + 5,R7
   \   000068   75..00       MOV     ?V0 + 6,#0x0
   \   00006B   78..         MOV     R0,#?V0 + 4
   \   00006D   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000070   7C10         MOV     R4,#0x10
   \   000072   7D00         MOV     R5,#0x0
   \   000074   7405         MOV     A,#0x5
   \   000076   12....       LCALL   ?XSTACK_DISP0_8
   \   000079   12....       LCALL   ?Subroutine78 & 0xFFFF
    613                }
   \                     ??CrossCallReturnLabel_225:
   \   00007C   12....       LCALL   ?DEALLOC_XSTACK8
   \   00007F   8012         SJMP    ??ZDSecMgrMasterKeyStore_5
    614                else
    615                {
    616                  osal_memset( masterKeyData.key, 0, SEC_KEY_LEN );
   \                     ??ZDSecMgrMasterKeyStore_4:
   \   000081                ; Setup parameters for call to function osal_memset
   \   000081   7C10         MOV     R4,#0x10
   \   000083   7D00         MOV     R5,#0x0
   \   000085   7900         MOV     R1,#0x0
   \   000087   7402         MOV     A,#0x2
   \   000089   12....       LCALL   ?XSTACK_DISP0_8
   \   00008C   AA82         MOV     R2,DPL
   \   00008E   AB83         MOV     R3,DPH
   \   000090   12....       LCALL   ??osal_memset?relay
    617                }
    618          
    619                // set new values in NV      
    620                osal_nv_write( (ZCD_NV_MASTER_KEY_DATA_START + index), 0, 
    621                                sizeof(ZDSecMgrMasterKeyData_t), &masterKeyData );
   \                     ??ZDSecMgrMasterKeyStore_5:
   \   000093                ; Setup parameters for call to function osal_nv_write
   \   000093   85..82       MOV     DPL,?XSP + 0
   \   000096   85..83       MOV     DPH,?XSP + 1
   \   000099   8582..       MOV     ?V0 + 2,DPL
   \   00009C   8583..       MOV     ?V0 + 3,DPH
   \   00009F   78..         MOV     R0,#?V0 + 2
   \   0000A1   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000A4   75..12       MOV     ?V0 + 2,#0x12
   \   0000A7   75..00       MOV     ?V0 + 3,#0x0
   \   0000AA   78..         MOV     R0,#?V0 + 2
   \   0000AC   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000AF   7C00         MOV     R4,#0x0
   \   0000B1   7D00         MOV     R5,#0x0
   \   0000B3   7401         MOV     A,#0x1
   \   0000B5   25..         ADD     A,?V0 + 0
   \   0000B7   FA           MOV     R2,A
   \   0000B8   7403         MOV     A,#0x3
   \   0000BA   35..         ADDC    A,?V0 + 1
   \   0000BC   12....       LCALL   ??Subroutine109_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_173:
   \   0000BF   12....       LCALL   ?DEALLOC_XSTACK8
    622                 
    623                // clear copy of key in RAM
    624                osal_memset( &masterKeyData, 0x00, sizeof(ZDSecMgrMasterKeyData_t) );
   \   0000C2                ; Setup parameters for call to function osal_memset
   \   0000C2   7C12         MOV     R4,#0x12
   \   0000C4   7D00         MOV     R5,#0x0
   \   0000C6   7900         MOV     R1,#0x0
   \   0000C8   85..82       MOV     DPL,?XSP + 0
   \   0000CB   85..83       MOV     DPH,?XSP + 1
   \   0000CE   AA82         MOV     R2,DPL
   \   0000D0   AB83         MOV     R3,DPH
   \   0000D2   12....       LCALL   ??osal_memset?relay
    625          
    626                // return successful results
    627                return ZSuccess;
   \   0000D5   7900         MOV     R1,#0x0
   \   0000D7   801D         SJMP    ??ZDSecMgrMasterKeyStore_6
    628              }
    629            }
   \                     ??ZDSecMgrMasterKeyStore_2:
   \   0000D9   12....       LCALL   ?Subroutine37 & 0xFFFF
   \                     ??CrossCallReturnLabel_55:
   \   0000DC   5003         JNC     $+5
   \   0000DE   02....       LJMP    ??ZDSecMgrMasterKeyStore_0 & 0xFFFF
    630            
    631            // clear copy of key in RAM
    632            osal_memset( &masterKeyData, 0x00, sizeof(ZDSecMgrMasterKeyData_t) );
   \   0000E1                ; Setup parameters for call to function osal_memset
   \   0000E1   7C12         MOV     R4,#0x12
   \   0000E3   7D00         MOV     R5,#0x0
   \   0000E5   7900         MOV     R1,#0x0
   \   0000E7   85..82       MOV     DPL,?XSP + 0
   \   0000EA   85..83       MOV     DPH,?XSP + 1
   \   0000ED   AA82         MOV     R2,DPL
   \   0000EF   AB83         MOV     R3,DPH
   \   0000F1   12....       LCALL   ??osal_memset?relay
    633            
    634            return ZNwkUnknownDevice;
   \   0000F4   79C8         MOV     R1,#-0x38
   \                     ??ZDSecMgrMasterKeyStore_6:
   \   0000F6                REQUIRE ?Subroutine3
   \   0000F6                ; // Fall through to label ?Subroutine3
    635          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine3:
   \   000000   7412         MOV     A,#0x12
   \   000002   12....       LCALL   ?DEALLOC_XSTACK8
   \   000005   7F07         MOV     R7,#0x7
   \   000007   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine78:
   \   000000   AA82         MOV     R2,DPL
   \   000002   AB83         MOV     R3,DPH
   \   000004                REQUIRE ??Subroutine121_0
   \   000004                ; // Fall through to label ??Subroutine121_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine121_0:
   \   000000   12....       LCALL   ??osal_memcpy?relay
   \   000003   7403         MOV     A,#0x3
   \   000005   22           RET
    636          
    637          /******************************************************************************
    638           * @fn          ZDSecMgrEntryInit
    639           *
    640           * @brief       Initialize entry sub module
    641           *
    642           * @param       state - device initialization state
    643           *
    644           * @return      none
    645           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    646          void ZDSecMgrEntryInit(uint8 state)
   \                     ZDSecMgrEntryInit:
    647          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    648            if (ZDSecMgrEntries == NULL)
   \   000004   90....       MOV     DPTR,#ZDSecMgrEntries
   \   000007   E0           MOVX    A,@DPTR
   \   000008   7002         JNZ     ??ZDSecMgrEntryInit_0
   \   00000A   A3           INC     DPTR
   \   00000B   E0           MOVX    A,@DPTR
   \                     ??ZDSecMgrEntryInit_0:
   \   00000C   7037         JNZ     ??ZDSecMgrEntryInit_1
    649            {
    650              uint16 index;
    651          
    652              if ((ZDSecMgrEntries = osal_mem_alloc(sizeof(ZDSecMgrEntry_t) * ZDSECMGR_ENTRY_MAX)) == NULL)
   \   00000E                ; Setup parameters for call to function osal_mem_alloc
   \   00000E   7A0F         MOV     R2,#0xf
   \   000010   7B00         MOV     R3,#0x0
   \   000012   12....       LCALL   ??osal_mem_alloc?relay
   \   000015   90....       MOV     DPTR,#ZDSecMgrEntries
   \   000018   12....       LCALL   ?Subroutine29 & 0xFFFF
   \                     ??CrossCallReturnLabel_36:
   \   00001B   90....       MOV     DPTR,#ZDSecMgrEntries
   \   00001E   E0           MOVX    A,@DPTR
   \   00001F   7002         JNZ     ??ZDSecMgrEntryInit_2
   \   000021   A3           INC     DPTR
   \   000022   E0           MOVX    A,@DPTR
   \                     ??ZDSecMgrEntryInit_2:
   \   000023   6020         JZ      ??ZDSecMgrEntryInit_1
    653              {
    654                return;
    655              }
    656          
    657              for (index = 0; index < ZDSECMGR_ENTRY_MAX; index++)
   \   000025   7800         MOV     R0,#0x0
   \   000027   7900         MOV     R1,#0x0
    658              {
    659                ZDSecMgrEntries[index].ami = INVALID_NODE_ADDR;
   \                     ??ZDSecMgrEntryInit_3:
   \   000029   12....       LCALL   ?Subroutine77 & 0xFFFF
   \                     ??CrossCallReturnLabel_117:
   \   00002C   8A82         MOV     DPL,R2
   \   00002E   8B83         MOV     DPH,R3
   \   000030   74FE         MOV     A,#-0x2
   \   000032   F0           MOVX    @DPTR,A
   \   000033   A3           INC     DPTR
   \   000034   74FF         MOV     A,#-0x1
   \   000036   F0           MOVX    @DPTR,A
    660                
    661                ZDSecMgrEntries[index].keyNvId = SEC_NO_KEY_NV_ID;
   \   000037   8A82         MOV     DPL,R2
   \   000039   8B83         MOV     DPH,R3
   \   00003B   A3           INC     DPTR
   \   00003C   A3           INC     DPTR
   \   00003D   E4           CLR     A
   \   00003E   F0           MOVX    @DPTR,A
   \   00003F   A3           INC     DPTR
   \   000040   12....       LCALL   ?Subroutine18 & 0xFFFF
    662              }
    663            }
   \                     ??CrossCallReturnLabel_7:
   \   000043   40E4         JC      ??ZDSecMgrEntryInit_3
   \                     ??ZDSecMgrEntryInit_1:
   \   000045   02....       LJMP    ??Subroutine125_0 & 0xFFFF
    664          
    665          #if defined NV_RESTORE
    666            if (state == ZDO_INITDEV_RESTORED_NETWORK_STATE)
    667            {
    668              ZDSecMgrRestoreFromNV();
    669            }
    670          #else
    671            (void)state;
    672          #endif
    673          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine77:
   \   000000   E8           MOV     A,R0
   \   000001   FA           MOV     R2,A
   \   000002   E9           MOV     A,R1
   \   000003   FB           MOV     R3,A
   \   000004   EA           MOV     A,R2
   \   000005   75F005       MOV     B,#0x5
   \   000008   A4           MUL     AB
   \   000009   FA           MOV     R2,A
   \   00000A   ACF0         MOV     R4,B
   \   00000C   75F005       MOV     B,#0x5
   \   00000F   EB           MOV     A,R3
   \   000010   A4           MUL     AB
   \   000011   2C           ADD     A,R4
   \   000012   FB           MOV     R3,A
   \   000013   90....       MOV     DPTR,#ZDSecMgrEntries
   \   000016   E0           MOVX    A,@DPTR
   \   000017   2A           ADD     A,R2
   \   000018   FA           MOV     R2,A
   \   000019   A3           INC     DPTR
   \   00001A   E0           MOVX    A,@DPTR
   \   00001B   3B           ADDC    A,R3
   \   00001C   FB           MOV     R3,A
   \   00001D   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine18:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   12....       LCALL   ?Subroutine99 & 0xFFFF
   \                     ??CrossCallReturnLabel_152:
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine99:
   \   000000   E8           MOV     A,R0
   \   000001   2401         ADD     A,#0x1
   \   000003   08           INC     R0
   \   000004   E9           MOV     A,R1
   \   000005   3400         ADDC    A,#0x0
   \   000007   F9           MOV     R1,A
   \   000008   C3           CLR     C
   \   000009   E8           MOV     A,R0
   \   00000A   9403         SUBB    A,#0x3
   \   00000C   E9           MOV     A,R1
   \   00000D   9400         SUBB    A,#0x0
   \   00000F   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine125_0:
   \   000000   D083         POP     DPH
   \   000002   D082         POP     DPL
   \   000004   02....       LJMP    ?BRET
    674          
    675          /******************************************************************************
    676           * @fn          ZDSecMgrEntryLookup
    677           *
    678           * @brief       Lookup entry index using specified NWK address.
    679           *
    680           * @param       nwkAddr - [in] NWK address
    681           * @param       entry   - [out] valid entry
    682           *
    683           * @return      ZStatus_t
    684           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    685          ZStatus_t ZDSecMgrEntryLookup( uint16 nwkAddr, ZDSecMgrEntry_t** entry )
   \                     ZDSecMgrEntryLookup:
    686          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 13
   \   000005   74F3         MOV     A,#-0xd
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EC           MOV     A,R4
   \   00000B   FE           MOV     R6,A
   \   00000C   ED           MOV     A,R5
   \   00000D   FF           MOV     R7,A
    687            ZStatus_t      status;
    688            uint16         index;
    689            AddrMgrEntry_t addrMgrEntry;
    690          
    691          
    692            // initialize results
    693            *entry = NULL;
   \   00000E   8E82         MOV     DPL,R6
   \   000010   8F83         MOV     DPH,R7
   \   000012   E4           CLR     A
   \   000013   F0           MOVX    @DPTR,A
   \   000014   A3           INC     DPTR
   \   000015   F0           MOVX    @DPTR,A
    694            status = ZNwkUnknownDevice;
    695          
    696            // verify data is available
    697            if ( ZDSecMgrEntries != NULL )
   \   000016   90....       MOV     DPTR,#ZDSecMgrEntries
   \   000019   E0           MOVX    A,@DPTR
   \   00001A   7002         JNZ     ??ZDSecMgrEntryLookup_0
   \   00001C   A3           INC     DPTR
   \   00001D   E0           MOVX    A,@DPTR
   \                     ??ZDSecMgrEntryLookup_0:
   \   00001E   6067         JZ      ??ZDSecMgrEntryLookup_1
    698            {
    699              addrMgrEntry.user    = ADDRMGR_USER_SECURITY;
   \   000020   7402         MOV     A,#0x2
   \   000022   85..82       MOV     DPL,?XSP + 0
   \   000025   85..83       MOV     DPH,?XSP + 1
   \   000028   F0           MOVX    @DPTR,A
    700              addrMgrEntry.nwkAddr = nwkAddr;
   \   000029   7401         MOV     A,#0x1
   \   00002B   12....       LCALL   ?XSTACK_DISP0_8
   \   00002E   12....       LCALL   ?Subroutine16 & 0xFFFF
    701          
    702              if ( AddrMgrEntryLookupNwk( &addrMgrEntry ) == TRUE )
   \                     ??CrossCallReturnLabel_255:
   \   000031   12....       LCALL   ??AddrMgrEntryLookupNwk?relay
   \   000034   E9           MOV     A,R1
   \   000035   6401         XRL     A,#0x1
   \   000037   704E         JNZ     ??ZDSecMgrEntryLookup_1
    703              {
    704                for ( index = 0; index < ZDSECMGR_ENTRY_MAX ; index++ )
   \   000039   7800         MOV     R0,#0x0
   \   00003B   7900         MOV     R1,#0x0
    705                {
    706                  if ( addrMgrEntry.index == ZDSecMgrEntries[index].ami )
   \                     ??ZDSecMgrEntryLookup_2:
   \   00003D   740B         MOV     A,#0xb
   \   00003F   12....       LCALL   ?XSTACK_DISP0_8
   \   000042   12....       LCALL   ?Subroutine103 & 0xFFFF
   \                     ??CrossCallReturnLabel_156:
   \   000045   E8           MOV     A,R0
   \   000046   FA           MOV     R2,A
   \   000047   E9           MOV     A,R1
   \   000048   FB           MOV     R3,A
   \   000049   EA           MOV     A,R2
   \   00004A   75F005       MOV     B,#0x5
   \   00004D   A4           MUL     AB
   \   00004E   FA           MOV     R2,A
   \   00004F   85F0..       MOV     ?V0 + 0,B
   \   000052   75F005       MOV     B,#0x5
   \   000055   EB           MOV     A,R3
   \   000056   A4           MUL     AB
   \   000057   25..         ADD     A,?V0 + 0
   \   000059   FB           MOV     R3,A
   \   00005A   90....       MOV     DPTR,#ZDSecMgrEntries
   \   00005D   12....       LCALL   ?Subroutine58 & 0xFFFF
   \                     ??CrossCallReturnLabel_82:
   \   000060   6C           XRL     A,R4
   \   000061   7003         JNZ     ??ZDSecMgrEntryLookup_3
   \   000063   A3           INC     DPTR
   \   000064   E0           MOVX    A,@DPTR
   \   000065   6D           XRL     A,R5
   \                     ??ZDSecMgrEntryLookup_3:
   \   000066   701A         JNZ     ??ZDSecMgrEntryLookup_4
    707                  {
    708                    // return successful results
    709                    *entry = &ZDSecMgrEntries[index];
   \   000068   E8           MOV     A,R0
   \   000069   75F005       MOV     B,#0x5
   \   00006C   A4           MUL     AB
   \   00006D   F8           MOV     R0,A
   \   00006E   AAF0         MOV     R2,B
   \   000070   75F005       MOV     B,#0x5
   \   000073   E9           MOV     A,R1
   \   000074   A4           MUL     AB
   \   000075   2A           ADD     A,R2
   \   000076   F9           MOV     R1,A
   \   000077   90....       MOV     DPTR,#ZDSecMgrEntries
   \   00007A   12....       LCALL   ?Subroutine98 & 0xFFFF
    710                    status = ZSuccess;
    711          
    712                    // break from loop
    713                    return status;
    714                  }
    715                }
   \                     ??CrossCallReturnLabel_148:
   \   00007D   12....       LCALL   ??Subroutine106_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_166:
   \   000080   8007         SJMP    ??ZDSecMgrEntryLookup_5
   \                     ??ZDSecMgrEntryLookup_4:
   \   000082   12....       LCALL   ?Subroutine35 & 0xFFFF
    716              }
    717            }
   \                     ??CrossCallReturnLabel_50:
   \   000085   40B6         JC      ??ZDSecMgrEntryLookup_2
    718          
    719            return status;
   \                     ??ZDSecMgrEntryLookup_1:
   \   000087   79C8         MOV     R1,#-0x38
   \                     ??ZDSecMgrEntryLookup_5:
   \   000089   02....       LJMP    ?Subroutine8 & 0xFFFF
    720          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine35:
   \   000000   12....       LCALL   ?Subroutine99 & 0xFFFF
   \                     ??CrossCallReturnLabel_151:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine98:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   28           ADD     A,R0
   \   000002   F8           MOV     R0,A
   \   000003   A3           INC     DPTR
   \   000004   E0           MOVX    A,@DPTR
   \   000005   39           ADDC    A,R1
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine58:
   \   000000   12....       LCALL   ?Subroutine96 & 0xFFFF
   \                     ??CrossCallReturnLabel_145:
   \   000003   E0           MOVX    A,@DPTR
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine96:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   2A           ADD     A,R2
   \   000002   F5..         MOV     ?V0 + 0,A
   \   000004   A3           INC     DPTR
   \   000005   E0           MOVX    A,@DPTR
   \   000006   3B           ADDC    A,R3
   \   000007   85..82       MOV     DPL,?V0 + 0
   \   00000A   F583         MOV     DPH,A
   \   00000C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine103:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FC           MOV     R4,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   FD           MOV     R5,A
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine16:
   \   000000   EA           MOV     A,R2
   \   000001   F0           MOVX    @DPTR,A
   \   000002   A3           INC     DPTR
   \   000003   EB           MOV     A,R3
   \   000004                REQUIRE ??Subroutine127_0
   \   000004                ; // Fall through to label ??Subroutine127_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine127_0:
   \   000000   12....       LCALL   ??Subroutine138_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_281:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine138_0:
   \   000000   12....       LCALL   ?Subroutine102 & 0xFFFF
   \                     ??CrossCallReturnLabel_283:
   \   000003   AA82         MOV     R2,DPL
   \   000005   AB83         MOV     R3,DPH
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine102:
   \   000000   F0           MOVX    @DPTR,A
   \   000001                ; Setup parameters for call to function ZDSecMgrMasterKeyLookup
   \   000001                ; Setup parameters for call to function ZDSecMgrEntryLookup
   \   000001                ; Setup parameters for call to function ZDSecMgrDeviceCtrlHandler
   \   000001                ; Setup parameters for call to function ZDSecMgrDeviceJoin
   \   000001                ; Setup parameters for call to function APSME_AuthenticateReq
   \   000001                ; Setup parameters for call to function ZDSecMgrDeviceRemove
   \   000001                ; Setup parameters for call to function ZDSecMgrDeviceRemove
   \   000001                ; Setup parameters for call to function AddrMgrEntryLookupNwk
   \   000001                ; Setup parameters for call to function AddrMgrEntryGet
   \   000001                ; Setup parameters for call to function APSME_EstablishKeyReq
   \   000001                ; Setup parameters for call to function AddrMgrEntryUpdate
   \   000001                ; Setup parameters for call to function NLME_LeaveReq
   \   000001                ; Setup parameters for call to function APSME_UpdateDeviceReq
   \   000001                ; Setup parameters for call to function APSME_AuthenticateReq
   \   000001                ; Setup parameters for call to function ZDSecMgrDeviceNew
   \   000001                ; Setup parameters for call to function APSME_EstablishKeyRsp
   \   000001                ; Setup parameters for call to function APSME_TransportKeyReq
   \   000001                ; Setup parameters for call to function APSME_SwitchKeyReq
   \   000001                ; Setup parameters for call to function osal_nv_write
   \   000001   85..82       MOV     DPL,?XSP + 0
   \   000004   85..83       MOV     DPH,?XSP + 1
   \   000007   22           RET
    721          
    722          /******************************************************************************
    723           * @fn          ZDSecMgrEntryLookupAMI
    724           *
    725           * @brief       Lookup entry using specified address index
    726           *
    727           * @param       ami   - [in] Address Manager index
    728           * @param       entry - [out] valid entry
    729           *
    730           * @return      ZStatus_t
    731           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    732          ZStatus_t ZDSecMgrEntryLookupAMI( uint16 ami, ZDSecMgrEntry_t** entry )
   \                     ZDSecMgrEntryLookupAMI:
    733          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
    734            ZStatus_t status;
    735            uint16    index;
    736          
    737          
    738            // initialize results
    739            *entry = NULL;
   \   000005   8C82         MOV     DPL,R4
   \   000007   8D83         MOV     DPH,R5
   \   000009   E4           CLR     A
   \   00000A   F0           MOVX    @DPTR,A
   \   00000B   A3           INC     DPTR
   \   00000C   F0           MOVX    @DPTR,A
    740            status = ZNwkUnknownDevice;
    741          
    742            // verify data is available
    743            if ( ZDSecMgrEntries != NULL )
   \   00000D   90....       MOV     DPTR,#ZDSecMgrEntries
   \   000010   E0           MOVX    A,@DPTR
   \   000011   7002         JNZ     ??ZDSecMgrEntryLookupAMI_0
   \   000013   A3           INC     DPTR
   \   000014   E0           MOVX    A,@DPTR
   \                     ??ZDSecMgrEntryLookupAMI_0:
   \   000015   6050         JZ      ??ZDSecMgrEntryLookupAMI_1
    744            {
    745              for ( index = 0; index < ZDSECMGR_ENTRY_MAX ; index++ )
   \   000017   7800         MOV     R0,#0x0
   \   000019   7900         MOV     R1,#0x0
    746              {
    747                if ( ZDSecMgrEntries[index].ami == ami )
   \                     ??ZDSecMgrEntryLookupAMI_2:
   \   00001B   E8           MOV     A,R0
   \   00001C   FE           MOV     R6,A
   \   00001D   E9           MOV     A,R1
   \   00001E   FF           MOV     R7,A
   \   00001F   EE           MOV     A,R6
   \   000020   75F005       MOV     B,#0x5
   \   000023   A4           MUL     AB
   \   000024   FE           MOV     R6,A
   \   000025   85F0..       MOV     ?V0 + 0,B
   \   000028   75F005       MOV     B,#0x5
   \   00002B   EF           MOV     A,R7
   \   00002C   A4           MUL     AB
   \   00002D   25..         ADD     A,?V0 + 0
   \   00002F   FF           MOV     R7,A
   \   000030   90....       MOV     DPTR,#ZDSecMgrEntries
   \   000033   E0           MOVX    A,@DPTR
   \   000034   2E           ADD     A,R6
   \   000035   F5..         MOV     ?V0 + 0,A
   \   000037   A3           INC     DPTR
   \   000038   E0           MOVX    A,@DPTR
   \   000039   3F           ADDC    A,R7
   \   00003A   85..82       MOV     DPL,?V0 + 0
   \   00003D   F583         MOV     DPH,A
   \   00003F   E0           MOVX    A,@DPTR
   \   000040   6A           XRL     A,R2
   \   000041   7003         JNZ     ??ZDSecMgrEntryLookupAMI_3
   \   000043   A3           INC     DPTR
   \   000044   E0           MOVX    A,@DPTR
   \   000045   6B           XRL     A,R3
   \                     ??ZDSecMgrEntryLookupAMI_3:
   \   000046   701A         JNZ     ??ZDSecMgrEntryLookupAMI_4
    748                {
    749                  // return successful results
    750                  *entry = &ZDSecMgrEntries[index];
   \   000048   E8           MOV     A,R0
   \   000049   75F005       MOV     B,#0x5
   \   00004C   A4           MUL     AB
   \   00004D   F8           MOV     R0,A
   \   00004E   AAF0         MOV     R2,B
   \   000050   75F005       MOV     B,#0x5
   \   000053   E9           MOV     A,R1
   \   000054   A4           MUL     AB
   \   000055   2A           ADD     A,R2
   \   000056   F9           MOV     R1,A
   \   000057   90....       MOV     DPTR,#ZDSecMgrEntries
   \   00005A   12....       LCALL   ?Subroutine61 & 0xFFFF
    751                  status = ZSuccess;
    752          
    753                  // break from loop
    754                  return status;
    755                }
    756              }
   \                     ??CrossCallReturnLabel_88:
   \   00005D   12....       LCALL   ??Subroutine107_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_167:
   \   000060   8007         SJMP    ??ZDSecMgrEntryLookupAMI_5
   \                     ??ZDSecMgrEntryLookupAMI_4:
   \   000062   12....       LCALL   ?Subroutine35 & 0xFFFF
    757            }
   \                     ??CrossCallReturnLabel_51:
   \   000065   40B4         JC      ??ZDSecMgrEntryLookupAMI_2
    758          
    759            return status;
   \                     ??ZDSecMgrEntryLookupAMI_1:
   \   000067   79C8         MOV     R1,#-0x38
   \                     ??ZDSecMgrEntryLookupAMI_5:
   \   000069   02....       LJMP    ??Subroutine133_0 & 0xFFFF
    760          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine61:
   \   000000   12....       LCALL   ?Subroutine98 & 0xFFFF
   \                     ??CrossCallReturnLabel_150:
   \   000003   F9           MOV     R1,A
   \   000004   8C82         MOV     DPL,R4
   \   000006   8D83         MOV     DPH,R5
   \   000008   22           RET
    761          
    762          /******************************************************************************
    763           * @fn          ZDSecMgrEntryLookupExt
    764           *
    765           * @brief       Lookup entry index using specified EXT address.
    766           *
    767           * @param       extAddr - [in] EXT address
    768           * @param       entry   - [out] valid entry
    769           *
    770           * @return      ZStatus_t
    771           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    772          ZStatus_t ZDSecMgrEntryLookupExt( uint8* extAddr, ZDSecMgrEntry_t** entry )
   \                     ZDSecMgrEntryLookupExt:
    773          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EC           MOV     A,R4
   \   00000B   FE           MOV     R6,A
   \   00000C   ED           MOV     A,R5
   \   00000D   FF           MOV     R7,A
    774            ZStatus_t status;
    775            uint16    ami;
    776          
    777          
    778            // initialize results
    779            *entry = NULL;
   \   00000E   8E82         MOV     DPL,R6
   \   000010   8F83         MOV     DPH,R7
   \   000012   E4           CLR     A
   \   000013   F0           MOVX    @DPTR,A
   \   000014   A3           INC     DPTR
   \   000015   F0           MOVX    @DPTR,A
    780            status = ZNwkUnknownDevice;
   \   000016   75..C8       MOV     ?V0 + 0,#-0x38
    781          
    782            // lookup address index
    783            if ( ZDSecMgrExtAddrLookup( extAddr, &ami ) == ZSuccess )
   \   000019                ; Setup parameters for call to function ZDSecMgrExtAddrLookup
   \   000019   85..82       MOV     DPL,?XSP + 0
   \   00001C   85..83       MOV     DPH,?XSP + 1
   \   00001F   AC82         MOV     R4,DPL
   \   000021   AD83         MOV     R5,DPH
   \   000023   12....       LCALL   ??ZDSecMgrExtAddrLookup?relay
   \   000026   E9           MOV     A,R1
   \   000027   7010         JNZ     ??ZDSecMgrEntryLookupExt_0
    784            {
    785              status = ZDSecMgrEntryLookupAMI( ami, entry );
   \   000029                ; Setup parameters for call to function ZDSecMgrEntryLookupAMI
   \   000029   EE           MOV     A,R6
   \   00002A   FC           MOV     R4,A
   \   00002B   EF           MOV     A,R7
   \   00002C   FD           MOV     R5,A
   \   00002D   85..82       MOV     DPL,?XSP + 0
   \   000030   85..83       MOV     DPH,?XSP + 1
   \   000033   12....       LCALL   ?Subroutine65 & 0xFFFF
    786            }
   \                     ??CrossCallReturnLabel_96:
   \   000036   E9           MOV     A,R1
   \   000037   F5..         MOV     ?V0 + 0,A
    787          
    788            return status;
   \                     ??ZDSecMgrEntryLookupExt_0:
   \   000039   02....       LJMP    ?Subroutine1 & 0xFFFF
    789          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine117_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FA           MOV     R2,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine1:
   \   000000   A9..         MOV     R1,?V0 + 0
   \   000002                REQUIRE ??Subroutine131_0
   \   000002                ; // Fall through to label ??Subroutine131_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine131_0:
   \   000000   7402         MOV     A,#0x2
   \   000002                REQUIRE ??Subroutine132_0
   \   000002                ; // Fall through to label ??Subroutine132_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine142_0:
   \   000000   12....       LCALL   ??Subroutine117_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_313:
   \   000003   FB           MOV     R3,A
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine65:
   \   000000   12....       LCALL   ??Subroutine142_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_302:
   \   000003   12....       LCALL   ??ZDSecMgrEntryLookupAMI?relay
   \   000006   22           RET
    790          
    791          /******************************************************************************
    792           * @fn          ZDSecMgrEntryLookupExtGetIndex
    793           *
    794           * @brief       Lookup entry index using specified EXT address.
    795           *
    796           * @param       extAddr - [in] EXT address
    797           * @param       entryIndex - [out] valid index to the entry table
    798           *
    799           * @return      ZStatus_t
    800           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    801          ZStatus_t ZDSecMgrEntryLookupExtGetIndex( uint8* extAddr, ZDSecMgrEntry_t** entry, uint16* entryIndex )
   \                     ZDSecMgrEntryLookupExtGetIndex:
    802          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EC           MOV     A,R4
   \   00000B   FE           MOV     R6,A
   \   00000C   ED           MOV     A,R5
   \   00000D   FF           MOV     R7,A
   \   00000E   740C         MOV     A,#0xc
   \   000010   12....       LCALL   ?XSTACK_DISP0_8
   \   000013   12....       LCALL   ??Subroutine144_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_314:
   \   000016   88..         MOV     ?V0 + 0,R0
   \   000018   89..         MOV     ?V0 + 1,R1
    803            ZStatus_t status;
    804            uint16    ami;
    805            uint16    index;
    806          
    807            // initialize results
    808            status = ZNwkUnknownDevice;
    809          
    810            // lookup address index
    811            if ( ZDSecMgrExtAddrLookup( extAddr, &ami ) == ZSuccess )
   \   00001A                ; Setup parameters for call to function ZDSecMgrExtAddrLookup
   \   00001A   85..82       MOV     DPL,?XSP + 0
   \   00001D   85..83       MOV     DPH,?XSP + 1
   \   000020   AC82         MOV     R4,DPL
   \   000022   AD83         MOV     R5,DPH
   \   000024   12....       LCALL   ??ZDSecMgrExtAddrLookup?relay
   \   000027   E9           MOV     A,R1
   \   000028   7053         JNZ     ??ZDSecMgrEntryLookupExtGetIndex_0
    812            {  
    813              // verify data is available
    814              if ( ZDSecMgrEntries != NULL )
   \   00002A   90....       MOV     DPTR,#ZDSecMgrEntries
   \   00002D   E0           MOVX    A,@DPTR
   \   00002E   7002         JNZ     ??ZDSecMgrEntryLookupExtGetIndex_1
   \   000030   A3           INC     DPTR
   \   000031   E0           MOVX    A,@DPTR
   \                     ??ZDSecMgrEntryLookupExtGetIndex_1:
   \   000032   6049         JZ      ??ZDSecMgrEntryLookupExtGetIndex_0
    815              {
    816                for ( index = 0; index < ZDSECMGR_ENTRY_MAX ; index++ )
   \   000034   7800         MOV     R0,#0x0
   \   000036   7900         MOV     R1,#0x0
    817                {
    818                  if ( ZDSecMgrEntries[index].ami == ami )
   \                     ??ZDSecMgrEntryLookupExtGetIndex_2:
   \   000038   E8           MOV     A,R0
   \   000039   FA           MOV     R2,A
   \   00003A   E9           MOV     A,R1
   \   00003B   FB           MOV     R3,A
   \   00003C   EA           MOV     A,R2
   \   00003D   75F005       MOV     B,#0x5
   \   000040   A4           MUL     AB
   \   000041   FA           MOV     R2,A
   \   000042   ACF0         MOV     R4,B
   \   000044   75F005       MOV     B,#0x5
   \   000047   EB           MOV     A,R3
   \   000048   A4           MUL     AB
   \   000049   2C           ADD     A,R4
   \   00004A   FB           MOV     R3,A
   \   00004B   90....       MOV     DPTR,#ZDSecMgrEntries
   \   00004E   12....       LCALL   ?Subroutine63 & 0xFFFF
   \                     ??CrossCallReturnLabel_92:
   \   000051   12....       LCALL   ??Subroutine123_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_230:
   \   000054   85..82       MOV     DPL,?XSP + 0
   \   000057   85..83       MOV     DPH,?XSP + 1
   \   00005A   E0           MOVX    A,@DPTR
   \   00005B   6A           XRL     A,R2
   \   00005C   7003         JNZ     ??ZDSecMgrEntryLookupExtGetIndex_3
   \   00005E   A3           INC     DPTR
   \   00005F   E0           MOVX    A,@DPTR
   \   000060   6B           XRL     A,R3
   \                     ??ZDSecMgrEntryLookupExtGetIndex_3:
   \   000061   7015         JNZ     ??ZDSecMgrEntryLookupExtGetIndex_4
    819                  {
    820                    // return successful results
    821                    *entry = &ZDSecMgrEntries[index];
   \   000063   12....       LCALL   ?Subroutine77 & 0xFFFF
   \                     ??CrossCallReturnLabel_118:
   \   000066   8E82         MOV     DPL,R6
   \   000068   8F83         MOV     DPH,R7
   \   00006A   12....       LCALL   ?Subroutine29 & 0xFFFF
    822                    *entryIndex = index;
   \                     ??CrossCallReturnLabel_37:
   \   00006D   85..82       MOV     DPL,?V0 + 0
   \   000070   85..83       MOV     DPH,?V0 + 1
   \   000073   12....       LCALL   ??Subroutine107_0 & 0xFFFF
    823                    status = ZSuccess;
    824                    
    825                    return status;
    826                  }
    827                }
   \                     ??CrossCallReturnLabel_168:
   \   000076   8007         SJMP    ??ZDSecMgrEntryLookupExtGetIndex_5
   \                     ??ZDSecMgrEntryLookupExtGetIndex_4:
   \   000078   12....       LCALL   ?Subroutine35 & 0xFFFF
    828              }
    829            }
   \                     ??CrossCallReturnLabel_52:
   \   00007B   40BB         JC      ??ZDSecMgrEntryLookupExtGetIndex_2
    830          
    831            return status;
   \                     ??ZDSecMgrEntryLookupExtGetIndex_0:
   \   00007D   79C8         MOV     R1,#-0x38
   \                     ??ZDSecMgrEntryLookupExtGetIndex_5:
   \   00007F   02....       LJMP    ?Subroutine0 & 0xFFFF
    832          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine63:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   2A           ADD     A,R2
   \   000002   FC           MOV     R4,A
   \   000003   A3           INC     DPTR
   \   000004   E0           MOVX    A,@DPTR
   \   000005   3B           ADDC    A,R3
   \   000006   8C82         MOV     DPL,R4
   \   000008   F583         MOV     DPH,A
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   7402         MOV     A,#0x2
   \   000002                REQUIRE ??Subroutine118_0
   \   000002                ; // Fall through to label ??Subroutine118_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine123_0:
   \   000000   12....       LCALL   ??Subroutine142_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_307:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine144_0:
   \   000000   12....       LCALL   ?Subroutine94 & 0xFFFF
   \                     ??CrossCallReturnLabel_326:
   \   000003   22           RET
    833          
    834          /******************************************************************************
    835           * @fn          ZDSecMgrEntryFree
    836           *
    837           * @brief       Free entry.
    838           *
    839           * @param       entry - [in] valid entry
    840           *
    841           * @return      ZStatus_t
    842           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    843          void ZDSecMgrEntryFree( ZDSecMgrEntry_t* entry )
   \                     ZDSecMgrEntryFree:
    844          {
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
    845            APSME_LinkKeyData_t   *pApsLinkKey = NULL;
    846            
    847            pApsLinkKey = (APSME_LinkKeyData_t *)osal_mem_alloc(sizeof(APSME_LinkKeyData_t));
   \   000009                ; Setup parameters for call to function osal_mem_alloc
   \   000009   12....       LCALL   ?Subroutine75 & 0xFFFF
    848          
    849            if (pApsLinkKey != NULL)
   \                     ??CrossCallReturnLabel_113:
   \   00000C   7001         JNZ     ??ZDSecMgrEntryFree_0
   \   00000E   EB           MOV     A,R3
   \                     ??ZDSecMgrEntryFree_0:
   \   00000F   603D         JZ      ??ZDSecMgrEntryFree_1
    850            {
    851              osal_memset( pApsLinkKey, 0x00, sizeof(APSME_LinkKeyData_t) );
   \   000011                ; Setup parameters for call to function osal_memset
   \   000011   7C18         MOV     R4,#0x18
   \   000013   7D00         MOV     R5,#0x0
   \   000015   7900         MOV     R1,#0x0
   \   000017   12....       LCALL   ??osal_memset?relay
    852          
    853              // Clear the APS Link key in NV
    854              osal_nv_write( entry->keyNvId, 0,
    855                                  sizeof(APSME_LinkKeyData_t), pApsLinkKey);
   \   00001A   12....       LCALL   ?Subroutine82 & 0xFFFF
   \                     ??CrossCallReturnLabel_126:
   \   00001D                ; Setup parameters for call to function osal_nv_write
   \   00001D   78..         MOV     R0,#?V0 + 2
   \   00001F   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000022   75..18       MOV     ?V0 + 4,#0x18
   \   000025   75..00       MOV     ?V0 + 5,#0x0
   \   000028   78..         MOV     R0,#?V0 + 4
   \   00002A   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00002D   7C00         MOV     R4,#0x0
   \   00002F   7D00         MOV     R5,#0x0
   \   000031   85..82       MOV     DPL,?V0 + 0
   \   000034   12....       LCALL   ?Subroutine104 & 0xFFFF
   \                     ??CrossCallReturnLabel_311:
   \   000037   12....       LCALL   ??Subroutine109_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_174:
   \   00003A   12....       LCALL   ?DEALLOC_XSTACK8
    856          
    857              // set entry to invalid Key
    858              entry->keyNvId = SEC_NO_KEY_NV_ID;
   \   00003D   85..82       MOV     DPL,?V0 + 0
   \   000040   85..83       MOV     DPH,?V0 + 1
   \   000043   E4           CLR     A
   \   000044   F0           MOVX    @DPTR,A
   \   000045   A3           INC     DPTR
   \   000046   F0           MOVX    @DPTR,A
    859              
    860              osal_mem_free(pApsLinkKey);
   \   000047                ; Setup parameters for call to function osal_mem_free
   \   000047   AA..         MOV     R2,?V0 + 2
   \   000049   AB..         MOV     R3,?V0 + 3
   \   00004B   12....       LCALL   ??osal_mem_free?relay
    861            }
    862          
    863            // marking the entry as INVALID_NODE_ADDR
    864            entry->ami = INVALID_NODE_ADDR;
   \                     ??ZDSecMgrEntryFree_1:
   \   00004E   8E82         MOV     DPL,R6
   \   000050   8F83         MOV     DPH,R7
   \   000052   74FE         MOV     A,#-0x2
   \   000054   F0           MOVX    @DPTR,A
   \   000055   A3           INC     DPTR
   \   000056   74FF         MOV     A,#-0x1
   \   000058   F0           MOVX    @DPTR,A
    865          }
   \   000059   02....       LJMP    ?Subroutine2 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine104:
   \   000000   8983         MOV     DPH,R1
   \   000002                REQUIRE ??Subroutine117_0
   \   000002                ; // Fall through to label ??Subroutine117_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine82:
   \   000000   EE           MOV     A,R6
   \   000001   2402         ADD     A,#0x2
   \   000003   F8           MOV     R0,A
   \   000004   EF           MOV     A,R7
   \   000005   3400         ADDC    A,#0x0
   \   000007   F9           MOV     R1,A
   \   000008   88..         MOV     ?V0 + 0,R0
   \   00000A   89..         MOV     ?V0 + 1,R1
   \   00000C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine75:
   \   000000   7A18         MOV     R2,#0x18
   \   000002   7B00         MOV     R3,#0x0
   \   000004   12....       LCALL   ??osal_mem_alloc?relay
   \   000007   8A..         MOV     ?V0 + 2,R2
   \   000009   8B..         MOV     ?V0 + 3,R3
   \   00000B   EA           MOV     A,R2
   \   00000C   22           RET
    866          
    867          /******************************************************************************
    868           * @fn          ZDSecMgrEntryNew
    869           *
    870           * @brief       Get a new entry.
    871           *
    872           * @param       entry - [out] valid entry
    873           *
    874           * @return      ZStatus_t
    875           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    876          ZStatus_t ZDSecMgrEntryNew( ZDSecMgrEntry_t** entry )
   \                     ZDSecMgrEntryNew:
    877          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
    878            ZStatus_t status;
    879            uint16    index;
    880          
    881          
    882            // initialize results
    883            *entry = NULL;
   \   000005   8A82         MOV     DPL,R2
   \   000007   8B83         MOV     DPH,R3
   \   000009   E4           CLR     A
   \   00000A   F0           MOVX    @DPTR,A
   \   00000B   A3           INC     DPTR
   \   00000C   F0           MOVX    @DPTR,A
    884            status = ZNwkUnknownDevice;
   \   00000D   79C8         MOV     R1,#-0x38
    885          
    886            // verify data is available
    887            if ( ZDSecMgrEntries != NULL )
   \   00000F   90....       MOV     DPTR,#ZDSecMgrEntries
   \   000012   E0           MOVX    A,@DPTR
   \   000013   7002         JNZ     ??ZDSecMgrEntryNew_0
   \   000015   A3           INC     DPTR
   \   000016   E0           MOVX    A,@DPTR
   \                     ??ZDSecMgrEntryNew_0:
   \   000017   6075         JZ      ??ZDSecMgrEntryNew_1
    888            {
    889              // find available entry
    890              for ( index = 0; index < ZDSECMGR_ENTRY_MAX ; index++ )
   \   000019   7C00         MOV     R4,#0x0
   \   00001B   7D00         MOV     R5,#0x0
    891              {
    892                if ( ZDSecMgrEntries[index].ami == INVALID_NODE_ADDR )
   \                     ??ZDSecMgrEntryNew_2:
   \   00001D   EC           MOV     A,R4
   \   00001E   FE           MOV     R6,A
   \   00001F   ED           MOV     A,R5
   \   000020   FF           MOV     R7,A
   \   000021   EE           MOV     A,R6
   \   000022   75F005       MOV     B,#0x5
   \   000025   A4           MUL     AB
   \   000026   FE           MOV     R6,A
   \   000027   A8F0         MOV     R0,B
   \   000029   75F005       MOV     B,#0x5
   \   00002C   EF           MOV     A,R7
   \   00002D   A4           MUL     AB
   \   00002E   28           ADD     A,R0
   \   00002F   FF           MOV     R7,A
   \   000030   90....       MOV     DPTR,#ZDSecMgrEntries
   \   000033   E0           MOVX    A,@DPTR
   \   000034   2E           ADD     A,R6
   \   000035   F8           MOV     R0,A
   \   000036   A3           INC     DPTR
   \   000037   E0           MOVX    A,@DPTR
   \   000038   3F           ADDC    A,R7
   \   000039   8882         MOV     DPL,R0
   \   00003B   F583         MOV     DPH,A
   \   00003D   E0           MOVX    A,@DPTR
   \   00003E   64FE         XRL     A,#0xfe
   \   000040   7004         JNZ     ??ZDSecMgrEntryNew_3
   \   000042   A3           INC     DPTR
   \   000043   E0           MOVX    A,@DPTR
   \   000044   64FF         XRL     A,#0xff
   \                     ??ZDSecMgrEntryNew_3:
   \   000046   7035         JNZ     ??ZDSecMgrEntryNew_4
    893                {
    894                  // return successful result
    895                  *entry = &ZDSecMgrEntries[index];
   \   000048   EC           MOV     A,R4
   \   000049   75F005       MOV     B,#0x5
   \   00004C   A4           MUL     AB
   \   00004D   FC           MOV     R4,A
   \   00004E   AEF0         MOV     R6,B
   \   000050   75F005       MOV     B,#0x5
   \   000053   ED           MOV     A,R5
   \   000054   A4           MUL     AB
   \   000055   2E           ADD     A,R6
   \   000056   FD           MOV     R5,A
   \   000057   90....       MOV     DPTR,#ZDSecMgrEntries
   \   00005A   E0           MOVX    A,@DPTR
   \   00005B   2C           ADD     A,R4
   \   00005C   A3           INC     DPTR
   \   00005D   E0           MOVX    A,@DPTR
   \   00005E   3D           ADDC    A,R5
   \   00005F   F9           MOV     R1,A
   \   000060   8A82         MOV     DPL,R2
   \   000062   8B83         MOV     DPH,R3
   \   000064   12....       LCALL   ??Subroutine107_0 & 0xFFFF
    896                  status = ZSuccess;
    897          
    898                  // Set the authentication option to default
    899                  ZDSecMgrEntries[index].authenticateOption = ZDSecMgr_Not_Authenticated;
   \                     ??CrossCallReturnLabel_169:
   \   000067   90....       MOV     DPTR,#ZDSecMgrEntries
   \   00006A   E0           MOVX    A,@DPTR
   \   00006B   2C           ADD     A,R4
   \   00006C   FE           MOV     R6,A
   \   00006D   A3           INC     DPTR
   \   00006E   E0           MOVX    A,@DPTR
   \   00006F   3D           ADDC    A,R5
   \   000070   8E82         MOV     DPL,R6
   \   000072   F583         MOV     DPH,A
   \   000074   A3           INC     DPTR
   \   000075   A3           INC     DPTR
   \   000076   A3           INC     DPTR
   \   000077   A3           INC     DPTR
   \   000078   E4           CLR     A
   \   000079   F0           MOVX    @DPTR,A
    900          
    901                  // break from loop
    902                  index = ZDSECMGR_ENTRY_MAX;
   \   00007A   7C03         MOV     R4,#0x3
   \   00007C   FD           MOV     R5,A
    903                }
    904              }
   \                     ??ZDSecMgrEntryNew_4:
   \   00007D   EC           MOV     A,R4
   \   00007E   2401         ADD     A,#0x1
   \   000080   0C           INC     R4
   \   000081   ED           MOV     A,R5
   \   000082   3400         ADDC    A,#0x0
   \   000084   FD           MOV     R5,A
   \   000085   C3           CLR     C
   \   000086   EC           MOV     A,R4
   \   000087   9403         SUBB    A,#0x3
   \   000089   ED           MOV     A,R5
   \   00008A   9400         SUBB    A,#0x0
   \   00008C   408F         JC      ??ZDSecMgrEntryNew_2
    905            }
    906          
    907            return status;
   \                     ??ZDSecMgrEntryNew_1:
   \   00008E   02....       LJMP    ??Subroutine133_0 & 0xFFFF
    908          }
    909          
    910          /******************************************************************************
    911           * @fn          ZDSecMgrCtrlInit
    912           *
    913           * @brief       Initialize control sub module
    914           *
    915           * @param       none
    916           *
    917           * @return      none
    918           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    919          void ZDSecMgrCtrlInit( void )
   \                     ZDSecMgrCtrlInit:
    920          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    921            uint16 size;
    922            uint16 index;
    923          
    924            // allocate entry data
    925            size = (short)( sizeof(ZDSecMgrCtrl_t) * ZDSECMGR_CTRL_MAX );
    926          
    927            ZDSecMgrCtrlData = osal_mem_alloc( size );
   \   000004                ; Setup parameters for call to function osal_mem_alloc
   \   000004   7A15         MOV     R2,#0x15
   \   000006   7B00         MOV     R3,#0x0
   \   000008   12....       LCALL   ??osal_mem_alloc?relay
   \   00000B   90....       MOV     DPTR,#ZDSecMgrCtrlData
   \   00000E   12....       LCALL   ?Subroutine29 & 0xFFFF
    928          
    929            // initialize data
    930            if ( ZDSecMgrCtrlData != NULL )
   \                     ??CrossCallReturnLabel_38:
   \   000011   90....       MOV     DPTR,#ZDSecMgrCtrlData
   \   000014   E0           MOVX    A,@DPTR
   \   000015   7002         JNZ     ??ZDSecMgrCtrlInit_0
   \   000017   A3           INC     DPTR
   \   000018   E0           MOVX    A,@DPTR
   \                     ??ZDSecMgrCtrlInit_0:
   \   000019   6028         JZ      ??ZDSecMgrCtrlInit_1
    931            {
    932              for( index = 0; index < ZDSECMGR_CTRL_MAX; index++ )
   \   00001B   7800         MOV     R0,#0x0
   \   00001D   7900         MOV     R1,#0x0
    933              {
    934                ZDSecMgrCtrlData[index].state = ZDSECMGR_CTRL_NONE;
   \                     ??ZDSecMgrCtrlInit_2:
   \   00001F   E8           MOV     A,R0
   \   000020   FA           MOV     R2,A
   \   000021   E9           MOV     A,R1
   \   000022   FB           MOV     R3,A
   \   000023   EA           MOV     A,R2
   \   000024   75F007       MOV     B,#0x7
   \   000027   A4           MUL     AB
   \   000028   FA           MOV     R2,A
   \   000029   ACF0         MOV     R4,B
   \   00002B   75F007       MOV     B,#0x7
   \   00002E   EB           MOV     A,R3
   \   00002F   A4           MUL     AB
   \   000030   2C           ADD     A,R4
   \   000031   FB           MOV     R3,A
   \   000032   90....       MOV     DPTR,#ZDSecMgrCtrlData
   \   000035   12....       LCALL   ?Subroutine63 & 0xFFFF
    935              }
    936            }
   \                     ??CrossCallReturnLabel_93:
   \   000038   A3           INC     DPTR
   \   000039   A3           INC     DPTR
   \   00003A   A3           INC     DPTR
   \   00003B   A3           INC     DPTR
   \   00003C   A3           INC     DPTR
   \   00003D   E4           CLR     A
   \   00003E   12....       LCALL   ?Subroutine18 & 0xFFFF
   \                     ??CrossCallReturnLabel_8:
   \   000041   40DC         JC      ??ZDSecMgrCtrlInit_2
    937          }
   \                     ??ZDSecMgrCtrlInit_1:
   \   000043   02....       LJMP    ??Subroutine125_0 & 0xFFFF
    938          
    939          /******************************************************************************
    940           * @fn          ZDSecMgrCtrlRelease
    941           *
    942           * @brief       Release control data.
    943           *
    944           * @param       ctrl - [in] valid control data
    945           *
    946           * @return      none
    947           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    948          void ZDSecMgrCtrlRelease( ZDSecMgrCtrl_t* ctrl )
   \                     ZDSecMgrCtrlRelease:
    949          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    950            // should always be enough entry control data
    951            ctrl->state = ZDSECMGR_CTRL_NONE;
   \   000004   E4           CLR     A
   \   000005   8A82         MOV     DPL,R2
   \   000007   8B83         MOV     DPH,R3
   \   000009   A3           INC     DPTR
   \   00000A   A3           INC     DPTR
   \   00000B   A3           INC     DPTR
   \   00000C   A3           INC     DPTR
   \   00000D   A3           INC     DPTR
   \   00000E   F0           MOVX    @DPTR,A
    952          }
   \   00000F   02....       LJMP    ??Subroutine125_0 & 0xFFFF
    953          
    954          /******************************************************************************
    955           * @fn          ZDSecMgrCtrlLookup
    956           *
    957           * @brief       Lookup control data.
    958           *
    959           * @param       entry - [in] valid entry data
    960           * @param       ctrl  - [out] control data - NULL if not found
    961           *
    962           * @return      none
    963           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    964          void ZDSecMgrCtrlLookup( ZDSecMgrEntry_t* entry, ZDSecMgrCtrl_t** ctrl )
   \                     ZDSecMgrCtrlLookup:
    965          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
    966            uint16 index;
    967          
    968          
    969            // initialize search results
    970            *ctrl = NULL;
   \   000009   8C82         MOV     DPL,R4
   \   00000B   8D83         MOV     DPH,R5
   \   00000D   E4           CLR     A
   \   00000E   F0           MOVX    @DPTR,A
   \   00000F   A3           INC     DPTR
   \   000010   F0           MOVX    @DPTR,A
    971          
    972            // verify data is available
    973            if ( ZDSecMgrCtrlData != NULL )
   \   000011   90....       MOV     DPTR,#ZDSecMgrCtrlData
   \   000014   E0           MOVX    A,@DPTR
   \   000015   7002         JNZ     ??ZDSecMgrCtrlLookup_0
   \   000017   A3           INC     DPTR
   \   000018   E0           MOVX    A,@DPTR
   \                     ??ZDSecMgrCtrlLookup_0:
   \   000019   606F         JZ      ??ZDSecMgrCtrlLookup_1
    974            {
    975              for ( index = 0; index < ZDSECMGR_CTRL_MAX; index++ )
   \   00001B   7800         MOV     R0,#0x0
   \   00001D   7900         MOV     R1,#0x0
    976              {
    977                // make sure control data is in use
    978                if ( ZDSecMgrCtrlData[index].state != ZDSECMGR_CTRL_NONE )
   \                     ??ZDSecMgrCtrlLookup_2:
   \   00001F   E8           MOV     A,R0
   \   000020   FA           MOV     R2,A
   \   000021   E9           MOV     A,R1
   \   000022   FB           MOV     R3,A
   \   000023   EA           MOV     A,R2
   \   000024   75F007       MOV     B,#0x7
   \   000027   A4           MUL     AB
   \   000028   FA           MOV     R2,A
   \   000029   85F0..       MOV     ?V0 + 0,B
   \   00002C   75F007       MOV     B,#0x7
   \   00002F   EB           MOV     A,R3
   \   000030   A4           MUL     AB
   \   000031   25..         ADD     A,?V0 + 0
   \   000033   FB           MOV     R3,A
   \   000034   90....       MOV     DPTR,#ZDSecMgrCtrlData
   \   000037   12....       LCALL   ?Subroutine96 & 0xFFFF
   \                     ??CrossCallReturnLabel_144:
   \   00003A   A3           INC     DPTR
   \   00003B   A3           INC     DPTR
   \   00003C   A3           INC     DPTR
   \   00003D   A3           INC     DPTR
   \   00003E   A3           INC     DPTR
   \   00003F   E0           MOVX    A,@DPTR
   \   000040   6043         JZ      ??ZDSecMgrCtrlLookup_3
    979                {
    980                  // check for entry match
    981                  if ( ZDSecMgrCtrlData[index].entry == entry )
   \   000042   E8           MOV     A,R0
   \   000043   FA           MOV     R2,A
   \   000044   E9           MOV     A,R1
   \   000045   FB           MOV     R3,A
   \   000046   EA           MOV     A,R2
   \   000047   75F007       MOV     B,#0x7
   \   00004A   A4           MUL     AB
   \   00004B   FA           MOV     R2,A
   \   00004C   85F0..       MOV     ?V0 + 0,B
   \   00004F   75F007       MOV     B,#0x7
   \   000052   EB           MOV     A,R3
   \   000053   A4           MUL     AB
   \   000054   25..         ADD     A,?V0 + 0
   \   000056   FB           MOV     R3,A
   \   000057   90....       MOV     DPTR,#ZDSecMgrCtrlData
   \   00005A   12....       LCALL   ?Subroutine58 & 0xFFFF
   \                     ??CrossCallReturnLabel_83:
   \   00005D   FA           MOV     R2,A
   \   00005E   A3           INC     DPTR
   \   00005F   E0           MOVX    A,@DPTR
   \   000060   FB           MOV     R3,A
   \   000061   EE           MOV     A,R6
   \   000062   6A           XRL     A,R2
   \   000063   7002         JNZ     ??ZDSecMgrCtrlLookup_4
   \   000065   EF           MOV     A,R7
   \   000066   6B           XRL     A,R3
   \                     ??ZDSecMgrCtrlLookup_4:
   \   000067   701C         JNZ     ??ZDSecMgrCtrlLookup_3
    982                  {
    983                    // return this control data
    984                    *ctrl = &ZDSecMgrCtrlData[index];
   \   000069   E8           MOV     A,R0
   \   00006A   75F007       MOV     B,#0x7
   \   00006D   A4           MUL     AB
   \   00006E   F8           MOV     R0,A
   \   00006F   AAF0         MOV     R2,B
   \   000071   75F007       MOV     B,#0x7
   \   000074   E9           MOV     A,R1
   \   000075   A4           MUL     AB
   \   000076   2A           ADD     A,R2
   \   000077   F9           MOV     R1,A
   \   000078   90....       MOV     DPTR,#ZDSecMgrCtrlData
   \   00007B   12....       LCALL   ?Subroutine61 & 0xFFFF
   \                     ??CrossCallReturnLabel_89:
   \   00007E   12....       LCALL   ??Subroutine113_0 & 0xFFFF
    985          
    986                    // break from loop
    987                    index = ZDSECMGR_CTRL_MAX;
   \                     ??CrossCallReturnLabel_189:
   \   000081   7803         MOV     R0,#0x3
   \   000083   7900         MOV     R1,#0x0
    988                  }
    989                }
    990              }
   \                     ??ZDSecMgrCtrlLookup_3:
   \   000085   12....       LCALL   ?Subroutine35 & 0xFFFF
    991            }
   \                     ??CrossCallReturnLabel_53:
   \   000088   4095         JC      ??ZDSecMgrCtrlLookup_2
    992          }
   \                     ??ZDSecMgrCtrlLookup_1:
   \   00008A   02....       LJMP    ??Subroutine133_0 & 0xFFFF
    993          
    994          /******************************************************************************
    995           * @fn          ZDSecMgrCtrlSet
    996           *
    997           * @brief       Set control data.
    998           *
    999           * @param       device - [in] valid device data
   1000           * @param       entry  - [in] valid entry data
   1001           * @param       ctrl   - [in] valid control data
   1002           *
   1003           * @return      none
   1004           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1005          void ZDSecMgrCtrlSet( ZDSecMgrDevice_t* device,
   \                     ZDSecMgrCtrlSet:
   1006                                ZDSecMgrEntry_t*  entry,
   1007                                ZDSecMgrCtrl_t*   ctrl )
   1008          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   7409         MOV     A,#0x9
   \   000007   12....       LCALL   ?XSTACK_DISP0_8
   \   00000A   12....       LCALL   ??Subroutine144_0 & 0xFFFF
   1009            // set control date
   1010            ctrl->parentAddr = device->parentAddr;
   \                     ??CrossCallReturnLabel_315:
   \   00000D   8A82         MOV     DPL,R2
   \   00000F   8B83         MOV     DPH,R3
   \   000011   A3           INC     DPTR
   \   000012   A3           INC     DPTR
   \   000013   A3           INC     DPTR
   \   000014   A3           INC     DPTR
   \   000015   E0           MOVX    A,@DPTR
   \   000016   FE           MOV     R6,A
   \   000017   A3           INC     DPTR
   \   000018   E0           MOVX    A,@DPTR
   \   000019   FF           MOV     R7,A
   \   00001A   8882         MOV     DPL,R0
   \   00001C   8983         MOV     DPH,R1
   \   00001E   A3           INC     DPTR
   \   00001F   A3           INC     DPTR
   \   000020   EE           MOV     A,R6
   \   000021   F0           MOVX    @DPTR,A
   \   000022   A3           INC     DPTR
   \   000023   EF           MOV     A,R7
   \   000024   12....       LCALL   ?Subroutine86 & 0xFFFF
   1011            ctrl->secure     = device->secure;
   \                     ??CrossCallReturnLabel_133:
   \   000027   E0           MOVX    A,@DPTR
   \   000028   8882         MOV     DPL,R0
   \   00002A   8983         MOV     DPH,R1
   \   00002C   A3           INC     DPTR
   \   00002D   A3           INC     DPTR
   \   00002E   A3           INC     DPTR
   \   00002F   A3           INC     DPTR
   \   000030   F0           MOVX    @DPTR,A
   1012            ctrl->entry      = entry;
   \   000031   8882         MOV     DPL,R0
   \   000033   8983         MOV     DPH,R1
   \   000035   EC           MOV     A,R4
   \   000036   F0           MOVX    @DPTR,A
   \   000037   A3           INC     DPTR
   \   000038   ED           MOV     A,R5
   \   000039   F0           MOVX    @DPTR,A
   1013            ctrl->state      = ZDSECMGR_CTRL_INIT;
   \   00003A   7401         MOV     A,#0x1
   \   00003C   8882         MOV     DPL,R0
   \   00003E   8983         MOV     DPH,R1
   \   000040   A3           INC     DPTR
   \   000041   A3           INC     DPTR
   \   000042   A3           INC     DPTR
   \   000043   A3           INC     DPTR
   \   000044   A3           INC     DPTR
   \   000045   F0           MOVX    @DPTR,A
   1014            ctrl->cntr       = 0;
   \   000046   E4           CLR     A
   \   000047   8882         MOV     DPL,R0
   \   000049   8983         MOV     DPH,R1
   \   00004B   A3           INC     DPTR
   \   00004C   A3           INC     DPTR
   \   00004D   A3           INC     DPTR
   \   00004E   A3           INC     DPTR
   \   00004F   A3           INC     DPTR
   \   000050   A3           INC     DPTR
   \   000051   12....       LCALL   ?Subroutine26 & 0xFFFF
   1015          
   1016            // set device pointer
   1017            device->ctrl = ctrl;
   \                     ??CrossCallReturnLabel_26:
   \   000054   A3           INC     DPTR
   \   000055   12....       LCALL   ??Subroutine113_0 & 0xFFFF
   1018          }
   \                     ??CrossCallReturnLabel_190:
   \   000058   02....       LJMP    ??Subroutine133_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine26:
   \   000000   12....       LCALL   ?Subroutine86 & 0xFFFF
   \                     ??CrossCallReturnLabel_134:
   \   000003   A3           INC     DPTR
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine86:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   8A82         MOV     DPL,R2
   \   000003   8B83         MOV     DPH,R3
   \   000005   A3           INC     DPTR
   \   000006   A3           INC     DPTR
   \   000007   A3           INC     DPTR
   \   000008   A3           INC     DPTR
   \   000009   A3           INC     DPTR
   \   00000A   A3           INC     DPTR
   \   00000B   22           RET
   1019          
   1020          /******************************************************************************
   1021           * @fn          ZDSecMgrCtrlAdd
   1022           *
   1023           * @brief       Add control data.
   1024           *
   1025           * @param       device - [in] valid device data
   1026           * @param       entry  - [in] valid entry data
   1027           *
   1028           * @return      ZStatus_t
   1029           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1030          ZStatus_t ZDSecMgrCtrlAdd( ZDSecMgrDevice_t* device, ZDSecMgrEntry_t*  entry )
   \                     ZDSecMgrCtrlAdd:
   1031          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   \   000009   8C..         MOV     ?V0 + 0,R4
   \   00000B   8D..         MOV     ?V0 + 1,R5
   1032            ZStatus_t status;
   1033            uint16    index;
   1034          
   1035          
   1036            // initialize results
   1037            status = ZNwkUnknownDevice;
   \   00000D   79C8         MOV     R1,#-0x38
   1038          
   1039            // verify data is available
   1040            if ( ZDSecMgrCtrlData != NULL )
   \   00000F   90....       MOV     DPTR,#ZDSecMgrCtrlData
   \   000012   E0           MOVX    A,@DPTR
   \   000013   7002         JNZ     ??ZDSecMgrCtrlAdd_0
   \   000015   A3           INC     DPTR
   \   000016   E0           MOVX    A,@DPTR
   \                     ??ZDSecMgrCtrlAdd_0:
   \   000017   6073         JZ      ??ZDSecMgrCtrlAdd_1
   1041            {
   1042              // look for an empty slot
   1043              for ( index = 0; index < ZDSECMGR_CTRL_MAX; index++ )
   \   000019   7A00         MOV     R2,#0x0
   \   00001B   7B00         MOV     R3,#0x0
   1044              {
   1045                if ( ZDSecMgrCtrlData[index].state == ZDSECMGR_CTRL_NONE )
   \                     ??ZDSecMgrCtrlAdd_2:
   \   00001D   EA           MOV     A,R2
   \   00001E   FC           MOV     R4,A
   \   00001F   EB           MOV     A,R3
   \   000020   FD           MOV     R5,A
   \   000021   EC           MOV     A,R4
   \   000022   75F007       MOV     B,#0x7
   \   000025   A4           MUL     AB
   \   000026   FC           MOV     R4,A
   \   000027   A8F0         MOV     R0,B
   \   000029   75F007       MOV     B,#0x7
   \   00002C   ED           MOV     A,R5
   \   00002D   A4           MUL     AB
   \   00002E   28           ADD     A,R0
   \   00002F   FD           MOV     R5,A
   \   000030   90....       MOV     DPTR,#ZDSecMgrCtrlData
   \   000033   E0           MOVX    A,@DPTR
   \   000034   2C           ADD     A,R4
   \   000035   F8           MOV     R0,A
   \   000036   A3           INC     DPTR
   \   000037   E0           MOVX    A,@DPTR
   \   000038   3D           ADDC    A,R5
   \   000039   8882         MOV     DPL,R0
   \   00003B   F583         MOV     DPH,A
   \   00003D   A3           INC     DPTR
   \   00003E   A3           INC     DPTR
   \   00003F   A3           INC     DPTR
   \   000040   A3           INC     DPTR
   \   000041   A3           INC     DPTR
   \   000042   E0           MOVX    A,@DPTR
   \   000043   7036         JNZ     ??ZDSecMgrCtrlAdd_3
   1046                {
   1047                  // return successful results
   1048                  ZDSecMgrCtrlSet( device, entry, &ZDSecMgrCtrlData[index] );
   \   000045                ; Setup parameters for call to function ZDSecMgrCtrlSet
   \   000045   EA           MOV     A,R2
   \   000046   75F007       MOV     B,#0x7
   \   000049   A4           MUL     AB
   \   00004A   FA           MOV     R2,A
   \   00004B   ACF0         MOV     R4,B
   \   00004D   75F007       MOV     B,#0x7
   \   000050   EB           MOV     A,R3
   \   000051   A4           MUL     AB
   \   000052   2C           ADD     A,R4
   \   000053   FB           MOV     R3,A
   \   000054   90....       MOV     DPTR,#ZDSecMgrCtrlData
   \   000057   E0           MOVX    A,@DPTR
   \   000058   2A           ADD     A,R2
   \   000059   F5..         MOV     ?V0 + 2,A
   \   00005B   A3           INC     DPTR
   \   00005C   E0           MOVX    A,@DPTR
   \   00005D   3B           ADDC    A,R3
   \   00005E   F5..         MOV     ?V0 + 3,A
   \   000060   78..         MOV     R0,#?V0 + 2
   \   000062   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000065   AC..         MOV     R4,?V0 + 0
   \   000067   AD..         MOV     R5,?V0 + 1
   \   000069   EE           MOV     A,R6
   \   00006A   FA           MOV     R2,A
   \   00006B   EF           MOV     A,R7
   \   00006C   FB           MOV     R3,A
   \   00006D   12....       LCALL   ??ZDSecMgrCtrlSet?relay
   \   000070   7402         MOV     A,#0x2
   \   000072   12....       LCALL   ?DEALLOC_XSTACK8
   1049          
   1050                  status = ZSuccess;
   \   000075   7900         MOV     R1,#0x0
   1051          
   1052                  // break from loop
   1053                  index = ZDSECMGR_CTRL_MAX;
   \   000077   7A03         MOV     R2,#0x3
   \   000079   7B00         MOV     R3,#0x0
   1054                }
   1055              }
   \                     ??ZDSecMgrCtrlAdd_3:
   \   00007B   EA           MOV     A,R2
   \   00007C   2401         ADD     A,#0x1
   \   00007E   0A           INC     R2
   \   00007F   EB           MOV     A,R3
   \   000080   3400         ADDC    A,#0x0
   \   000082   FB           MOV     R3,A
   \   000083   C3           CLR     C
   \   000084   EA           MOV     A,R2
   \   000085   9403         SUBB    A,#0x3
   \   000087   EB           MOV     A,R3
   \   000088   9400         SUBB    A,#0x0
   \   00008A   4091         JC      ??ZDSecMgrCtrlAdd_2
   1056            }
   1057          
   1058            return status;
   \                     ??ZDSecMgrCtrlAdd_1:
   \   00008C   02....       LJMP    ??Subroutine129_0 & 0xFFFF
   1059          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine129_0:
   \   000000   7F04         MOV     R7,#0x4
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA
   1060          
   1061          /******************************************************************************
   1062           * @fn          ZDSecMgrCtrlTerm
   1063           *
   1064           * @brief       Terminate device control.
   1065           *
   1066           * @param       entry - [in] valid entry data
   1067           *
   1068           * @return      none
   1069           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1070          void ZDSecMgrCtrlTerm( ZDSecMgrEntry_t* entry )
   \                     ZDSecMgrCtrlTerm:
   1071          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 2
   \   000004   74FE         MOV     A,#-0x2
   \   000006   12....       LCALL   ?ALLOC_XSTACK8
   1072            ZDSecMgrCtrl_t* ctrl;
   1073          
   1074            // remove device from control data
   1075            ZDSecMgrCtrlLookup ( entry, &ctrl );
   \   000009                ; Setup parameters for call to function ZDSecMgrCtrlLookup
   \   000009   85..82       MOV     DPL,?XSP + 0
   \   00000C   85..83       MOV     DPH,?XSP + 1
   \   00000F   AC82         MOV     R4,DPL
   \   000011   AD83         MOV     R5,DPH
   \   000013   12....       LCALL   ?Subroutine81 & 0xFFFF
   1076          
   1077            if ( ctrl != NULL )
   \                     ??CrossCallReturnLabel_123:
   \   000016   7002         JNZ     ??ZDSecMgrCtrlTerm_0
   \   000018   A3           INC     DPTR
   \   000019   E0           MOVX    A,@DPTR
   \                     ??ZDSecMgrCtrlTerm_0:
   \   00001A   6009         JZ      ??CrossCallReturnLabel_76
   1078            {
   1079              ZDSecMgrCtrlRelease ( ctrl );
   \   00001C   85..82       MOV     DPL,?XSP + 0
   \   00001F   85..83       MOV     DPH,?XSP + 1
   \   000022   12....       LCALL   ?Subroutine53 & 0xFFFF
   1080            }
   1081          }
   \                     ??CrossCallReturnLabel_76:
   \   000025   7402         MOV     A,#0x2
   \   000027   80..         SJMP    ??Subroutine111_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine111_0:
   \   000000   12....       LCALL   ?DEALLOC_XSTACK8
   \   000003   02....       LJMP    ??Subroutine125_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine81:
   \   000000   12....       LCALL   ??ZDSecMgrCtrlLookup?relay
   \   000003   85..82       MOV     DPL,?XSP + 0
   \   000006   85..83       MOV     DPH,?XSP + 1
   \   000009   E0           MOVX    A,@DPTR
   \   00000A   22           RET
   1082          
   1083          /******************************************************************************
   1084           * @fn          ZDSecMgrCtrlReset
   1085           *
   1086           * @brief       Reset control data.
   1087           *
   1088           * @param       device - [in] valid device data
   1089           * @param       entry  - [in] valid entry data
   1090           *
   1091           * @return      ZStatus_t
   1092           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1093          ZStatus_t ZDSecMgrCtrlReset( ZDSecMgrDevice_t* device, ZDSecMgrEntry_t* entry )
   \                     ZDSecMgrCtrlReset:
   1094          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0 + 0,R2
   \   00000C   8B..         MOV     ?V0 + 1,R3
   \   00000E   EC           MOV     A,R4
   \   00000F   FE           MOV     R6,A
   \   000010   ED           MOV     A,R5
   \   000011   FF           MOV     R7,A
   1095            ZStatus_t       status;
   1096            ZDSecMgrCtrl_t* ctrl;
   1097          
   1098          
   1099            // initialize results
   1100            status = ZNwkUnknownDevice;
   1101          
   1102            // look for a match for the entry
   1103            ZDSecMgrCtrlLookup( entry, &ctrl );
   \   000012                ; Setup parameters for call to function ZDSecMgrCtrlLookup
   \   000012   85..82       MOV     DPL,?XSP + 0
   \   000015   85..83       MOV     DPH,?XSP + 1
   \   000018   AC82         MOV     R4,DPL
   \   00001A   AD83         MOV     R5,DPH
   \   00001C   EE           MOV     A,R6
   \   00001D   FA           MOV     R2,A
   \   00001E   EF           MOV     A,R7
   \   00001F   FB           MOV     R3,A
   \   000020   12....       LCALL   ?Subroutine81 & 0xFFFF
   1104          
   1105            if ( ctrl != NULL )
   \                     ??CrossCallReturnLabel_124:
   \   000023   7002         JNZ     ??ZDSecMgrCtrlReset_0
   \   000025   A3           INC     DPTR
   \   000026   E0           MOVX    A,@DPTR
   \                     ??ZDSecMgrCtrlReset_0:
   \   000027   601D         JZ      ??ZDSecMgrCtrlReset_1
   1106            {
   1107              ZDSecMgrCtrlSet( device, entry, ctrl );
   \   000029                ; Setup parameters for call to function ZDSecMgrCtrlSet
   \   000029   85..82       MOV     DPL,?XSP + 0
   \   00002C   85..83       MOV     DPH,?XSP + 1
   \   00002F   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   000032   EE           MOV     A,R6
   \   000033   FC           MOV     R4,A
   \   000034   EF           MOV     A,R7
   \   000035   FD           MOV     R5,A
   \   000036   AA..         MOV     R2,?V0 + 0
   \   000038   AB..         MOV     R3,?V0 + 1
   \   00003A   12....       LCALL   ??ZDSecMgrCtrlSet?relay
   \   00003D   7402         MOV     A,#0x2
   \   00003F   12....       LCALL   ?DEALLOC_XSTACK8
   1108          
   1109              status = ZSuccess;
   \   000042   7900         MOV     R1,#0x0
   \   000044   800B         SJMP    ??ZDSecMgrCtrlReset_2
   1110            }
   1111            else
   1112            {
   1113              status = ZDSecMgrCtrlAdd( device, entry );
   \                     ??ZDSecMgrCtrlReset_1:
   \   000046                ; Setup parameters for call to function ZDSecMgrCtrlAdd
   \   000046   EE           MOV     A,R6
   \   000047   FC           MOV     R4,A
   \   000048   EF           MOV     A,R7
   \   000049   FD           MOV     R5,A
   \   00004A   AA..         MOV     R2,?V0 + 0
   \   00004C   AB..         MOV     R3,?V0 + 1
   \   00004E   12....       LCALL   ??ZDSecMgrCtrlAdd?relay
   1114            }
   1115          
   1116            return status;
   \                     ??ZDSecMgrCtrlReset_2:
   \   000051   02....       LJMP    ?Subroutine0 & 0xFFFF
   1117          }
   1118          
   1119          /******************************************************************************
   1120           * @fn          ZDSecMgrMasterKeyLoad
   1121           *
   1122           * @brief       Load the MASTER key for device with specified EXT
   1123           *              address.
   1124           *
   1125           * @param       extAddr - [in] EXT address of device
   1126           * @param       key     - [in] MASTER key shared with device
   1127           *
   1128           * @return      ZStatus_t
   1129           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1130          ZStatus_t ZDSecMgrMasterKeyLoad( uint8* extAddr, uint8* key )
   \                     ZDSecMgrMasterKeyLoad:
   1131          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV     A,#-0x4
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8C..         MOV     ?V0 + 0,R4
   \   00000C   8D..         MOV     ?V0 + 1,R5
   1132            ZStatus_t status;
   1133            uint16 ami;
   1134            uint16 keyNvId;
   1135          
   1136          
   1137            // set status based on policy
   1138            status = ZDSecMgrExtAddrLookup( extAddr, &ami );
   \   00000E                ; Setup parameters for call to function ZDSecMgrExtAddrLookup
   \   00000E   85..82       MOV     DPL,?XSP + 0
   \   000011   85..83       MOV     DPH,?XSP + 1
   \   000014   AC82         MOV     R4,DPL
   \   000016   AD83         MOV     R5,DPH
   \   000018   12....       LCALL   ??ZDSecMgrExtAddrLookup?relay
   \   00001B   E9           MOV     A,R1
   \   00001C   FE           MOV     R6,A
   1139          
   1140            if ( status == ZSuccess )
   \   00001D   7037         JNZ     ??ZDSecMgrMasterKeyLoad_0
   1141            {
   1142              // get the address NV ID
   1143              if ( ZDSecMgrMasterKeyLookup( ami, &keyNvId ) == ZSuccess )
   \   00001F                ; Setup parameters for call to function ZDSecMgrMasterKeyLookup
   \   00001F   7402         MOV     A,#0x2
   \   000021   12....       LCALL   ?XSTACK_DISP0_8
   \   000024   12....       LCALL   ?Subroutine48 & 0xFFFF
   \                     ??CrossCallReturnLabel_221:
   \   000027   7024         JNZ     ??ZDSecMgrMasterKeyLoad_1
   1144              {
   1145                // overwrite old key in NV
   1146                osal_nv_write( keyNvId, osal_offsetof(ZDSecMgrMasterKeyData_t, key), 
   1147                               SEC_KEY_LEN, key );
   \   000029                ; Setup parameters for call to function osal_nv_write
   \   000029   78..         MOV     R0,#?V0 + 0
   \   00002B   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00002E   75..10       MOV     ?V0 + 0,#0x10
   \   000031   75..00       MOV     ?V0 + 1,#0x0
   \   000034   78..         MOV     R0,#?V0 + 0
   \   000036   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000039   7C02         MOV     R4,#0x2
   \   00003B   7D00         MOV     R5,#0x0
   \   00003D   7406         MOV     A,#0x6
   \   00003F   12....       LCALL   ?XSTACK_DISP0_8
   \   000042   12....       LCALL   ??Subroutine117_0 & 0xFFFF
   1148              }
   \                     ??CrossCallReturnLabel_308:
   \   000045   12....       LCALL   ??Subroutine109_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_175:
   \   000048   12....       LCALL   ?DEALLOC_XSTACK8
   \   00004B   8009         SJMP    ??ZDSecMgrMasterKeyLoad_0
   1149              else
   1150              {
   1151                // store new key -- NULL will zero key
   1152                status = ZDSecMgrMasterKeyStore( ami, key );
   \                     ??ZDSecMgrMasterKeyLoad_1:
   \   00004D                ; Setup parameters for call to function ZDSecMgrMasterKeyStore
   \   00004D   AC..         MOV     R4,?V0 + 0
   \   00004F   AD..         MOV     R5,?V0 + 1
   \   000051   12....       LCALL   ?Subroutine68 & 0xFFFF
   1153              }
   1154            }
   \                     ??CrossCallReturnLabel_101:
   \   000054   E9           MOV     A,R1
   \   000055   FE           MOV     R6,A
   1155          
   1156            return status;
   \                     ??ZDSecMgrMasterKeyLoad_0:
   \   000056   EE           MOV     A,R6
   \   000057   F9           MOV     R1,A
   \   000058   7404         MOV     A,#0x4
   \   00005A   02....       LJMP    ??Subroutine118_0 & 0xFFFF
   1157          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine48:
   \   000000   AC82         MOV     R4,DPL
   \   000002   AD83         MOV     R5,DPH
   \   000004   85..82       MOV     DPL,?XSP + 0
   \   000007   85..83       MOV     DPH,?XSP + 1
   \   00000A                REQUIRE ??Subroutine120_0
   \   00000A                ; // Fall through to label ??Subroutine120_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine120_0:
   \   000000   12....       LCALL   ??Subroutine142_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_306:
   \   000003   12....       LCALL   ??ZDSecMgrMasterKeyLookup?relay
   \   000006   E9           MOV     A,R1
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine68:
   \   000000   12....       LCALL   ?Subroutine91 & 0xFFFF
   \                     ??CrossCallReturnLabel_304:
   \   000003   12....       LCALL   ??ZDSecMgrMasterKeyStore?relay
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine91:
   \   000000   85..82       MOV     DPL,?XSP + 0
   \   000003   85..83       MOV     DPH,?XSP + 1
   \   000006                REQUIRE ??Subroutine142_0
   \   000006                ; // Fall through to label ??Subroutine142_0
   1158          
   1159          /******************************************************************************
   1160           * @fn          ZDSecMgrAppKeyGet
   1161           *
   1162           * @brief       get an APP key - option APP(MASTER or LINK) key
   1163           *
   1164           * @param       initNwkAddr - [in] NWK address of initiator device
   1165           * @param       initExtAddr - [in] EXT address of initiator device
   1166           * @param       partNwkAddr - [in] NWK address of partner device
   1167           * @param       partExtAddr - [in] EXT address of partner device
   1168           * @param       key         - [out] APP(MASTER or LINK) key
   1169           * @param       keyType     - [out] APP(MASTER or LINK) key type
   1170           *
   1171           * @return      ZStatus_t
   1172           */

   \                                 In  segment XDATA_I, align 1, keep-with-next
   1173          uint8 ZDSecMgrAppKeyType = KEY_TYPE_APP_LINK;    // Set the default key type
   \                     ZDSecMgrAppKeyType:
   \   000000                DS 1
   \   000001                REQUIRE `?<Initializer for ZDSecMgrAppKeyType>`
   \   000001                REQUIRE __INIT_XDATA_I
   1174                                                           // to KEY_TYPE_APP_LINK since
   1175                                                           // only specific requirement
   1176                                                           // right now comes from SE profile
   1177          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1178          ZStatus_t ZDSecMgrAppKeyGet( uint16  initNwkAddr,
   \                     ZDSecMgrAppKeyGet:
   1179                                       uint8*  initExtAddr,
   1180                                       uint16  partNwkAddr,
   1181                                       uint8*  partExtAddr,
   1182                                       uint8** key,
   1183                                       uint8*  keyType )
   1184          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   740D         MOV     A,#0xd
   \   000007   12....       LCALL   ?XSTACK_DISP0_8
   \   00000A   12....       LCALL   ?Subroutine66 & 0xFFFF
   \                     ??CrossCallReturnLabel_98:
   \   00000D   FA           MOV     R2,A
   \   00000E   E9           MOV     A,R1
   \   00000F   FB           MOV     R3,A
   \   000010   740F         MOV     A,#0xf
   \   000012   12....       LCALL   ?XSTACK_DISP0_8
   \   000015   12....       LCALL   ?Subroutine66 & 0xFFFF
   \                     ??CrossCallReturnLabel_99:
   \   000018   FE           MOV     R6,A
   \   000019   E9           MOV     A,R1
   \   00001A   FF           MOV     R7,A
   1185            // Intentionally unreferenced parameters
   1186            (void)initNwkAddr;
   1187            (void)initExtAddr;
   1188            (void)partNwkAddr;
   1189            (void)partExtAddr;
   1190            
   1191            //---------------------------------------------------------------------------
   1192            // note:
   1193            // should use a robust mechanism to generate keys, for example
   1194            // combine EXT addresses and call a hash function
   1195            //---------------------------------------------------------------------------
   1196            SSP_GetTrueRand( SEC_KEY_LEN, *key );
   \   00001B                ; Setup parameters for call to function SSP_GetTrueRand
   \   00001B   8A82         MOV     DPL,R2
   \   00001D   8B83         MOV     DPH,R3
   \   00001F   12....       LCALL   ??Subroutine123_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_231:
   \   000022   7910         MOV     R1,#0x10
   \   000024   12....       LCALL   ??SSP_GetTrueRand?relay
   1197          
   1198            *keyType = ZDSecMgrAppKeyType;
   \   000027   90....       MOV     DPTR,#ZDSecMgrAppKeyType
   \   00002A   E0           MOVX    A,@DPTR
   \   00002B   8E82         MOV     DPL,R6
   \   00002D   8F83         MOV     DPH,R7
   \   00002F   F0           MOVX    @DPTR,A
   1199          
   1200            return ZSuccess;
   \   000030   7900         MOV     R1,#0x0
   \   000032   02....       LJMP    ??Subroutine133_0 & 0xFFFF
   1201          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine66:
   \   000000   12....       LCALL   ?Subroutine94 & 0xFFFF
   \                     ??CrossCallReturnLabel_324:
   \   000003   E8           MOV     A,R0
   \   000004   22           RET
   1202          
   1203          /******************************************************************************
   1204           * @fn          ZDSecMgrAppKeyReq
   1205           *
   1206           * @brief       Process request for APP key between two devices.
   1207           *
   1208           * @param       device - [in] ZDO_RequestKeyInd_t, request info
   1209           *
   1210           * @return      none
   1211           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1212          void ZDSecMgrAppKeyReq( ZDO_RequestKeyInd_t* ind )
   \                     ZDSecMgrAppKeyReq:
   1213          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 39
   \   000005   74D9         MOV     A,#-0x27
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   1214            APSME_TransportKeyReq_t req;
   1215            uint8                   initExtAddr[Z_EXTADDR_LEN];
   1216            uint16                  partNwkAddr;
   1217            uint8                   key[SEC_KEY_LEN];
   1218          
   1219          
   1220            // validate initiator and partner
   1221            if ( ( APSME_LookupNwkAddr( ind->partExtAddr, &partNwkAddr ) == TRUE ) &&
   1222                 ( APSME_LookupExtAddr( ind->srcAddr, initExtAddr ) == TRUE      )   )
   \   00000E                ; Setup parameters for call to function APSME_LookupNwkAddr
   \   00000E   85..82       MOV     DPL,?XSP + 0
   \   000011   85..83       MOV     DPH,?XSP + 1
   \   000014   AC82         MOV     R4,DPL
   \   000016   AD83         MOV     R5,DPH
   \   000018   EE           MOV     A,R6
   \   000019   2405         ADD     A,#0x5
   \   00001B   12....       LCALL   ?Subroutine46 & 0xFFFF
   \                     ??CrossCallReturnLabel_64:
   \   00001E   6003         JZ      $+5
   \   000020   02....       LJMP    ??ZDSecMgrAppKeyReq_0 & 0xFFFF
   \   000023                ; Setup parameters for call to function APSME_LookupExtAddr
   \   000023   740F         MOV     A,#0xf
   \   000025   12....       LCALL   ?XSTACK_DISP0_8
   \   000028   12....       LCALL   ?Subroutine71 & 0xFFFF
   \                     ??CrossCallReturnLabel_238:
   \   00002B   12....       LCALL   ??APSME_LookupExtAddr?relay
   \   00002E   E9           MOV     A,R1
   \   00002F   6401         XRL     A,#0x1
   \   000031   6003         JZ      $+5
   \   000033   02....       LJMP    ??ZDSecMgrAppKeyReq_0 & 0xFFFF
   1223            {
   1224              // point the key to some memory
   1225              req.key = key;
   \   000036   7417         MOV     A,#0x17
   \   000038   12....       LCALL   ?XSTACK_DISP0_8
   \   00003B   A882         MOV     R0,DPL
   \   00003D   A983         MOV     R1,DPH
   \   00003F   7406         MOV     A,#0x6
   \   000041   12....       LCALL   ?XSTACK_DISP0_8
   \   000044   12....       LCALL   ??Subroutine113_0 & 0xFFFF
   1226          
   1227              // get an APP key - option APP (MASTER or LINK) key
   1228              if ( ZDSecMgrAppKeyGet( ind->srcAddr,
   1229                                      initExtAddr,
   1230                                      partNwkAddr,
   1231                                      ind->partExtAddr,
   1232                                      &req.key,
   1233                                      &req.keyType ) == ZSuccess )
   \                     ??CrossCallReturnLabel_191:
   \   000047                ; Setup parameters for call to function SSP_GetTrueRand
   \   000047   7417         MOV     A,#0x17
   \   000049   12....       LCALL   ?XSTACK_DISP0_8
   \   00004C   AA82         MOV     R2,DPL
   \   00004E   AB83         MOV     R3,DPH
   \   000050   7910         MOV     R1,#0x10
   \   000052   12....       LCALL   ??SSP_GetTrueRand?relay
   \   000055   90....       MOV     DPTR,#ZDSecMgrAppKeyType
   \   000058   E0           MOVX    A,@DPTR
   \   000059   C0E0         PUSH    A
   \   00005B   7404         MOV     A,#0x4
   \   00005D   12....       LCALL   ?XSTACK_DISP0_8
   \   000060   D0E0         POP     A
   \   000062   F0           MOVX    @DPTR,A
   1234              {
   1235                // always secure
   1236                req.nwkSecure = TRUE;
   \   000063   740C         MOV     A,#0xc
   \   000065   12....       LCALL   ?XSTACK_DISP0_8
   \   000068   7401         MOV     A,#0x1
   \   00006A   F0           MOVX    @DPTR,A
   1237                req.apsSecure = TRUE;
   \   00006B   740B         MOV     A,#0xb
   \   00006D   12....       LCALL   ?XSTACK_DISP0_8
   \   000070   7401         MOV     A,#0x1
   \   000072   F0           MOVX    @DPTR,A
   1238                req.tunnel    = NULL;
   \   000073   740D         MOV     A,#0xd
   \   000075   12....       LCALL   ?XSTACK_DISP0_8
   \   000078   12....       LCALL   ?Subroutine21 & 0xFFFF
   1239          
   1240                // send key to initiator device
   1241                req.dstAddr   = ind->srcAddr;
   \                     ??CrossCallReturnLabel_16:
   \   00007B   7402         MOV     A,#0x2
   \   00007D   12....       LCALL   ?XSTACK_DISP0_8
   \   000080   12....       LCALL   ??Subroutine113_0 & 0xFFFF
   1242                req.extAddr   = ind->partExtAddr;
   \                     ??CrossCallReturnLabel_192:
   \   000083   EE           MOV     A,R6
   \   000084   2405         ADD     A,#0x5
   \   000086   F8           MOV     R0,A
   \   000087   EF           MOV     A,R7
   \   000088   3400         ADDC    A,#0x0
   \   00008A   F9           MOV     R1,A
   \   00008B   7408         MOV     A,#0x8
   \   00008D   12....       LCALL   ?XSTACK_DISP0_8
   \   000090   12....       LCALL   ?Subroutine19 & 0xFFFF
   1243                req.initiator = TRUE;
   \                     ??CrossCallReturnLabel_9:
   \   000093   12....       LCALL   ?XSTACK_DISP0_8
   \   000096   7401         MOV     A,#0x1
   \   000098   F0           MOVX    @DPTR,A
   1244                APSME_TransportKeyReq( &req );
   \   000099                ; Setup parameters for call to function APSME_TransportKeyReq
   \   000099   7402         MOV     A,#0x2
   \   00009B   12....       LCALL   ?XSTACK_DISP0_8
   \   00009E   AA82         MOV     R2,DPL
   \   0000A0   AB83         MOV     R3,DPH
   \   0000A2   12....       LCALL   ??APSME_TransportKeyReq?relay
   1245          
   1246                // send key to partner device
   1247                req.dstAddr   = partNwkAddr;
   \   0000A5   85..82       MOV     DPL,?XSP + 0
   \   0000A8   85..83       MOV     DPH,?XSP + 1
   \   0000AB   12....       LCALL   ??Subroutine124_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_240:
   \   0000AE   12....       LCALL   ?XSTACK_DISP0_8
   \   0000B1   12....       LCALL   ??Subroutine113_0 & 0xFFFF
   1248                req.extAddr   = initExtAddr;
   \                     ??CrossCallReturnLabel_193:
   \   0000B4   740F         MOV     A,#0xf
   \   0000B6   12....       LCALL   ?XSTACK_DISP0_8
   \   0000B9   A882         MOV     R0,DPL
   \   0000BB   A983         MOV     R1,DPH
   \   0000BD   7408         MOV     A,#0x8
   \   0000BF   12....       LCALL   ?XSTACK_DISP0_8
   \   0000C2   12....       LCALL   ?Subroutine19 & 0xFFFF
   1249                req.initiator = FALSE;
   \                     ??CrossCallReturnLabel_10:
   \   0000C5   12....       LCALL   ?XSTACK_DISP0_8
   \   0000C8   E4           CLR     A
   \   0000C9   F0           MOVX    @DPTR,A
   1250          
   1251                APSME_TransportKeyReq( &req );
   \   0000CA                ; Setup parameters for call to function APSME_TransportKeyReq
   \   0000CA   7402         MOV     A,#0x2
   \   0000CC   12....       LCALL   ?XSTACK_DISP0_8
   \   0000CF   AA82         MOV     R2,DPL
   \   0000D1   AB83         MOV     R3,DPH
   \   0000D3   12....       LCALL   ??APSME_TransportKeyReq?relay
   1252                
   1253                // clear copy of key in RAM
   1254                osal_memset( key, 0x00, SEC_KEY_LEN);
   \   0000D6                ; Setup parameters for call to function osal_memset
   \   0000D6   7C10         MOV     R4,#0x10
   \   0000D8   7D00         MOV     R5,#0x0
   \   0000DA   7900         MOV     R1,#0x0
   \   0000DC   7417         MOV     A,#0x17
   \   0000DE   12....       LCALL   ?XSTACK_DISP0_8
   \   0000E1   AA82         MOV     R2,DPL
   \   0000E3   AB83         MOV     R3,DPH
   \   0000E5   12....       LCALL   ??osal_memset?relay
   1255          
   1256              }
   1257            }
   1258          }
   \                     ??ZDSecMgrAppKeyReq_0:
   \   0000E8   7427         MOV     A,#0x27
   \   0000EA   02....       LJMP    ??Subroutine132_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine71:
   \   000000   AC82         MOV     R4,DPL
   \   000002   AD83         MOV     R5,DPH
   \   000004   8E82         MOV     DPL,R6
   \   000006   8F83         MOV     DPH,R7
   \   000008                REQUIRE ??Subroutine122_0
   \   000008                ; // Fall through to label ??Subroutine122_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine122_0:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002                REQUIRE ??Subroutine123_0
   \   000002                ; // Fall through to label ??Subroutine123_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine124_0:
   \   000000   12....       LCALL   ?Subroutine94 & 0xFFFF
   \                     ??CrossCallReturnLabel_325:
   \   000003   7402         MOV     A,#0x2
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine19:
   \   000000   12....       LCALL   ?Subroutine87 & 0xFFFF
   \                     ??CrossCallReturnLabel_249:
   \   000003                ; Setup parameters for call to function AddrMgrEntryGet
   \   000003                ; Setup parameters for call to function AddrMgrEntryGet
   \   000003   740A         MOV     A,#0xa
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine21:
   \   000000   E4           CLR     A
   \   000001   F0           MOVX    @DPTR,A
   \   000002   A3           INC     DPTR
   \   000003   12....       LCALL   ?Subroutine84 & 0xFFFF
   \                     ??CrossCallReturnLabel_131:
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine84:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   8E82         MOV     DPL,R6
   \   000003   8F83         MOV     DPH,R7
   \   000005   A3           INC     DPTR
   \   000006   A3           INC     DPTR
   \   000007   E0           MOVX    A,@DPTR
   \   000008   F8           MOV     R0,A
   \   000009   A3           INC     DPTR
   \   00000A   E0           MOVX    A,@DPTR
   \   00000B   F9           MOV     R1,A
   \   00000C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine46:
   \   000000   FA           MOV     R2,A
   \   000001   EF           MOV     A,R7
   \   000002   3400         ADDC    A,#0x0
   \   000004   FB           MOV     R3,A
   \   000005   12....       LCALL   ??APSME_LookupNwkAddr?relay
   \   000008   E9           MOV     A,R1
   \   000009   6401         XRL     A,#0x1
   \   00000B   22           RET
   1259          
   1260          /******************************************************************************
   1261           * @fn          ZDSecMgrEstablishKey
   1262           *
   1263           * @brief       Start SKKE with device joining network.
   1264           *
   1265           * @param       device - [in] ZDSecMgrDevice_t, device info
   1266           *
   1267           * @return      ZStatus_t
   1268           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1269          ZStatus_t ZDSecMgrEstablishKey( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrEstablishKey:
   1270          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 7
   \   000005   74F9         MOV     A,#-0x7
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   1271            ZStatus_t               status;
   1272            APSME_EstablishKeyReq_t req;
   1273          
   1274          
   1275            req.respExtAddr = device->extAddr;
   \   00000E   8E82         MOV     DPL,R6
   \   000010   8F83         MOV     DPH,R7
   \   000012   12....       LCALL   ?Subroutine51 & 0xFFFF
   \                     ??CrossCallReturnLabel_243:
   \   000015   12....       LCALL   ?XSTACK_DISP0_8
   \   000018   12....       LCALL   ??Subroutine113_0 & 0xFFFF
   1276            req.method      = APSME_SKKE_METHOD;
   \                     ??CrossCallReturnLabel_194:
   \   00001B   7404         MOV     A,#0x4
   \   00001D   12....       LCALL   ?XSTACK_DISP0_8
   \   000020   E4           CLR     A
   \   000021   12....       LCALL   ??Subroutine114_0 & 0xFFFF
   1277          
   1278            if ( device->parentAddr == NLME_GetShortAddr() )
   \                     ??CrossCallReturnLabel_209:
   \   000024   7003         JNZ     ??ZDSecMgrEstablishKey_0
   \   000026   A3           INC     DPTR
   \   000027   E0           MOVX    A,@DPTR
   \   000028   69           XRL     A,R1
   \                     ??ZDSecMgrEstablishKey_0:
   \   000029   8E82         MOV     DPL,R6
   \   00002B   8F83         MOV     DPH,R7
   \   00002D   7010         JNZ     ??ZDSecMgrEstablishKey_1
   1279            {
   1280              req.dstAddr   = device->nwkAddr;
   \   00002F   12....       LCALL   ?Subroutine31 & 0xFFFF
   1281              //devtag.0604.todo - remove obsolete
   1282              req.apsSecure = FALSE;
   \                     ??CrossCallReturnLabel_185:
   \   000032   12....       LCALL   ?XSTACK_DISP0_8
   \   000035   E4           CLR     A
   \   000036   F0           MOVX    @DPTR,A
   1283              req.nwkSecure = FALSE;
   \   000037   7406         MOV     A,#0x6
   \   000039   12....       LCALL   ?XSTACK_DISP0_8
   \   00003C   E4           CLR     A
   \   00003D   8014         SJMP    ??ZDSecMgrEstablishKey_2
   1284            }
   1285            else
   1286            {
   1287              req.dstAddr   = device->parentAddr;
   \                     ??ZDSecMgrEstablishKey_1:
   \   00003F   A3           INC     DPTR
   \   000040   A3           INC     DPTR
   \   000041   A3           INC     DPTR
   \   000042   A3           INC     DPTR
   \   000043   12....       LCALL   ?Subroutine31 & 0xFFFF
   1288              //devtag.0604.todo - remove obsolete
   1289              req.apsSecure = TRUE;
   \                     ??CrossCallReturnLabel_186:
   \   000046   12....       LCALL   ?XSTACK_DISP0_8
   \   000049   7401         MOV     A,#0x1
   \   00004B   F0           MOVX    @DPTR,A
   1290              req.nwkSecure = TRUE;
   \   00004C   7406         MOV     A,#0x6
   \   00004E   12....       LCALL   ?XSTACK_DISP0_8
   \   000051   7401         MOV     A,#0x1
   1291            }
   \                     ??ZDSecMgrEstablishKey_2:
   \   000053   12....       LCALL   ??Subroutine127_0 & 0xFFFF
   1292          
   1293            status = APSME_EstablishKeyReq( &req );
   1294          
   1295            return status;
   \                     ??CrossCallReturnLabel_257:
   \   000056   12....       LCALL   ??APSME_EstablishKeyReq?relay
   \   000059   7407         MOV     A,#0x7
   \   00005B   02....       LJMP    ??Subroutine118_0 & 0xFFFF
   1296          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine31:
   \   000000   12....       LCALL   ?Subroutine90 & 0xFFFF
   \                     ??CrossCallReturnLabel_138:
   \   000003                REQUIRE ??Subroutine112_0
   \   000003                ; // Fall through to label ??Subroutine112_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine112_0:
   \   000000   12....       LCALL   ?Subroutine87 & 0xFFFF
   \                     ??CrossCallReturnLabel_252:
   \   000003                ; Setup parameters for call to function APSME_RemoveDeviceReq
   \   000003   7405         MOV     A,#0x5
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine114_0:
   \   000000   F0           MOVX    @DPTR,A
   \   000001                ; Setup parameters for call to function NLME_GetShortAddr
   \   000001                ; Setup parameters for call to function NLME_GetShortAddr
   \   000001                ; Setup parameters for call to function NLME_GetShortAddr
   \   000001                ; Setup parameters for call to function NLME_GetShortAddr
   \   000001   12....       LCALL   ?Subroutine100 & 0xFFFF
   \                     ??CrossCallReturnLabel_211:
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine100:
   \   000000   12....       LCALL   ??NLME_GetShortAddr?relay
   \   000003   8A..         MOV     ?V0 + 0,R2
   \   000005   8B..         MOV     ?V0 + 1,R3
   \   000007   A8..         MOV     R0,?V0 + 0
   \   000009   A9..         MOV     R1,?V0 + 1
   \   00000B   8E82         MOV     DPL,R6
   \   00000D   8F83         MOV     DPH,R7
   \   00000F   A3           INC     DPTR
   \   000010   A3           INC     DPTR
   \   000011   A3           INC     DPTR
   \   000012   A3           INC     DPTR
   \   000013   E0           MOVX    A,@DPTR
   \   000014   68           XRL     A,R0
   \   000015   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine51:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002                REQUIRE ??Subroutine124_0
   \   000002                ; // Fall through to label ??Subroutine124_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine90:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F9           MOV     R1,A
   \   000005   85..82       MOV     DPL,?XSP + 0
   \   000008   85..83       MOV     DPH,?XSP + 1
   \   00000B   22           RET
   1297          
   1298          /******************************************************************************
   1299           * @fn          ZDSecMgrSendMasterKey
   1300           *
   1301           * @brief       Send MASTER key to device joining network.
   1302           *
   1303           * @param       device - [in] ZDSecMgrDevice_t, device info
   1304           *
   1305           * @return      ZStatus_t
   1306           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1307          ZStatus_t ZDSecMgrSendMasterKey( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrSendMasterKey:
   1308          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 31
   \   000005   74E1         MOV     A,#-0x1f
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   1309            ZStatus_t status;
   1310            APSME_TransportKeyReq_t req;
   1311            uint16 keyNvId;
   1312            uint8 masterKey[SEC_KEY_LEN];
   1313          
   1314          
   1315            req.keyType = KEY_TYPE_TC_MASTER;
   \   00000E   7404         MOV     A,#0x4
   \   000010   12....       LCALL   ?XSTACK_DISP0_8
   \   000013   E4           CLR     A
   \   000014   12....       LCALL   ?Subroutine22 & 0xFFFF
   1316            req.extAddr = device->extAddr;
   \                     ??CrossCallReturnLabel_18:
   \   000017   12....       LCALL   ?XSTACK_DISP0_8
   \   00001A   12....       LCALL   ??Subroutine126_0 & 0xFFFF
   1317            req.tunnel  = NULL;
   \                     ??CrossCallReturnLabel_247:
   \   00001D   12....       LCALL   ?XSTACK_DISP0_8
   \   000020   12....       LCALL   ?Subroutine23 & 0xFFFF
   1318          
   1319            if ( ZDSecMgrMasterKeyLookup( device->ctrl->entry->ami, &keyNvId ) == ZSuccess )
   \                     ??CrossCallReturnLabel_20:
   \   000023   8E82         MOV     DPL,R6
   \   000025   8F83         MOV     DPH,R7
   \   000027   A3           INC     DPTR
   \   000028   A3           INC     DPTR
   \   000029   A3           INC     DPTR
   \   00002A   A3           INC     DPTR
   \   00002B   A3           INC     DPTR
   \   00002C   A3           INC     DPTR
   \   00002D   A3           INC     DPTR
   \   00002E   A3           INC     DPTR
   \   00002F   12....       LCALL   ?Subroutine72 & 0xFFFF
   \                     ??CrossCallReturnLabel_107:
   \   000032   12....       LCALL   ??Subroutine130_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_294:
   \   000035   12....       LCALL   ??Subroutine120_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_224:
   \   000038   702C         JNZ     ??ZDSecMgrSendMasterKey_0
   1320            {
   1321              osal_nv_read( keyNvId, osal_offsetof(ZDSecMgrMasterKeyData_t, key), 
   1322                            SEC_KEY_LEN, masterKey );
   \   00003A                ; Setup parameters for call to function osal_nv_read
   \   00003A   740F         MOV     A,#0xf
   \   00003C   12....       LCALL   ?XSTACK_DISP0_8
   \   00003F   8582..       MOV     ?V0 + 0,DPL
   \   000042   8583..       MOV     ?V0 + 1,DPH
   \   000045   78..         MOV     R0,#?V0 + 0
   \   000047   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00004A   75..10       MOV     ?V0 + 0,#0x10
   \   00004D   75..00       MOV     ?V0 + 1,#0x0
   \   000050   78..         MOV     R0,#?V0 + 0
   \   000052   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000055   7C02         MOV     R4,#0x2
   \   000057   7D00         MOV     R5,#0x0
   \   000059   7404         MOV     A,#0x4
   \   00005B   12....       LCALL   ?XSTACK_DISP0_8
   \   00005E   12....       LCALL   ?Subroutine52 & 0xFFFF
   1323            }
   \                     ??CrossCallReturnLabel_73:
   \   000061   12....       LCALL   ?DEALLOC_XSTACK8
   \   000064   8012         SJMP    ??ZDSecMgrSendMasterKey_1
   1324            else
   1325            {
   1326              // in case read from NV fails
   1327              osal_memset( masterKey, 0x00, SEC_KEY_LEN);
   \                     ??ZDSecMgrSendMasterKey_0:
   \   000066                ; Setup parameters for call to function osal_memset
   \   000066   7C10         MOV     R4,#0x10
   \   000068   7D00         MOV     R5,#0x0
   \   00006A   7900         MOV     R1,#0x0
   \   00006C   740F         MOV     A,#0xf
   \   00006E   12....       LCALL   ?XSTACK_DISP0_8
   \   000071   AA82         MOV     R2,DPL
   \   000073   AB83         MOV     R3,DPH
   \   000075   12....       LCALL   ??osal_memset?relay
   1328            }
   1329          
   1330            req.key = masterKey;
   \                     ??ZDSecMgrSendMasterKey_1:
   \   000078   740F         MOV     A,#0xf
   \   00007A   12....       LCALL   ?XSTACK_DISP0_8
   \   00007D   A882         MOV     R0,DPL
   \   00007F   A983         MOV     R1,DPH
   \   000081   7406         MOV     A,#0x6
   \   000083   12....       LCALL   ?XSTACK_DISP0_8
   \   000086   12....       LCALL   ?Subroutine11 & 0xFFFF
   1331          
   1332            //check if using secure hop to to parent
   1333            if ( device->parentAddr != NLME_GetShortAddr() )
   \                     ??CrossCallReturnLabel_207:
   \   000089   7003         JNZ     ??ZDSecMgrSendMasterKey_2
   \   00008B   A3           INC     DPTR
   \   00008C   E0           MOVX    A,@DPTR
   \   00008D   69           XRL     A,R1
   \                     ??ZDSecMgrSendMasterKey_2:
   \   00008E   8E82         MOV     DPL,R6
   \   000090   8F83         MOV     DPH,R7
   \   000092   601C         JZ      ??ZDSecMgrSendMasterKey_3
   1334            {
   1335              //send to parent with security
   1336              req.dstAddr   = device->parentAddr;
   \   000094   A3           INC     DPTR
   \   000095   A3           INC     DPTR
   \   000096   12....       LCALL   ?Subroutine51 & 0xFFFF
   \                     ??CrossCallReturnLabel_244:
   \   000099   12....       LCALL   ?XSTACK_DISP0_8
   \   00009C   12....       LCALL   ??Subroutine113_0 & 0xFFFF
   1337              req.nwkSecure = TRUE;
   \                     ??CrossCallReturnLabel_195:
   \   00009F   740C         MOV     A,#0xc
   \   0000A1   12....       LCALL   ?XSTACK_DISP0_8
   \   0000A4   7401         MOV     A,#0x1
   \   0000A6   F0           MOVX    @DPTR,A
   1338              req.apsSecure = TRUE;
   \   0000A7   740B         MOV     A,#0xb
   \   0000A9   12....       LCALL   ?XSTACK_DISP0_8
   \   0000AC   7401         MOV     A,#0x1
   \   0000AE   8016         SJMP    ??ZDSecMgrSendMasterKey_4
   1339            }
   1340            else
   1341            {
   1342              //direct with no security
   1343              req.dstAddr   = device->nwkAddr;
   \                     ??ZDSecMgrSendMasterKey_3:
   \   0000B0   12....       LCALL   ??Subroutine124_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_241:
   \   0000B3   12....       LCALL   ?XSTACK_DISP0_8
   \   0000B6   12....       LCALL   ??Subroutine113_0 & 0xFFFF
   1344              req.nwkSecure = FALSE;
   \                     ??CrossCallReturnLabel_196:
   \   0000B9   740C         MOV     A,#0xc
   \   0000BB   12....       LCALL   ?XSTACK_DISP0_8
   \   0000BE   E4           CLR     A
   \   0000BF   F0           MOVX    @DPTR,A
   1345              req.apsSecure = FALSE;
   \   0000C0   740B         MOV     A,#0xb
   \   0000C2   12....       LCALL   ?XSTACK_DISP0_8
   \   0000C5   E4           CLR     A
   \                     ??ZDSecMgrSendMasterKey_4:
   \   0000C6   F0           MOVX    @DPTR,A
   1346            }
   1347          
   1348            status = APSME_TransportKeyReq( &req );
   \   0000C7                ; Setup parameters for call to function APSME_TransportKeyReq
   \   0000C7   7402         MOV     A,#0x2
   \   0000C9   12....       LCALL   ?XSTACK_DISP0_8
   \   0000CC   AA82         MOV     R2,DPL
   \   0000CE   AB83         MOV     R3,DPH
   \   0000D0   12....       LCALL   ??APSME_TransportKeyReq?relay
   \   0000D3   E9           MOV     A,R1
   \   0000D4   FE           MOV     R6,A
   1349          
   1350            // clear copy of key in RAM
   1351            osal_memset( masterKey, 0x00, SEC_KEY_LEN);
   \   0000D5                ; Setup parameters for call to function osal_memset
   \   0000D5   7C10         MOV     R4,#0x10
   \   0000D7   7D00         MOV     R5,#0x0
   \   0000D9   7900         MOV     R1,#0x0
   \   0000DB   740F         MOV     A,#0xf
   \   0000DD   12....       LCALL   ?XSTACK_DISP0_8
   \   0000E0   AA82         MOV     R2,DPL
   \   0000E2   AB83         MOV     R3,DPH
   \   0000E4   12....       LCALL   ??osal_memset?relay
   1352          
   1353            return status;
   \   0000E7   EE           MOV     A,R6
   \   0000E8   F9           MOV     R1,A
   \   0000E9   741F         MOV     A,#0x1f
   \   0000EB   02....       LJMP    ??Subroutine118_0 & 0xFFFF
   1354          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine11:
   \   000000   E8           MOV     A,R0
   \   000001   F0           MOVX    @DPTR,A
   \   000002   A3           INC     DPTR
   \   000003   E9           MOV     A,R1
   \   000004                REQUIRE ??Subroutine114_0
   \   000004                ; // Fall through to label ??Subroutine114_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine72:
   \   000000   12....       LCALL   ?Subroutine95 & 0xFFFF
   \                     ??CrossCallReturnLabel_298:
   \   000003   E0           MOVX    A,@DPTR
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine23:
   \   000000   E4           CLR     A
   \   000001   F0           MOVX    @DPTR,A
   \   000002   A3           INC     DPTR
   \   000003   12....       LCALL   ?Subroutine102 & 0xFFFF
   \                     ??CrossCallReturnLabel_282:
   \   000006   AC82         MOV     R4,DPL
   \   000008   AD83         MOV     R5,DPH
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine126_0:
   \   000000   12....       LCALL   ?Subroutine87 & 0xFFFF
   \                     ??CrossCallReturnLabel_254:
   \   000003   740D         MOV     A,#0xd
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine95:
   \   000000   E0           MOVX    A,@DPTR
   \   000001                REQUIRE ??Subroutine130_0
   \   000001                ; // Fall through to label ??Subroutine130_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine130_0:
   \   000000   F8           MOV     R0,A
   \   000001   A3           INC     DPTR
   \   000002   E0           MOVX    A,@DPTR
   \   000003   F583         MOV     DPH,A
   \   000005   8882         MOV     DPL,R0
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine22:
   \   000000   12....       LCALL   ?Subroutine84 & 0xFFFF
   \                     ??CrossCallReturnLabel_132:
   \   000003   7408         MOV     A,#0x8
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine52:
   \   000000   12....       LCALL   ??Subroutine142_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_301:
   \   000003   12....       LCALL   ??osal_nv_read?relay
   \   000006   7404         MOV     A,#0x4
   \   000008   22           RET
   1355          
   1356          /******************************************************************************
   1357           * @fn          ZDSecMgrSendNwkKey
   1358           *
   1359           * @brief       Send NWK key to device joining network.
   1360           *
   1361           * @param       device - [in] ZDSecMgrDevice_t, device info
   1362           *
   1363           * @return      ZStatus_t
   1364           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1365          ZStatus_t ZDSecMgrSendNwkKey( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrSendNwkKey:
   1366          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 30
   \   000005   74E2         MOV     A,#-0x1e
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   1367            ZStatus_t status;
   1368            APSME_TransportKeyReq_t req;
   1369            APSDE_FrameTunnel_t tunnel;
   1370            nwkKeyDesc tmpKey;
   1371              
   1372            req.dstAddr   = device->nwkAddr;
   \   00000E   8E82         MOV     DPL,R6
   \   000010   8F83         MOV     DPH,R7
   \   000012   12....       LCALL   ?Subroutine62 & 0xFFFF
   \                     ??CrossCallReturnLabel_90:
   \   000015   12....       LCALL   ?Subroutine20 & 0xFFFF
   1373            req.extAddr   = device->extAddr;
   \                     ??CrossCallReturnLabel_14:
   \   000018   7406         MOV     A,#0x6
   \   00001A   12....       LCALL   ?XSTACK_DISP0_8
   \   00001D   12....       LCALL   ??Subroutine113_0 & 0xFFFF
   1374          
   1375            if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   1376              req.keyType   = KEY_TYPE_NWK_HIGH;
   1377            else
   1378              req.keyType   = KEY_TYPE_NWK;
   \                     ??CrossCallReturnLabel_197:
   \   000020   7402         MOV     A,#0x2
   \   000022   12....       LCALL   ?XSTACK_DISP0_8
   \   000025   7401         MOV     A,#0x1
   \   000027   F0           MOVX    @DPTR,A
   1379          
   1380            // get the Active Key into a local variable 
   1381            if( NLME_ReadNwkKeyInfo( 0, sizeof(tmpKey), &tmpKey,
   1382                                     ZCD_NV_NWK_ACTIVE_KEY_INFO ) != SUCCESS )
   \   000028                ; Setup parameters for call to function NLME_ReadNwkKeyInfo
   \   000028   75..3A       MOV     ?V0 + 0,#0x3a
   \   00002B   75..00       MOV     ?V0 + 1,#0x0
   \   00002E   78..         MOV     R0,#?V0 + 0
   \   000030   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000033   740F         MOV     A,#0xf
   \   000035   12....       LCALL   ?XSTACK_DISP0_8
   \   000038   8582..       MOV     ?V0 + 0,DPL
   \   00003B   8583..       MOV     ?V0 + 1,DPH
   \   00003E   78..         MOV     R0,#?V0 + 0
   \   000040   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000043   7C11         MOV     R4,#0x11
   \   000045   7D00         MOV     R5,#0x0
   \   000047   7A00         MOV     R2,#0x0
   \   000049   7B00         MOV     R3,#0x0
   \   00004B   12....       LCALL   ??NLME_ReadNwkKeyInfo?relay
   \   00004E   7404         MOV     A,#0x4
   \   000050   12....       LCALL   ?DEALLOC_XSTACK8
   \   000053   E9           MOV     A,R1
   \   000054   6012         JZ      ??ZDSecMgrSendNwkKey_0
   1383            {
   1384              // set key data to all 0s if NV read fails
   1385              osal_memset(&tmpKey, 0x00, sizeof(tmpKey));
   \   000056                ; Setup parameters for call to function osal_memset
   \   000056   7C11         MOV     R4,#0x11
   \   000058   7D00         MOV     R5,#0x0
   \   00005A   7900         MOV     R1,#0x0
   \   00005C   740D         MOV     A,#0xd
   \   00005E   12....       LCALL   ?XSTACK_DISP0_8
   \   000061   AA82         MOV     R2,DPL
   \   000063   AB83         MOV     R3,DPH
   \   000065   12....       LCALL   ??osal_memset?relay
   1386            }
   1387            
   1388            if ( (ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH)
   1389                || (ZG_CHECK_SECURITY_MODE == ZG_SECURITY_SE_STANDARD) )
   1390            {
   1391              // set values
   1392              req.keySeqNum = tmpKey.keySeqNum;
   1393              req.key       = tmpKey.key;
   1394          
   1395              //devtag.pro.security.todo - make sure that if there is no link key the NWK
   1396              //key isn't used to secure the frame at the APS layer -- since the receiving
   1397              //device may not have a NWK key yet
   1398              req.apsSecure = TRUE;
   1399          
   1400              // check if using secure hop to to parent
   1401              if ( device->parentAddr == NLME_GetShortAddr() )
   1402              {
   1403                req.nwkSecure = FALSE;
   1404                req.tunnel    = NULL;
   1405              }
   1406              else
   1407              {
   1408                req.nwkSecure   = TRUE;
   1409                req.tunnel      = &tunnel;
   1410                req.tunnel->tna = device->parentAddr;
   1411                req.tunnel->dea = device->extAddr;
   1412              }
   1413            }
   1414            else
   1415            {
   1416              // default values
   1417              //devtag.0604.verify
   1418              req.nwkSecure = TRUE;
   \                     ??ZDSecMgrSendNwkKey_0:
   \   000068   740A         MOV     A,#0xa
   \   00006A   12....       LCALL   ?XSTACK_DISP0_8
   \   00006D   7401         MOV     A,#0x1
   \   00006F   F0           MOVX    @DPTR,A
   1419              req.apsSecure = FALSE;
   \   000070   7409         MOV     A,#0x9
   \   000072   12....       LCALL   ?XSTACK_DISP0_8
   \   000075   E4           CLR     A
   \   000076   F0           MOVX    @DPTR,A
   1420              req.tunnel    = NULL;
   \   000077   740B         MOV     A,#0xb
   \   000079   12....       LCALL   ?XSTACK_DISP0_8
   \   00007C   E4           CLR     A
   \   00007D   F0           MOVX    @DPTR,A
   \   00007E   A3           INC     DPTR
   \   00007F   12....       LCALL   ??Subroutine114_0 & 0xFFFF
   1421          
   1422              if ( device->parentAddr != NLME_GetShortAddr() )
   \                     ??CrossCallReturnLabel_210:
   \   000082   7003         JNZ     ??ZDSecMgrSendNwkKey_1
   \   000084   A3           INC     DPTR
   \   000085   E0           MOVX    A,@DPTR
   \   000086   69           XRL     A,R1
   \                     ??ZDSecMgrSendNwkKey_1:
   \   000087   600B         JZ      ??CrossCallReturnLabel_205
   1423              {
   1424                req.dstAddr = device->parentAddr;
   \   000089   8E82         MOV     DPL,R6
   \   00008B   8F83         MOV     DPH,R7
   \   00008D   A3           INC     DPTR
   \   00008E   A3           INC     DPTR
   \   00008F   A3           INC     DPTR
   \   000090   A3           INC     DPTR
   \   000091   12....       LCALL   ?Subroutine33 & 0xFFFF
   1425              }
   1426          
   1427              // special cases
   1428              //devtag.0604.todo - modify to preconfig flag
   1429              if ( device->secure == FALSE )
   \                     ??CrossCallReturnLabel_205:
   \   000094   8E82         MOV     DPL,R6
   \   000096   8F83         MOV     DPH,R7
   \   000098   A3           INC     DPTR
   \   000099   A3           INC     DPTR
   \   00009A   A3           INC     DPTR
   \   00009B   A3           INC     DPTR
   \   00009C   A3           INC     DPTR
   \   00009D   A3           INC     DPTR
   \   00009E   E0           MOVX    A,@DPTR
   \   00009F   702C         JNZ     ??ZDSecMgrSendNwkKey_2
   1430              {
   1431                req.keySeqNum = tmpKey.keySeqNum;
   \   0000A1   740D         MOV     A,#0xd
   \   0000A3   12....       LCALL   ?XSTACK_DISP0_8
   \   0000A6   E0           MOVX    A,@DPTR
   \   0000A7   C0E0         PUSH    A
   \   0000A9   7403         MOV     A,#0x3
   \   0000AB   12....       LCALL   ?XSTACK_DISP0_8
   \   0000AE   D0E0         POP     A
   \   0000B0   F0           MOVX    @DPTR,A
   1432                req.key       = tmpKey.key;
   \   0000B1   740E         MOV     A,#0xe
   \   0000B3   12....       LCALL   ?XSTACK_DISP0_8
   \   0000B6   A882         MOV     R0,DPL
   \   0000B8   A983         MOV     R1,DPH
   \   0000BA   7404         MOV     A,#0x4
   \   0000BC   12....       LCALL   ?XSTACK_DISP0_8
   \   0000BF   12....       LCALL   ?Subroutine11 & 0xFFFF
   1433          
   1434                // check if using secure hop to to parent
   1435                if ( device->parentAddr == NLME_GetShortAddr() )
   \                     ??CrossCallReturnLabel_208:
   \   0000C2   7003         JNZ     ??ZDSecMgrSendNwkKey_3
   \   0000C4   A3           INC     DPTR
   \   0000C5   E0           MOVX    A,@DPTR
   \   0000C6   69           XRL     A,R1
   \                     ??ZDSecMgrSendNwkKey_3:
   \   0000C7   7014         JNZ     ??ZDSecMgrSendNwkKey_4
   1436                {
   1437                  req.nwkSecure = FALSE;
   \   0000C9   740A         MOV     A,#0xa
   \   0000CB   800B         SJMP    ??ZDSecMgrSendNwkKey_5
   1438                }
   1439              }
   1440              else
   1441              {
   1442                req.key       = NULL;
   \                     ??ZDSecMgrSendNwkKey_2:
   \   0000CD   7404         MOV     A,#0x4
   \   0000CF   12....       LCALL   ?XSTACK_DISP0_8
   \   0000D2   E4           CLR     A
   \   0000D3   F0           MOVX    @DPTR,A
   \   0000D4   A3           INC     DPTR
   \   0000D5   F0           MOVX    @DPTR,A
   1443                req.keySeqNum = 0;
   \   0000D6   7403         MOV     A,#0x3
   \                     ??ZDSecMgrSendNwkKey_5:
   \   0000D8   12....       LCALL   ?XSTACK_DISP0_8
   \   0000DB   E4           CLR     A
   \   0000DC   F0           MOVX    @DPTR,A
   1444              }
   1445            }
   1446          
   1447            status = APSME_TransportKeyReq( &req );
   \                     ??ZDSecMgrSendNwkKey_4:
   \   0000DD                ; Setup parameters for call to function APSME_TransportKeyReq
   \   0000DD   85..82       MOV     DPL,?XSP + 0
   \   0000E0   85..83       MOV     DPH,?XSP + 1
   \   0000E3   AA82         MOV     R2,DPL
   \   0000E5   AB83         MOV     R3,DPH
   \   0000E7   12....       LCALL   ??APSME_TransportKeyReq?relay
   \   0000EA   E9           MOV     A,R1
   \   0000EB   FE           MOV     R6,A
   1448          
   1449            // clear copy of key in RAM before return
   1450            osal_memset( &tmpKey, 0x00, sizeof(nwkKeyDesc) );
   \   0000EC                ; Setup parameters for call to function osal_memset
   \   0000EC   7C11         MOV     R4,#0x11
   \   0000EE   7D00         MOV     R5,#0x0
   \   0000F0   7900         MOV     R1,#0x0
   \   0000F2   740D         MOV     A,#0xd
   \   0000F4   12....       LCALL   ?XSTACK_DISP0_8
   \   0000F7   AA82         MOV     R2,DPL
   \   0000F9   AB83         MOV     R3,DPH
   \   0000FB   12....       LCALL   ??osal_memset?relay
   1451          
   1452            return status;
   \   0000FE   EE           MOV     A,R6
   \   0000FF   F9           MOV     R1,A
   \   000100   741E         MOV     A,#0x1e
   \   000102   02....       LJMP    ??Subroutine118_0 & 0xFFFF
   1453          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine33:
   \   000000   12....       LCALL   ?Subroutine90 & 0xFFFF
   \                     ??CrossCallReturnLabel_140:
   \   000003                REQUIRE ??Subroutine113_0
   \   000003                ; // Fall through to label ??Subroutine113_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine20:
   \   000000   E8           MOV     A,R0
   \   000001   F0           MOVX    @DPTR,A
   \   000002   A3           INC     DPTR
   \   000003   E9           MOV     A,R1
   \   000004   12....       LCALL   ?Subroutine84 & 0xFFFF
   \                     ??CrossCallReturnLabel_130:
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine62:
   \   000000   12....       LCALL   ?Subroutine90 & 0xFFFF
   \                     ??CrossCallReturnLabel_141:
   \   000003   22           RET
   1454          
   1455          /******************************************************************************
   1456           * @fn          ZDSecMgrDeviceEntryRemove
   1457           *
   1458           * @brief       Remove device entry.
   1459           *
   1460           * @param       entry - [in] valid entry
   1461           *
   1462           * @return      none
   1463           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1464          void ZDSecMgrDeviceEntryRemove( ZDSecMgrEntry_t* entry )
   \                     ZDSecMgrDeviceEntryRemove:
   1465          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   1466            // terminate device control
   1467            if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   1468            {
   1469              ZDSecMgrCtrlTerm( entry );
   \   000009                ; Setup parameters for call to function ZDSecMgrCtrlTerm
   \   000009   12....       LCALL   ??ZDSecMgrCtrlTerm?relay
   1470            }
   1471          
   1472            // remove device from entry data
   1473            ZDSecMgrEntryFree( entry );
   \   00000C                ; Setup parameters for call to function ZDSecMgrEntryFree
   \   00000C   EE           MOV     A,R6
   \   00000D   FA           MOV     R2,A
   \   00000E   EF           MOV     A,R7
   \   00000F   FB           MOV     R3,A
   \   000010   12....       LCALL   ??ZDSecMgrEntryFree?relay
   1474          
   1475            // remove EXT address
   1476            //ZDSecMgrExtAddrRelease( aiOld );
   1477          }
   \   000013   02....       LJMP    ??Subroutine133_0 & 0xFFFF
   1478          
   1479          /******************************************************************************
   1480           * @fn          ZDSecMgrDeviceRemoveByExtAddr
   1481           *
   1482           * @brief       Remove device entry by its ext address.
   1483           *
   1484           * @param       pAddr - pointer to the extended address
   1485           *
   1486           * @return      ZStatus_t
   1487           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1488          ZStatus_t ZDSecMgrDeviceRemoveByExtAddr( uint8 *pAddr )
   \                     ZDSecMgrDeviceRemoveByExtAddr:
   1489          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   1490            ZDSecMgrEntry_t *pEntry;
   1491            uint8           retValue;
   1492            
   1493            retValue = (uint8)ZDSecMgrEntryLookupExt( pAddr, &pEntry );
   \   00000A                ; Setup parameters for call to function ZDSecMgrEntryLookupExt
   \   00000A   85..82       MOV     DPL,?XSP + 0
   \   00000D   85..83       MOV     DPH,?XSP + 1
   \   000010   AC82         MOV     R4,DPL
   \   000012   AD83         MOV     R5,DPH
   \   000014   12....       LCALL   ??ZDSecMgrEntryLookupExt?relay
   \   000017   E9           MOV     A,R1
   \   000018   FE           MOV     R6,A
   1494            
   1495            if( retValue == ZSuccess )
   \   000019   7003         JNZ     ??CrossCallReturnLabel_103
   1496            {
   1497              ZDSecMgrDeviceEntryRemove( pEntry );
   \   00001B                ; Setup parameters for call to function ZDSecMgrDeviceEntryRemove
   \   00001B   12....       LCALL   ?Subroutine69 & 0xFFFF
   1498            }
   1499            
   1500            return retValue;
   \                     ??CrossCallReturnLabel_103:
   \   00001E   EE           MOV     A,R6
   \   00001F   F9           MOV     R1,A
   \   000020   02....       LJMP    ??Subroutine131_0 & 0xFFFF
   1501          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine69:
   \   000000   12....       LCALL   ?Subroutine91 & 0xFFFF
   \                     ??CrossCallReturnLabel_305:
   \   000003   12....       LCALL   ??ZDSecMgrDeviceEntryRemove?relay
   \   000006   22           RET
   1502          
   1503          /******************************************************************************
   1504           * @fn          ZDSecMgrDeviceEntryAdd
   1505           *
   1506           * @brief       Add entry.
   1507           *
   1508           * @param       device - [in] ZDSecMgrDevice_t, device info
   1509           * @param       ami    - [in] Address Manager index
   1510           *
   1511           * @return      ZStatus_t
   1512           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1513          void ZDSecMgrAddrMgrUpdate( uint16 ami, uint16 nwkAddr )
   \                     ZDSecMgrAddrMgrUpdate:
   1514          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 13
   \   000005   74F3         MOV     A,#-0xd
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EC           MOV     A,R4
   \   00000B   FE           MOV     R6,A
   \   00000C   ED           MOV     A,R5
   \   00000D   FF           MOV     R7,A
   1515            AddrMgrEntry_t entry;
   1516          
   1517            // get the ami data
   1518            entry.user  = ADDRMGR_USER_SECURITY;
   \   00000E   7402         MOV     A,#0x2
   \   000010   85..82       MOV     DPL,?XSP + 0
   \   000013   85..83       MOV     DPH,?XSP + 1
   \   000016   F0           MOVX    @DPTR,A
   1519            entry.index = ami;
   \   000017   740B         MOV     A,#0xb
   \   000019   12....       LCALL   ?XSTACK_DISP0_8
   \   00001C   12....       LCALL   ?Subroutine16 & 0xFFFF
   1520          
   1521            AddrMgrEntryGet( &entry );
   \                     ??CrossCallReturnLabel_256:
   \   00001F   12....       LCALL   ??AddrMgrEntryGet?relay
   1522          
   1523            // check if NWK address is same
   1524            if ( entry.nwkAddr != nwkAddr )
   \   000022   7401         MOV     A,#0x1
   \   000024   12....       LCALL   ?XSTACK_DISP0_8
   \   000027   E0           MOVX    A,@DPTR
   \   000028   6E           XRL     A,R6
   \   000029   7003         JNZ     ??ZDSecMgrAddrMgrUpdate_0
   \   00002B   A3           INC     DPTR
   \   00002C   E0           MOVX    A,@DPTR
   \   00002D   6F           XRL     A,R7
   \                     ??ZDSecMgrAddrMgrUpdate_0:
   \   00002E   600F         JZ      ??ZDSecMgrAddrMgrUpdate_1
   1525            {
   1526              // update NWK address
   1527              entry.nwkAddr = nwkAddr;
   \   000030   7401         MOV     A,#0x1
   \   000032   12....       LCALL   ?XSTACK_DISP0_8
   \   000035   EE           MOV     A,R6
   \   000036   F0           MOVX    @DPTR,A
   \   000037   A3           INC     DPTR
   \   000038   EF           MOV     A,R7
   \   000039   12....       LCALL   ??Subroutine127_0 & 0xFFFF
   1528          
   1529              AddrMgrEntryUpdate( &entry );
   1530            }
   \                     ??CrossCallReturnLabel_258:
   \   00003C   12....       LCALL   ??AddrMgrEntryUpdate?relay
   1531          }
   \                     ??ZDSecMgrAddrMgrUpdate_1:
   \   00003F   02....       LJMP    ?Subroutine8 & 0xFFFF
   1532          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1533          ZStatus_t ZDSecMgrDeviceEntryAdd( ZDSecMgrDevice_t* device, uint16 ami )
   \                     ZDSecMgrDeviceEntryAdd:
   1534          {
   \   000000   74F5         MOV     A,#-0xb
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0 + 0,R2
   \   00000C   8B..         MOV     ?V0 + 1,R3
   \   00000E   EC           MOV     A,R4
   \   00000F   FE           MOV     R6,A
   \   000010   ED           MOV     A,R5
   \   000011   FF           MOV     R7,A
   1535            ZStatus_t        status;
   1536            ZDSecMgrEntry_t* entry;
   1537          
   1538          
   1539            // initialize as unknown until completion
   1540            status = ZNwkUnknownDevice;
   \   000012   75..C8       MOV     ?V0 + 2,#-0x38
   1541          
   1542            device->ctrl = NULL;
   \   000015   8A82         MOV     DPL,R2
   \   000017   8B83         MOV     DPH,R3
   \   000019   A3           INC     DPTR
   \   00001A   A3           INC     DPTR
   \   00001B   A3           INC     DPTR
   \   00001C   A3           INC     DPTR
   \   00001D   A3           INC     DPTR
   \   00001E   A3           INC     DPTR
   \   00001F   A3           INC     DPTR
   \   000020   A3           INC     DPTR
   \   000021   12....       LCALL   ?Subroutine23 & 0xFFFF
   1543          
   1544            // make sure not already registered
   1545            if ( ZDSecMgrEntryLookup( device->nwkAddr, &entry ) == ZSuccess )
   \                     ??CrossCallReturnLabel_21:
   \   000024   8A82         MOV     DPL,R2
   \   000026   8B83         MOV     DPH,R3
   \   000028   12....       LCALL   ??Subroutine123_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_232:
   \   00002B   12....       LCALL   ??ZDSecMgrEntryLookup?relay
   \   00002E   E9           MOV     A,R1
   \   00002F   85..82       MOV     DPL,?XSP + 0
   \   000032   85..83       MOV     DPH,?XSP + 1
   \   000035   7027         JNZ     ??ZDSecMgrDeviceEntryAdd_0
   1546            {
   1547              // verify that address index is same
   1548              if ( entry->ami != ami )
   \   000037   12....       LCALL   ?Subroutine72 & 0xFFFF
   \                     ??CrossCallReturnLabel_108:
   \   00003A   6E           XRL     A,R6
   \   00003B   7003         JNZ     ??ZDSecMgrDeviceEntryAdd_1
   \   00003D   A3           INC     DPTR
   \   00003E   E0           MOVX    A,@DPTR
   \   00003F   6F           XRL     A,R7
   \                     ??ZDSecMgrDeviceEntryAdd_1:
   \   000040   602A         JZ      ??ZDSecMgrDeviceEntryAdd_2
   1549              {
   1550                // remove conflicting entry
   1551                ZDSecMgrDeviceEntryRemove( entry );
   \   000042                ; Setup parameters for call to function ZDSecMgrDeviceEntryRemove
   \   000042   12....       LCALL   ?Subroutine69 & 0xFFFF
   1552          
   1553                if ( ZDSecMgrEntryLookupAMI( ami, &entry ) == ZSuccess )
   \                     ??CrossCallReturnLabel_104:
   \   000045                ; Setup parameters for call to function ZDSecMgrEntryLookupAMI
   \   000045   85..82       MOV     DPL,?XSP + 0
   \   000048   85..83       MOV     DPH,?XSP + 1
   \   00004B   AC82         MOV     R4,DPL
   \   00004D   AD83         MOV     R5,DPH
   \   00004F   EE           MOV     A,R6
   \   000050   FA           MOV     R2,A
   \   000051   EF           MOV     A,R7
   \   000052   FB           MOV     R3,A
   \   000053   12....       LCALL   ??ZDSecMgrEntryLookupAMI?relay
   \   000056   E9           MOV     A,R1
   \   000057   7013         JNZ     ??ZDSecMgrDeviceEntryAdd_2
   1554                {
   1555                  // update NWK address
   1556                  ZDSecMgrAddrMgrUpdate( ami, device->nwkAddr );
   \                     ??ZDSecMgrDeviceEntryAdd_3:
   \   000059                ; Setup parameters for call to function ZDSecMgrAddrMgrUpdate
   \   000059   12....       LCALL   ?Subroutine59 & 0xFFFF
   1557                }
   1558              }
   1559            }
   \                     ??CrossCallReturnLabel_84:
   \   00005C   800E         SJMP    ??ZDSecMgrDeviceEntryAdd_2
   1560            else if ( ZDSecMgrEntryLookupAMI( ami, &entry ) == ZSuccess )
   \                     ??ZDSecMgrDeviceEntryAdd_0:
   \   00005E                ; Setup parameters for call to function ZDSecMgrEntryLookupAMI
   \   00005E   AC82         MOV     R4,DPL
   \   000060   AD83         MOV     R5,DPH
   \   000062   EE           MOV     A,R6
   \   000063   FA           MOV     R2,A
   \   000064   EF           MOV     A,R7
   \   000065   FB           MOV     R3,A
   \   000066   12....       LCALL   ??ZDSecMgrEntryLookupAMI?relay
   \   000069   E9           MOV     A,R1
   \   00006A   60ED         JZ      ??ZDSecMgrDeviceEntryAdd_3
   1561            {
   1562              // update NWK address
   1563              ZDSecMgrAddrMgrUpdate( ami, device->nwkAddr );
   1564            }
   1565          
   1566            // check if a new entry needs to be created
   1567            if ( entry == NULL )
   \                     ??ZDSecMgrDeviceEntryAdd_2:
   \   00006C   85..82       MOV     DPL,?XSP + 0
   \   00006F   85..83       MOV     DPH,?XSP + 1
   \   000072   E0           MOVX    A,@DPTR
   \   000073   7002         JNZ     ??ZDSecMgrDeviceEntryAdd_4
   \   000075   A3           INC     DPTR
   \   000076   E0           MOVX    A,@DPTR
   \                     ??ZDSecMgrDeviceEntryAdd_4:
   \   000077   85..82       MOV     DPL,?XSP + 0
   \   00007A   85..83       MOV     DPH,?XSP + 1
   \   00007D   7029         JNZ     ??ZDSecMgrDeviceEntryAdd_5
   1568            {
   1569              // get new entry
   1570              if ( ZDSecMgrEntryNew( &entry ) == ZSuccess )
   \   00007F                ; Setup parameters for call to function ZDSecMgrEntryNew
   \   00007F   AA82         MOV     R2,DPL
   \   000081   AB83         MOV     R3,DPH
   \   000083   12....       LCALL   ??ZDSecMgrEntryNew?relay
   \   000086   E9           MOV     A,R1
   \   000087   7028         JNZ     ??ZDSecMgrDeviceEntryAdd_6
   1571              {
   1572                // reset entry lkd
   1573          
   1574                // finish setting up entry
   1575                entry->ami = ami;
   \   000089   85..82       MOV     DPL,?XSP + 0
   \   00008C   85..83       MOV     DPH,?XSP + 1
   \   00008F   12....       LCALL   ?Subroutine95 & 0xFFFF
   \                     ??CrossCallReturnLabel_295:
   \   000092   EE           MOV     A,R6
   \   000093   F0           MOVX    @DPTR,A
   \   000094   A3           INC     DPTR
   \   000095   EF           MOV     A,R7
   \   000096   F0           MOVX    @DPTR,A
   1576          
   1577                // update NWK address
   1578                ZDSecMgrAddrMgrUpdate( ami, device->nwkAddr );
   \   000097                ; Setup parameters for call to function ZDSecMgrAddrMgrUpdate
   \   000097   12....       LCALL   ?Subroutine59 & 0xFFFF
   1579          
   1580                // enter new device into device control
   1581                if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   1582                {
   1583                  status = ZDSecMgrCtrlAdd( device, entry );
   \                     ??CrossCallReturnLabel_85:
   \   00009A                ; Setup parameters for call to function ZDSecMgrCtrlAdd
   \   00009A   85..82       MOV     DPL,?XSP + 0
   \   00009D   85..83       MOV     DPH,?XSP + 1
   \   0000A0   12....       LCALL   ?Subroutine64 & 0xFFFF
   1584                }
   1585                else
   1586                {
   1587                  status = ZSuccess;
   1588                }
   1589              }
   1590            }
   \                     ??CrossCallReturnLabel_94:
   \   0000A3   12....       LCALL   ??ZDSecMgrCtrlAdd?relay
   \   0000A6   8006         SJMP    ??ZDSecMgrDeviceEntryAdd_7
   1591            else
   1592            {
   1593              // reset entry lkd
   1594          
   1595              // reset entry in entry control
   1596              if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   1597              {
   1598                status = ZDSecMgrCtrlReset( device, entry );
   \                     ??ZDSecMgrDeviceEntryAdd_5:
   \   0000A8                ; Setup parameters for call to function ZDSecMgrCtrlReset
   \   0000A8   12....       LCALL   ?Subroutine64 & 0xFFFF
   1599              }
   1600              else
   1601              {
   1602                status = ZSuccess;
   1603              }
   1604            }
   \                     ??CrossCallReturnLabel_95:
   \   0000AB   12....       LCALL   ??ZDSecMgrCtrlReset?relay
   \                     ??ZDSecMgrDeviceEntryAdd_7:
   \   0000AE   E9           MOV     A,R1
   \   0000AF   F5..         MOV     ?V0 + 2,A
   1605          
   1606            return status;
   \                     ??ZDSecMgrDeviceEntryAdd_6:
   \   0000B1   A9..         MOV     R1,?V0 + 2
   \   0000B3   7402         MOV     A,#0x2
   \   0000B5                REQUIRE ?Subroutine6
   \   0000B5                ; // Fall through to label ?Subroutine6
   1607          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine6:
   \   000000   12....       LCALL   ?DEALLOC_XSTACK8
   \   000003   7F03         MOV     R7,#0x3
   \   000005   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine64:
   \   000000   12....       LCALL   ?Subroutine103 & 0xFFFF
   \                     ??CrossCallReturnLabel_158:
   \   000003   AA..         MOV     R2,?V0 + 0
   \   000005   AB..         MOV     R3,?V0 + 1
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine59:
   \   000000   85..82       MOV     DPL,?V0 + 0
   \   000003   85..83       MOV     DPH,?V0 + 1
   \   000006   12....       LCALL   ?Subroutine97 & 0xFFFF
   \                     ??CrossCallReturnLabel_146:
   \   000009   12....       LCALL   ??ZDSecMgrAddrMgrUpdate?relay
   \   00000C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine97:
   \   000000   12....       LCALL   ?Subroutine103 & 0xFFFF
   \                     ??CrossCallReturnLabel_159:
   \   000003   EE           MOV     A,R6
   \   000004   FA           MOV     R2,A
   \   000005   EF           MOV     A,R7
   \   000006   FB           MOV     R3,A
   \   000007   22           RET
   1608          
   1609          /******************************************************************************
   1610           * @fn          ZDSecMgrDeviceCtrlHandler
   1611           *
   1612           * @brief       Device control handler.
   1613           *
   1614           * @param       device - [in] ZDSecMgrDevice_t, device info
   1615           *
   1616           * @return      none
   1617           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1618          void ZDSecMgrDeviceCtrlHandler( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceCtrlHandler:
   1619          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   1620            uint8 state;
   1621            uint8 cntr;
   1622          
   1623          
   1624            state = device->ctrl->state;
   \   000009   8E82         MOV     DPL,R6
   \   00000B   8F83         MOV     DPH,R7
   \   00000D   A3           INC     DPTR
   \   00000E   A3           INC     DPTR
   \   00000F   A3           INC     DPTR
   \   000010   A3           INC     DPTR
   \   000011   A3           INC     DPTR
   \   000012   A3           INC     DPTR
   \   000013   A3           INC     DPTR
   \   000014   A3           INC     DPTR
   \   000015   12....       LCALL   ?Subroutine54 & 0xFFFF
   \                     ??CrossCallReturnLabel_78:
   \   000018   F5..         MOV     ?V0 + 0,A
   1625            cntr  = ZDSECMGR_CTRL_BASE_CNTR;
   1626          
   1627            switch ( state )
   \   00001A   12....       LCALL   ?UC_SWITCH_DENSE
   \                     `?<Jumptable for ZDSecMgrDeviceCtrlHandler>_0`:
   \   00001D   02           DB        2
   \   00001E   05           DB        5
   \   00001F   ....         DW        ??ZDSecMgrDeviceCtrlHandler_0
   \   000021   ....         DW        ??ZDSecMgrDeviceCtrlHandler_1
   \   000023   ....         DW        ??ZDSecMgrDeviceCtrlHandler_2
   \   000025   ....         DW        ??ZDSecMgrDeviceCtrlHandler_3
   \   000027   ....         DW        ??ZDSecMgrDeviceCtrlHandler_0
   \   000029   ....         DW        ??ZDSecMgrDeviceCtrlHandler_0
   \   00002B   ....         DW        ??ZDSecMgrDeviceCtrlHandler_4
   1628            {
   1629              case ZDSECMGR_CTRL_TK_MASTER:
   1630                if ( ZDSecMgrSendMasterKey( device ) == ZSuccess )
   \                     ??ZDSecMgrDeviceCtrlHandler_1:
   \   00002D                ; Setup parameters for call to function ZDSecMgrSendMasterKey
   \   00002D   12....       LCALL   ??ZDSecMgrSendMasterKey?relay
   \   000030   E9           MOV     A,R1
   \   000031   7010         JNZ     ??ZDSecMgrDeviceCtrlHandler_3
   1631                {
   1632                  state = ZDSECMGR_CTRL_SKKE_INIT;
   \   000033   75..03       MOV     ?V0 + 0,#0x3
   1633                  cntr  = ZDSECMGR_CTRL_SKKE_INIT_CNTR;
   \   000036   800F         SJMP    ??ZDSecMgrDeviceCtrlHandler_5
   1634                }
   1635                break;
   1636          
   1637              case ZDSECMGR_CTRL_SKKE_INIT:
   1638                if ( ZDSecMgrEstablishKey( device ) == ZSuccess )
   \                     ??ZDSecMgrDeviceCtrlHandler_2:
   \   000038                ; Setup parameters for call to function ZDSecMgrEstablishKey
   \   000038   12....       LCALL   ??ZDSecMgrEstablishKey?relay
   \   00003B   E9           MOV     A,R1
   \   00003C   7005         JNZ     ??ZDSecMgrDeviceCtrlHandler_3
   1639                {
   1640                  state = ZDSECMGR_CTRL_SKKE_WAIT;
   \   00003E   75..04       MOV     ?V0 + 0,#0x4
   \   000041   8004         SJMP    ??ZDSecMgrDeviceCtrlHandler_5
   1641                }
   1642                break;
   1643          
   1644              case ZDSECMGR_CTRL_SKKE_WAIT:
   1645                // continue to wait for SKA control timeout
   1646                break;
   1647          
   1648              case ZDSECMGR_CTRL_TK_NWK:
   1649                if ( ZDSecMgrSendNwkKey( device ) == ZSuccess )
   1650                {
   1651                  state = ZDSECMGR_CTRL_NONE;
   1652                }
   1653                break;
   1654          
   1655              default:
   1656                state = ZDSECMGR_CTRL_NONE;
   1657                break;
   1658            }
   1659          
   1660            if ( state != ZDSECMGR_CTRL_NONE )
   \                     ??ZDSecMgrDeviceCtrlHandler_3:
   \   000043   E5..         MOV     A,?V0 + 0
   \   000045   6034         JZ      ??ZDSecMgrDeviceCtrlHandler_0
   1661            {
   1662              device->ctrl->state = state;
   \                     ??ZDSecMgrDeviceCtrlHandler_5:
   \   000047   EE           MOV     A,R6
   \   000048   2408         ADD     A,#0x8
   \   00004A   12....       LCALL   ?Subroutine43 & 0xFFFF
   \                     ??CrossCallReturnLabel_60:
   \   00004D   F583         MOV     DPH,A
   \   00004F   8A82         MOV     DPL,R2
   \   000051   A3           INC     DPTR
   \   000052   A3           INC     DPTR
   \   000053   A3           INC     DPTR
   \   000054   A3           INC     DPTR
   \   000055   A3           INC     DPTR
   \   000056   E5..         MOV     A,?V0 + 0
   \   000058   12....       LCALL   ?Subroutine24 & 0xFFFF
   1663              device->ctrl->cntr  = cntr;
   \                     ??CrossCallReturnLabel_22:
   \   00005B   A3           INC     DPTR
   \   00005C   A3           INC     DPTR
   \   00005D   A3           INC     DPTR
   \   00005E   A3           INC     DPTR
   \   00005F   A3           INC     DPTR
   \   000060   A3           INC     DPTR
   \   000061   7401         MOV     A,#0x1
   \   000063   F0           MOVX    @DPTR,A
   1664          
   1665              osal_start_timerEx(ZDAppTaskID, ZDO_SECMGR_EVENT, 100 );
   \   000064                ; Setup parameters for call to function osal_start_timerEx
   \   000064   7C64         MOV     R4,#0x64
   \   000066   7D00         MOV     R5,#0x0
   \   000068   7A00         MOV     R2,#0x0
   \   00006A   FB           MOV     R3,A
   \   00006B   90....       MOV     DPTR,#ZDAppTaskID
   \   00006E   E0           MOVX    A,@DPTR
   \   00006F   F9           MOV     R1,A
   \   000070   12....       LCALL   ??osal_start_timerEx?relay
   \   000073   8015         SJMP    ??CrossCallReturnLabel_77
   1666            }
   \                     ??ZDSecMgrDeviceCtrlHandler_4:
   \   000075                ; Setup parameters for call to function ZDSecMgrSendNwkKey
   \   000075   12....       LCALL   ??ZDSecMgrSendNwkKey?relay
   \   000078   E9           MOV     A,R1
   \   000079   70C8         JNZ     ??ZDSecMgrDeviceCtrlHandler_3
   1667            else
   1668            {
   1669              ZDSecMgrCtrlRelease( device->ctrl );
   \                     ??ZDSecMgrDeviceCtrlHandler_0:
   \   00007B   8E82         MOV     DPL,R6
   \   00007D   8F83         MOV     DPH,R7
   \   00007F   A3           INC     DPTR
   \   000080   A3           INC     DPTR
   \   000081   A3           INC     DPTR
   \   000082   A3           INC     DPTR
   \   000083   A3           INC     DPTR
   \   000084   A3           INC     DPTR
   \   000085   A3           INC     DPTR
   \   000086   A3           INC     DPTR
   \   000087   12....       LCALL   ?Subroutine53 & 0xFFFF
   1670            }
   1671          }
   \                     ??CrossCallReturnLabel_77:
   \   00008A   02....       LJMP    ??Subroutine133_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine92:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002                REQUIRE ??Subroutine115_0
   \   000002                ; // Fall through to label ??Subroutine115_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine115_0:
   \   000000   A3           INC     DPTR
   \   000001   E0           MOVX    A,@DPTR
   \   000002   F583         MOV     DPH,A
   \   000004   8882         MOV     DPL,R0
   \   000006   A3           INC     DPTR
   \   000007   A3           INC     DPTR
   \   000008   A3           INC     DPTR
   \   000009   A3           INC     DPTR
   \   00000A   A3           INC     DPTR
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine54:
   \   000000   12....       LCALL   ?Subroutine92 & 0xFFFF
   \                     ??CrossCallReturnLabel_219:
   \   000003   E0           MOVX    A,@DPTR
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine43:
   \   000000   F8           MOV     R0,A
   \   000001   EF           MOV     A,R7
   \   000002   3400         ADDC    A,#0x0
   \   000004   F9           MOV     R1,A
   \   000005   8882         MOV     DPL,R0
   \   000007   12....       LCALL   ?Subroutine104 & 0xFFFF
   \                     ??CrossCallReturnLabel_312:
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine24:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   8882         MOV     DPL,R0
   \   000003   8983         MOV     DPH,R1
   \   000005   12....       LCALL   ?Subroutine95 & 0xFFFF
   \                     ??CrossCallReturnLabel_296:
   \   000008   22           RET
   1672          
   1673          /******************************************************************************
   1674           * @fn          ZDSecMgrDeviceCtrlSetup
   1675           *
   1676           * @brief       Setup device control.
   1677           *
   1678           * @param       device - [in] ZDSecMgrDevice_t, device info
   1679           *
   1680           * @return      ZStatus_t
   1681           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1682          void ZDSecMgrDeviceCtrlSetup( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceCtrlSetup:
   1683          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1684            if ( device->ctrl != NULL )
   \   000004   8A82         MOV     DPL,R2
   \   000006   8B83         MOV     DPH,R3
   \   000008   A3           INC     DPTR
   \   000009   A3           INC     DPTR
   \   00000A   A3           INC     DPTR
   \   00000B   A3           INC     DPTR
   \   00000C   A3           INC     DPTR
   \   00000D   A3           INC     DPTR
   \   00000E   A3           INC     DPTR
   \   00000F   A3           INC     DPTR
   \   000010   E0           MOVX    A,@DPTR
   \   000011   7002         JNZ     ??ZDSecMgrDeviceCtrlSetup_0
   \   000013   A3           INC     DPTR
   \   000014   E0           MOVX    A,@DPTR
   \                     ??ZDSecMgrDeviceCtrlSetup_0:
   \   000015   602D         JZ      ??ZDSecMgrDeviceCtrlSetup_1
   1685            {
   1686              if ( device->secure == FALSE )
   \   000017   8A82         MOV     DPL,R2
   \   000019   8B83         MOV     DPH,R3
   \   00001B   A3           INC     DPTR
   \   00001C   A3           INC     DPTR
   \   00001D   A3           INC     DPTR
   \   00001E   A3           INC     DPTR
   \   00001F   A3           INC     DPTR
   \   000020   A3           INC     DPTR
   \   000021   E0           MOVX    A,@DPTR
   \   000022   8A82         MOV     DPL,R2
   \   000024   8B83         MOV     DPH,R3
   \   000026   A3           INC     DPTR
   \   000027   A3           INC     DPTR
   \   000028   A3           INC     DPTR
   \   000029   A3           INC     DPTR
   \   00002A   A3           INC     DPTR
   \   00002B   A3           INC     DPTR
   \   00002C   A3           INC     DPTR
   \   00002D   A3           INC     DPTR
   \   00002E   7009         JNZ     ??ZDSecMgrDeviceCtrlSetup_2
   1687              {
   1688                // send the master key data to the joining device
   1689                device->ctrl->state = ZDSECMGR_CTRL_TK_MASTER;
   \   000030   E0           MOVX    A,@DPTR
   \   000031   F8           MOV     R0,A
   \   000032   12....       LCALL   ??Subroutine116_0 & 0xFFFF
   1690              }
   \                     ??CrossCallReturnLabel_213:
   \   000035   7402         MOV     A,#0x2
   \   000037   8007         SJMP    ??ZDSecMgrDeviceCtrlSetup_3
   1691              else
   1692              {
   1693                // start SKKE
   1694                device->ctrl->state = ZDSECMGR_CTRL_SKKE_INIT;
   \                     ??ZDSecMgrDeviceCtrlSetup_2:
   \   000039   E0           MOVX    A,@DPTR
   \   00003A   F8           MOV     R0,A
   \   00003B   12....       LCALL   ??Subroutine116_0 & 0xFFFF
   1695              }
   \                     ??CrossCallReturnLabel_214:
   \   00003E   7403         MOV     A,#0x3
   \                     ??ZDSecMgrDeviceCtrlSetup_3:
   \   000040   F0           MOVX    @DPTR,A
   1696          
   1697              ZDSecMgrDeviceCtrlHandler( device );
   \   000041                ; Setup parameters for call to function ZDSecMgrDeviceCtrlHandler
   \   000041   12....       LCALL   ??ZDSecMgrDeviceCtrlHandler?relay
   1698            }
   1699          }
   \                     ??ZDSecMgrDeviceCtrlSetup_1:
   \   000044   02....       LJMP    ??Subroutine125_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine116_0:
   \   000000   12....       LCALL   ??Subroutine115_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_220:
   \   000003   22           RET
   1700          
   1701          /******************************************************************************
   1702           * @fn          ZDSecMgrDeviceCtrlUpdate
   1703           *
   1704           * @brief       Update control data.
   1705           *
   1706           * @param       extAddr - [in] EXT address
   1707           * @param       state   - [in] new control state
   1708           *
   1709           * @return      none
   1710           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1711          void ZDSecMgrDeviceCtrlUpdate( uint8* extAddr, uint8 state )
   \                     ZDSecMgrDeviceCtrlUpdate:
   1712          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV     A,#-0x4
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   E9           MOV     A,R1
   \   00000B   FE           MOV     R6,A
   1713            ZDSecMgrEntry_t* entry;
   1714            ZDSecMgrCtrl_t*  ctrl;
   1715          
   1716          
   1717            // lookup device entry data
   1718            ZDSecMgrEntryLookupExt( extAddr, &entry );
   \   00000C                ; Setup parameters for call to function ZDSecMgrEntryLookupExt
   \   00000C   7402         MOV     A,#0x2
   \   00000E   12....       LCALL   ?XSTACK_DISP0_8
   \   000011   AC82         MOV     R4,DPL
   \   000013   AD83         MOV     R5,DPH
   \   000015   12....       LCALL   ??ZDSecMgrEntryLookupExt?relay
   1719          
   1720            if ( entry != NULL )
   \   000018   7402         MOV     A,#0x2
   \   00001A   12....       LCALL   ?XSTACK_DISP0_8
   \   00001D   E0           MOVX    A,@DPTR
   \   00001E   7002         JNZ     ??ZDSecMgrDeviceCtrlUpdate_0
   \   000020   A3           INC     DPTR
   \   000021   E0           MOVX    A,@DPTR
   \                     ??ZDSecMgrDeviceCtrlUpdate_0:
   \   000022   604A         JZ      ??ZDSecMgrDeviceCtrlUpdate_1
   1721            {
   1722              // lookup device control data
   1723              ZDSecMgrCtrlLookup( entry, &ctrl );
   \   000024                ; Setup parameters for call to function ZDSecMgrCtrlLookup
   \   000024   85..82       MOV     DPL,?XSP + 0
   \   000027   85..83       MOV     DPH,?XSP + 1
   \   00002A   AC82         MOV     R4,DPL
   \   00002C   AD83         MOV     R5,DPH
   \   00002E   7402         MOV     A,#0x2
   \   000030   12....       LCALL   ?XSTACK_DISP0_8
   \   000033   12....       LCALL   ??Subroutine123_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_233:
   \   000036   12....       LCALL   ?Subroutine81 & 0xFFFF
   1724          
   1725              // make sure control data is valid
   1726              if ( ctrl != NULL )
   \                     ??CrossCallReturnLabel_125:
   \   000039   7002         JNZ     ??ZDSecMgrDeviceCtrlUpdate_2
   \   00003B   A3           INC     DPTR
   \   00003C   E0           MOVX    A,@DPTR
   \                     ??ZDSecMgrDeviceCtrlUpdate_2:
   \   00003D   602F         JZ      ??ZDSecMgrDeviceCtrlUpdate_1
   1727              {
   1728                // possible state transitions
   1729                if ( ctrl->state == ZDSECMGR_CTRL_SKKE_WAIT )
   \   00003F   85..82       MOV     DPL,?XSP + 0
   \   000042   85..83       MOV     DPH,?XSP + 1
   \   000045   12....       LCALL   ?Subroutine54 & 0xFFFF
   \                     ??CrossCallReturnLabel_79:
   \   000048   6404         XRL     A,#0x4
   \   00004A   7022         JNZ     ??ZDSecMgrDeviceCtrlUpdate_1
   1730                {
   1731                  if ( state == ZDSECMGR_CTRL_SKKE_DONE )
   \   00004C   7405         MOV     A,#0x5
   \   00004E   6E           XRL     A,R6
   \   00004F   7007         JNZ     ??ZDSecMgrDeviceCtrlUpdate_3
   1732                  {
   1733                    // send the network key
   1734                    ctrl->state = ZDSECMGR_CTRL_TK_NWK;
   \   000051   12....       LCALL   ?Subroutine55 & 0xFFFF
   1735                    ctrl->cntr  = ZDSECMGR_CTRL_TK_NWK_CNTR;
   1736                  }
   \                     ??CrossCallReturnLabel_216:
   \   000054   7407         MOV     A,#0x7
   \   000056   800A         SJMP    ??ZDSecMgrDeviceCtrlUpdate_4
   1737                  else if ( state == ZDSECMGR_CTRL_SKKE_FAIL )
   \                     ??ZDSecMgrDeviceCtrlUpdate_3:
   \   000058   7406         MOV     A,#0x6
   \   00005A   6E           XRL     A,R6
   \   00005B   7011         JNZ     ??ZDSecMgrDeviceCtrlUpdate_1
   1738                  {
   1739                    // force default timeout in order to cleanup control logic
   1740                    ctrl->state = ZDSECMGR_CTRL_SKKE_FAIL;
   \   00005D   12....       LCALL   ?Subroutine55 & 0xFFFF
   1741                    ctrl->cntr  = ZDSECMGR_CTRL_BASE_CNTR;
   1742                  }
   1743                }
   1744                // timer should be active
   1745              }
   1746            }
   \                     ??CrossCallReturnLabel_217:
   \   000060   7406         MOV     A,#0x6
   \                     ??ZDSecMgrDeviceCtrlUpdate_4:
   \   000062   12....       LCALL   ?Subroutine27 & 0xFFFF
   \                     ??CrossCallReturnLabel_28:
   \   000065   E0           MOVX    A,@DPTR
   \   000066   F8           MOV     R0,A
   \   000067   12....       LCALL   ??Subroutine116_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_215:
   \   00006A   A3           INC     DPTR
   \   00006B   7401         MOV     A,#0x1
   \   00006D   F0           MOVX    @DPTR,A
   1747          }
   \                     ??ZDSecMgrDeviceCtrlUpdate_1:
   \   00006E                REQUIRE ?Subroutine9
   \   00006E                ; // Fall through to label ?Subroutine9

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine9:
   \   000000   7404         MOV     A,#0x4
   \   000002   02....       LJMP    ??Subroutine132_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine55:
   \   000000   85..82       MOV     DPL,?XSP + 0
   \   000003   85..83       MOV     DPH,?XSP + 1
   \   000006                REQUIRE ??Subroutine116_0
   \   000006                ; // Fall through to label ??Subroutine116_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine27:
   \   000000   12....       LCALL   ?Subroutine102 & 0xFFFF
   \                     ??CrossCallReturnLabel_284:
   \   000003   22           RET
   1748          
   1749          void APSME_SKA_TimerExpired( uint8 initiator, uint8* partExtAddr );

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1750          void APSME_SKA_TimerExpired( uint8 initiator, uint8* partExtAddr )
   \                     APSME_SKA_TimerExpired:
   1751          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   E9           MOV     A,R1
   \   000006   FE           MOV     R6,A
   1752            if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   1753            {
   1754              if ( initiator == TRUE )
   \   000007   7401         MOV     A,#0x1
   \   000009   6E           XRL     A,R6
   \   00000A   7005         JNZ     ??APSME_SKA_TimerExpired_0
   1755              {
   1756                ZDSecMgrDeviceCtrlUpdate( partExtAddr, ZDSECMGR_CTRL_SKKE_FAIL );
   \   00000C                ; Setup parameters for call to function ZDSecMgrDeviceCtrlUpdate
   \   00000C   7906         MOV     R1,#0x6
   \   00000E   12....       LCALL   ??ZDSecMgrDeviceCtrlUpdate?relay
   1757              }
   1758            }
   1759          }
   \                     ??APSME_SKA_TimerExpired_0:
   \   000011   02....       LJMP    ??Subroutine133_0 & 0xFFFF
   1760          
   1761          /******************************************************************************
   1762           * @fn          ZDSecMgrDeviceRemove
   1763           *
   1764           * @brief       Remove device from network.
   1765           *
   1766           * @param       device - [in] ZDSecMgrDevice_t, device info
   1767           *
   1768           * @return      none
   1769           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1770          void ZDSecMgrDeviceRemove( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceRemove:
   1771          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 9
   \   000005   74F7         MOV     A,#-0x9
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   1772            APSME_RemoveDeviceReq_t remDevReq;
   1773            NLME_LeaveReq_t         leaveReq;
   1774            associated_devices_t*   assoc;
   1775          
   1776          
   1777            // check if parent, remove the device
   1778            if ( device->parentAddr == NLME_GetShortAddr() )
   \   00000E                ; Setup parameters for call to function NLME_GetShortAddr
   \   00000E   12....       LCALL   ?Subroutine100 & 0xFFFF
   \                     ??CrossCallReturnLabel_212:
   \   000011   7003         JNZ     ??ZDSecMgrDeviceRemove_0
   \   000013   A3           INC     DPTR
   \   000014   E0           MOVX    A,@DPTR
   \   000015   69           XRL     A,R1
   \                     ??ZDSecMgrDeviceRemove_0:
   \   000016   705D         JNZ     ??ZDSecMgrDeviceRemove_1
   1779            {
   1780              // this is the parent of the device
   1781              leaveReq.extAddr        = device->extAddr;
   \   000018   EE           MOV     A,R6
   \   000019   2402         ADD     A,#0x2
   \   00001B   12....       LCALL   ?Subroutine43 & 0xFFFF
   \                     ??CrossCallReturnLabel_61:
   \   00001E   FB           MOV     R3,A
   \   00001F   12....       LCALL   ?Subroutine28 & 0xFFFF
   1782              leaveReq.removeChildren = FALSE;
   \                     ??CrossCallReturnLabel_31:
   \   000022   12....       LCALL   ?XSTACK_DISP0_8
   \   000025   E4           CLR     A
   \   000026   F0           MOVX    @DPTR,A
   1783              leaveReq.rejoin         = FALSE;
   \   000027   7403         MOV     A,#0x3
   \   000029   12....       LCALL   ?XSTACK_DISP0_8
   \   00002C   E4           CLR     A
   \   00002D   F0           MOVX    @DPTR,A
   1784          
   1785              // find child association
   1786              assoc = AssocGetWithExt( device->extAddr );
   \   00002E                ; Setup parameters for call to function AssocGetWithExt
   \   00002E   8882         MOV     DPL,R0
   \   000030   8983         MOV     DPH,R1
   \   000032   12....       LCALL   ?Subroutine70 & 0xFFFF
   \                     ??CrossCallReturnLabel_105:
   \   000035   8A..         MOV     ?V0 + 0,R2
   \   000037   8B..         MOV     ?V0 + 1,R3
   \   000039   A8..         MOV     R0,?V0 + 0
   \   00003B   A9..         MOV     R1,?V0 + 1
   1787          
   1788              if ( ( assoc != NULL                            ) &&
   1789                   ( assoc->nodeRelation >= CHILD_RFD         ) &&
   1790                   ( assoc->nodeRelation <= CHILD_FFD_RX_IDLE )    )
   \   00003D   E8           MOV     A,R0
   \   00003E   7001         JNZ     ??ZDSecMgrDeviceRemove_2
   \   000040   E9           MOV     A,R1
   \                     ??ZDSecMgrDeviceRemove_2:
   \   000041   6055         JZ      ??ZDSecMgrDeviceRemove_3
   \   000043   8882         MOV     DPL,R0
   \   000045   8983         MOV     DPH,R1
   \   000047   A3           INC     DPTR
   \   000048   A3           INC     DPTR
   \   000049   A3           INC     DPTR
   \   00004A   A3           INC     DPTR
   \   00004B   E0           MOVX    A,@DPTR
   \   00004C   14           DEC     A
   \   00004D   C3           CLR     C
   \   00004E   9404         SUBB    A,#0x4
   \   000050   5046         JNC     ??ZDSecMgrDeviceRemove_3
   1791              {
   1792                // check if associated device is authenticated
   1793                if ( assoc->devStatus & DEV_SEC_AUTH_STATUS )
   \   000052   8882         MOV     DPL,R0
   \   000054   8983         MOV     DPH,R1
   \   000056   A3           INC     DPTR
   \   000057   A3           INC     DPTR
   \   000058   A3           INC     DPTR
   \   000059   A3           INC     DPTR
   \   00005A   A3           INC     DPTR
   \   00005B   E0           MOVX    A,@DPTR
   \   00005C   A2E3         MOV     C,0xE0 /* A   */.3
   \   00005E   7404         MOV     A,#0x4
   \   000060   5006         JNC     ??ZDSecMgrDeviceRemove_4
   1794                {
   1795                  leaveReq.silent = FALSE;
   \   000062   12....       LCALL   ?XSTACK_DISP0_8
   \   000065   E4           CLR     A
   \   000066   8005         SJMP    ??ZDSecMgrDeviceRemove_5
   1796                }
   1797                else
   1798                {
   1799                  leaveReq.silent = TRUE;
   \                     ??ZDSecMgrDeviceRemove_4:
   \   000068   12....       LCALL   ?XSTACK_DISP0_8
   \   00006B   7401         MOV     A,#0x1
   1800                }
   1801          
   1802                NLME_LeaveReq( &leaveReq );
   1803              }
   1804            }
   \                     ??ZDSecMgrDeviceRemove_5:
   \   00006D   12....       LCALL   ??Subroutine127_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_259:
   \   000070   12....       LCALL   ??NLME_LeaveReq?relay
   \   000073   8023         SJMP    ??ZDSecMgrDeviceRemove_3
   1805            else
   1806            {
   1807              // this is not the parent of the device
   1808              remDevReq.parentAddr   = device->parentAddr;
   \                     ??ZDSecMgrDeviceRemove_1:
   \   000075   8E82         MOV     DPL,R6
   \   000077   8F83         MOV     DPH,R7
   \   000079   A3           INC     DPTR
   \   00007A   A3           INC     DPTR
   \   00007B   12....       LCALL   ??Subroutine143_0 & 0xFFFF
   1809              remDevReq.childExtAddr = device->extAddr;
   1810          
   1811              APSME_RemoveDeviceReq( &remDevReq );
   1812            }
   \                     ??CrossCallReturnLabel_318:
   \   00007E   7405         MOV     A,#0x5
   \   000080   12....       LCALL   ?XSTACK_DISP0_8
   \   000083   12....       LCALL   ?Subroutine20 & 0xFFFF
   \                     ??CrossCallReturnLabel_15:
   \   000086   7407         MOV     A,#0x7
   \   000088   12....       LCALL   ?XSTACK_DISP0_8
   \   00008B   12....       LCALL   ??Subroutine112_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_187:
   \   00008E   12....       LCALL   ?XSTACK_DISP0_8
   \   000091   AA82         MOV     R2,DPL
   \   000093   AB83         MOV     R3,DPH
   \   000095   12....       LCALL   ??APSME_RemoveDeviceReq?relay
   1813          }
   \                     ??ZDSecMgrDeviceRemove_3:
   \   000098   7409         MOV     A,#0x9
   \   00009A   80..         SJMP    ??Subroutine118_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine28:
   \   000000   85..82       MOV     DPL,?XSP + 0
   \   000003   85..83       MOV     DPH,?XSP + 1
   \   000006   EA           MOV     A,R2
   \   000007   F0           MOVX    @DPTR,A
   \   000008   A3           INC     DPTR
   \   000009   EB           MOV     A,R3
   \   00000A   F0           MOVX    @DPTR,A
   \   00000B   7402         MOV     A,#0x2
   \   00000D   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine70:
   \   000000   12....       LCALL   ??Subroutine142_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_303:
   \   000003   12....       LCALL   ??AssocGetWithExt?relay
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine143_0:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002                REQUIRE ??Subroutine144_0
   \   000002                ; // Fall through to label ??Subroutine144_0
   1814          
   1815          /******************************************************************************
   1816           * @fn          ZDSecMgrDeviceValidateSKKE
   1817           *
   1818           * @brief       Decide whether device is allowed for SKKE.
   1819           *
   1820           * @param       device - [in] ZDSecMgrDevice_t, device info
   1821           *
   1822           * @return      ZStatus_t
   1823           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1824          ZStatus_t ZDSecMgrDeviceValidateSKKE( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceValidateSKKE:
   1825          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV     A,#-0x4
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   1826            ZStatus_t status;
   1827            uint16 ami;
   1828            uint16 keyNvId;
   1829          
   1830          
   1831            // get EXT address
   1832            status = ZDSecMgrExtAddrLookup( device->extAddr, &ami );
   \   00000E                ; Setup parameters for call to function ZDSecMgrExtAddrLookup
   \   00000E   85..82       MOV     DPL,?XSP + 0
   \   000011   85..83       MOV     DPH,?XSP + 1
   \   000014   12....       LCALL   ?Subroutine71 & 0xFFFF
   \                     ??CrossCallReturnLabel_239:
   \   000017   12....       LCALL   ??ZDSecMgrExtAddrLookup?relay
   \   00001A   E9           MOV     A,R1
   1833          
   1834            if ( status == ZSuccess )
   \   00001B   700D         JNZ     ??CrossCallReturnLabel_86
   1835            {
   1836              // get MASTER key
   1837              status = ZDSecMgrMasterKeyLookup( ami, &keyNvId );
   \   00001D                ; Setup parameters for call to function ZDSecMgrMasterKeyLookup
   \   00001D   7402         MOV     A,#0x2
   \   00001F   12....       LCALL   ?XSTACK_DISP0_8
   \   000022   12....       LCALL   ?Subroutine48 & 0xFFFF
   1838          
   1839              if ( status == ZSuccess )
   \                     ??CrossCallReturnLabel_222:
   \   000025   7003         JNZ     ??CrossCallReturnLabel_86
   1840              {
   1841                status = ZDSecMgrDeviceEntryAdd( device, ami );
   \   000027                ; Setup parameters for call to function ZDSecMgrDeviceEntryAdd
   \   000027   12....       LCALL   ?Subroutine60 & 0xFFFF
   1842              }
   1843            }
   1844          
   1845            return status;
   \                     ??CrossCallReturnLabel_86:
   \   00002A   02....       LJMP    ?Subroutine9 & 0xFFFF
   1846          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine60:
   \   000000   85..82       MOV     DPL,?XSP + 0
   \   000003   85..83       MOV     DPH,?XSP + 1
   \   000006   12....       LCALL   ?Subroutine97 & 0xFFFF
   \                     ??CrossCallReturnLabel_147:
   \   000009   12....       LCALL   ??ZDSecMgrDeviceEntryAdd?relay
   \   00000C   22           RET
   1847          
   1848          /******************************************************************************
   1849           * @fn          ZDSecMgrDeviceValidateRM (RESIDENTIAL MODE)
   1850           *
   1851           * @brief       Decide whether device is allowed.
   1852           *
   1853           * @param       device - [in] ZDSecMgrDevice_t, device info
   1854           *
   1855           * @return      ZStatus_t
   1856           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1857          ZStatus_t ZDSecMgrDeviceValidateRM( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceValidateRM:
   1858          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1859          
   1860            ZStatus_t status;
   1861            status = ZSuccess;
   \   000004   7900         MOV     R1,#0x0
   1862          
   1863            (void)device;  // Intentionally unreferenced parameter
   1864            
   1865            // For test purpose, turning off the zgSecurePermitJoin flag will force
   1866            // the trust center to reject any newly joining devices by sending
   1867            // Remove-device to the parents.
   1868            if ( zgSecurePermitJoin == false )
   \   000006   90....       MOV     DPTR,#zgSecurePermitJoin
   \   000009   E0           MOVX    A,@DPTR
   \   00000A   7002         JNZ     ??ZDSecMgrDeviceValidateRM_0
   1869            {
   1870              status = ZNwkUnknownDevice;
   \   00000C   79C8         MOV     R1,#-0x38
   1871            }
   1872          
   1873          
   1874          
   1875          #if 0  // Taken out because the following functionality is only used for test
   1876                 // purpose. A more efficient (above) way is used. It can be put
   1877                 // back in if customers request for a white/black list feature.
   1878                 // ZDSecMgrStoredDeviceList[] is defined in ZDSecMgr.c
   1879          
   1880            // The following code processes the device black list (stored device list)
   1881            // If the joining device is not part of the forbidden device list
   1882            // Return ZSuccess. Otherwise, return ZNwkUnknownDevice. The trust center
   1883            // will send Remove-device and ban the device from joining.
   1884          
   1885            uint8     index;
   1886            uint8*    restricted;
   1887          
   1888            // Look through the stored device list - used for restricted devices
   1889            for ( index = 0; index < ZDSECMGR_STORED_DEVICES; index++ )
   1890            {
   1891              restricted = ZDSecMgrStoredDeviceList[index];
   1892          
   1893              if ( AddrMgrExtAddrEqual( restricted, device->extAddr )  == TRUE )
   1894              {
   1895                // return as unknown device in regards to validation
   1896                status = ZNwkUnknownDevice;
   1897          
   1898                // break from loop
   1899                index = ZDSECMGR_STORED_DEVICES;
   1900              }
   1901            }
   1902          
   1903          #endif
   1904          
   1905            return status;
   \                     ??ZDSecMgrDeviceValidateRM_0:
   \   00000E   02....       LJMP    ??Subroutine125_0 & 0xFFFF
   1906          }
   1907          
   1908          /******************************************************************************
   1909           * @fn          ZDSecMgrDeviceValidateCM (COMMERCIAL MODE)
   1910           *
   1911           * @brief       Decide whether device is allowed.
   1912           *
   1913           * @param       device - [in] ZDSecMgrDevice_t, device info
   1914           *
   1915           * @return      ZStatus_t
   1916           */
   1917          //devtag.pro.security

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1918          ZStatus_t ZDSecMgrDeviceValidateCM( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceValidateCM:
   1919          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 18
   \   000005   74EE         MOV     A,#-0x12
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   1920            ZStatus_t status;
   1921            uint16    ami;
   1922            uint8     key[SEC_KEY_LEN];
   1923          
   1924          
   1925            // implement EXT address and MASTER key policy here -- the total number of
   1926            // Security Manager entries should never exceed the number of EXT addresses
   1927            // and MASTER keys available
   1928            
   1929            // set status based on policy
   1930            //status = ZNwkUnknownDevice;
   1931            
   1932            // set status based on policy
   1933            status = ZSuccess; // ZNwkUnknownDevice;
   1934            
   1935            // get key based on policy
   1936            osal_memcpy( key, ZDSecMgrTCMasterKey, SEC_KEY_LEN);
   \   00000E                ; Setup parameters for call to function osal_memcpy
   \   00000E   75....       MOV     ?V0 + 0,#(ZDSecMgrTCMasterKey & 0xff)
   \   000011   75....       MOV     ?V0 + 1,#((ZDSecMgrTCMasterKey >> 8) & 0xff)
   \   000014   75..80       MOV     ?V0 + 2,#-0x80
   \   000017   78..         MOV     R0,#?V0 + 0
   \   000019   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   00001C   7C10         MOV     R4,#0x10
   \   00001E   7D00         MOV     R5,#0x0
   \   000020   7405         MOV     A,#0x5
   \   000022   12....       LCALL   ?XSTACK_DISP0_8
   \   000025   12....       LCALL   ?Subroutine78 & 0xFFFF
   \                     ??CrossCallReturnLabel_226:
   \   000028   12....       LCALL   ?DEALLOC_XSTACK8
   1937            
   1938            // if policy, store new EXT address
   1939            status = ZDSecMgrAddrStore( device->nwkAddr, device->extAddr, &ami );
   \   00002B   12....       LCALL   ?Subroutine82 & 0xFFFF
   \                     ??CrossCallReturnLabel_127:
   \   00002E                ; Setup parameters for call to function ZDSecMgrAddrStore
   \   00002E   85..82       MOV     DPL,?XSP + 0
   \   000031   85..83       MOV     DPH,?XSP + 1
   \   000034   8582..       MOV     ?V0 + 2,DPL
   \   000037   8583..       MOV     ?V0 + 3,DPH
   \   00003A   78..         MOV     R0,#?V0 + 2
   \   00003C   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00003F   85..82       MOV     DPL,?V0 + 0
   \   000042   8983         MOV     DPH,R1
   \   000044   12....       LCALL   ?Subroutine50 & 0xFFFF
   \                     ??CrossCallReturnLabel_71:
   \   000047   12....       LCALL   ?DEALLOC_XSTACK8
   \   00004A   E9           MOV     A,R1
   \   00004B   F5..         MOV     ?V0 + 2,A
   1940            
   1941            // set the key
   1942            ZDSecMgrMasterKeyLoad( device->extAddr, key );
   \   00004D                ; Setup parameters for call to function ZDSecMgrMasterKeyLoad
   \   00004D   7402         MOV     A,#0x2
   \   00004F   12....       LCALL   ?XSTACK_DISP0_8
   \   000052   AC82         MOV     R4,DPL
   \   000054   AD83         MOV     R5,DPH
   \   000056   85..82       MOV     DPL,?V0 + 0
   \   000059   85..83       MOV     DPH,?V0 + 1
   \   00005C   12....       LCALL   ??Subroutine123_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_234:
   \   00005F   12....       LCALL   ??ZDSecMgrMasterKeyLoad?relay
   1943            
   1944            // if EXT address and MASTER key available -- add device
   1945            if ( status == ZSuccess )
   \   000062   E5..         MOV     A,?V0 + 2
   \   000064   7006         JNZ     ??ZDSecMgrDeviceValidateCM_0
   1946            {
   1947              // add device to internal data - with control
   1948              status = ZDSecMgrDeviceEntryAdd( device, ami );
   \   000066                ; Setup parameters for call to function ZDSecMgrDeviceEntryAdd
   \   000066   12....       LCALL   ?Subroutine60 & 0xFFFF
   1949            }
   \                     ??CrossCallReturnLabel_87:
   \   000069   E9           MOV     A,R1
   \   00006A   F5..         MOV     ?V0 + 2,A
   1950          
   1951            // remove copy of key in RAM  
   1952            osal_memset( key, 0x00, SEC_KEY_LEN );
   \                     ??ZDSecMgrDeviceValidateCM_0:
   \   00006C                ; Setup parameters for call to function osal_memset
   \   00006C   7C10         MOV     R4,#0x10
   \   00006E   7D00         MOV     R5,#0x0
   \   000070   7900         MOV     R1,#0x0
   \   000072   7402         MOV     A,#0x2
   \   000074   12....       LCALL   ?XSTACK_DISP0_8
   \   000077   AA82         MOV     R2,DPL
   \   000079   AB83         MOV     R3,DPH
   \   00007B   12....       LCALL   ??osal_memset?relay
   1953          
   1954            return status;
   \   00007E   A9..         MOV     R1,?V0 + 2
   \   000080   7412         MOV     A,#0x12
   \   000082   02....       LJMP    ??Subroutine128_0 & 0xFFFF
   1955          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine50:
   \   000000   12....       LCALL   ?Subroutine103 & 0xFFFF
   \                     ??CrossCallReturnLabel_157:
   \   000003   8E82         MOV     DPL,R6
   \   000005   8F83         MOV     DPH,R7
   \   000007   12....       LCALL   ??Subroutine142_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_300:
   \   00000A   12....       LCALL   ??ZDSecMgrAddrStore?relay
   \   00000D   7402         MOV     A,#0x2
   \   00000F   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine128_0:
   \   000000   12....       LCALL   ?DEALLOC_XSTACK8
   \   000003                REQUIRE ??Subroutine129_0
   \   000003                ; // Fall through to label ??Subroutine129_0
   1956          
   1957          /******************************************************************************
   1958           * @fn          ZDSecMgrDeviceValidate
   1959           *
   1960           * @brief       Decide whether device is allowed.
   1961           *
   1962           * @param       device - [in] ZDSecMgrDevice_t, device info
   1963           *
   1964           * @return      ZStatus_t
   1965           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1966          ZStatus_t ZDSecMgrDeviceValidate( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceValidate:
   1967          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1968            ZStatus_t status;
   1969          
   1970          
   1971            if ( ZDSecMgrPermitJoiningEnabled == TRUE )
   \   000004   90....       MOV     DPTR,#ZDSecMgrPermitJoiningEnabled
   \   000007   E0           MOVX    A,@DPTR
   \   000008   6401         XRL     A,#0x1
   \   00000A   701D         JNZ     ??ZDSecMgrDeviceValidate_0
   1972            {
   1973              // device may be joining with a secure flag but it is ultimately the Trust
   1974              // Center that decides -- check if expected pre configured device --
   1975              // override settings
   1976              if ( zgPreConfigKeys == TRUE )
   \   00000C   90....       MOV     DPTR,#zgPreConfigKeys
   \   00000F   E0           MOVX    A,@DPTR
   \   000010   6401         XRL     A,#0x1
   \   000012   7004         JNZ     ??ZDSecMgrDeviceValidate_1
   1977              {
   1978                device->secure = TRUE;
   \   000014   7401         MOV     A,#0x1
   \   000016   8001         SJMP    ??ZDSecMgrDeviceValidate_2
   1979              }
   1980              else
   1981              {
   1982                device->secure = FALSE;
   \                     ??ZDSecMgrDeviceValidate_1:
   \   000018   E4           CLR     A
   \                     ??ZDSecMgrDeviceValidate_2:
   \   000019   8A82         MOV     DPL,R2
   \   00001B   8B83         MOV     DPH,R3
   \   00001D   A3           INC     DPTR
   \   00001E   A3           INC     DPTR
   \   00001F   A3           INC     DPTR
   \   000020   A3           INC     DPTR
   \   000021   A3           INC     DPTR
   \   000022   A3           INC     DPTR
   \   000023   F0           MOVX    @DPTR,A
   1983              }
   1984          
   1985              if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   1986              {
   1987                status = ZDSecMgrDeviceValidateCM( device );
   1988              }
   1989              else // ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_RESIDENTIAL )
   1990              {
   1991                status = ZDSecMgrDeviceValidateRM( device );
   \   000024                ; Setup parameters for call to function ZDSecMgrDeviceValidateRM
   \   000024   12....       LCALL   ??ZDSecMgrDeviceValidateRM?relay
   \   000027   8002         SJMP    ??ZDSecMgrDeviceValidate_3
   1992              }
   1993            }
   1994            else
   1995            {
   1996              status = ZNwkUnknownDevice;
   \                     ??ZDSecMgrDeviceValidate_0:
   \   000029   79C8         MOV     R1,#-0x38
   1997            }
   1998          
   1999            return status;
   \                     ??ZDSecMgrDeviceValidate_3:
   \   00002B   02....       LJMP    ??Subroutine125_0 & 0xFFFF
   2000          }
   2001          
   2002          /******************************************************************************
   2003           * @fn          ZDSecMgrDeviceJoin
   2004           *
   2005           * @brief       Try to join this device.
   2006           *
   2007           * @param       device - [in] ZDSecMgrDevice_t, device info
   2008           *
   2009           * @return      ZStatus_t
   2010           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2011          ZStatus_t ZDSecMgrDeviceJoin( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceJoin:
   2012          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   2013            ZStatus_t status;
   2014            uint16    ami;
   2015          
   2016            // attempt to validate device
   2017            status = ZDSecMgrDeviceValidate( device );
   \   00000E                ; Setup parameters for call to function ZDSecMgrDeviceValidate
   \   00000E   12....       LCALL   ??ZDSecMgrDeviceValidate?relay
   \   000011   E9           MOV     A,R1
   \   000012   F5..         MOV     ?V0 + 0,A
   2018          
   2019            if ( status == ZSuccess )
   \   000014   7029         JNZ     ??ZDSecMgrDeviceJoin_0
   2020            {
   2021              if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   2022              {
   2023                ZDSecMgrDeviceCtrlSetup( device );
   2024              }
   2025              else // ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_RESIDENTIAL )
   2026              {
   2027                // Add the device to the address manager
   2028                ZDSecMgrAddrStore( device->nwkAddr, device->extAddr, &ami );
   \   000016                ; Setup parameters for call to function ZDSecMgrAddrStore
   \   000016   85..82       MOV     DPL,?XSP + 0
   \   000019   85..83       MOV     DPH,?XSP + 1
   \   00001C   8582..       MOV     ?V0 + 0,DPL
   \   00001F   8583..       MOV     ?V0 + 1,DPH
   \   000022   78..         MOV     R0,#?V0 + 0
   \   000024   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000027   8E82         MOV     DPL,R6
   \   000029   8F83         MOV     DPH,R7
   \   00002B   A3           INC     DPTR
   \   00002C   A3           INC     DPTR
   \   00002D   12....       LCALL   ?Subroutine50 & 0xFFFF
   \                     ??CrossCallReturnLabel_72:
   \   000030   12....       LCALL   ?DEALLOC_XSTACK8
   2029                //send the nwk key data to the joining device
   2030                status = ZDSecMgrSendNwkKey( device );
   \   000033                ; Setup parameters for call to function ZDSecMgrSendNwkKey
   \   000033   EE           MOV     A,R6
   \   000034   FA           MOV     R2,A
   \   000035   EF           MOV     A,R7
   \   000036   FB           MOV     R3,A
   \   000037   12....       LCALL   ??ZDSecMgrSendNwkKey?relay
   \   00003A   E9           MOV     A,R1
   \   00003B   F5..         MOV     ?V0 + 0,A
   \   00003D   8007         SJMP    ??ZDSecMgrDeviceJoin_1
   2031              }
   2032            }
   2033            else
   2034            {
   2035              // not allowed, remove the device
   2036              ZDSecMgrDeviceRemove( device );
   \                     ??ZDSecMgrDeviceJoin_0:
   \   00003F                ; Setup parameters for call to function ZDSecMgrDeviceRemove
   \   00003F   EE           MOV     A,R6
   \   000040   FA           MOV     R2,A
   \   000041   EF           MOV     A,R7
   \   000042   FB           MOV     R3,A
   \   000043   12....       LCALL   ??ZDSecMgrDeviceRemove?relay
   2037            }
   2038          
   2039            return status;
   \                     ??ZDSecMgrDeviceJoin_1:
   \   000046   A9..         MOV     R1,?V0 + 0
   \   000048   02....       LJMP    ?Subroutine0 & 0xFFFF
   2040          }
   2041          
   2042          /******************************************************************************
   2043           * @fn          ZDSecMgrDeviceJoinDirect
   2044           *
   2045           * @brief       Try to join this device as a direct child.
   2046           *
   2047           * @param       device - [in] ZDSecMgrDevice_t, device info
   2048           *
   2049           * @return      ZStatus_t
   2050           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2051          ZStatus_t ZDSecMgrDeviceJoinDirect( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceJoinDirect:
   2052          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   2053            ZStatus_t status;
   2054          
   2055            status = ZDSecMgrDeviceJoin( device );
   \   000009                ; Setup parameters for call to function ZDSecMgrDeviceJoin
   \   000009   12....       LCALL   ??ZDSecMgrDeviceJoin?relay
   \   00000C   E9           MOV     A,R1
   \   00000D   F5..         MOV     ?V0 + 0,A
   2056          
   2057            if ( status == ZSuccess )
   \   00000F   700D         JNZ     ??ZDSecMgrDeviceJoinDirect_0
   2058            {
   2059              // set association status to authenticated
   2060              ZDSecMgrAssocDeviceAuth( AssocGetWithShort( device->nwkAddr ) );
   \   000011                ; Setup parameters for call to function ZDSecMgrAssocDeviceAuth
   \   000011                ; Setup parameters for call to function AssocGetWithShort
   \   000011   8E82         MOV     DPL,R6
   \   000013   8F83         MOV     DPH,R7
   \   000015   12....       LCALL   ??Subroutine123_0 & 0xFFFF
   2061            }
   \                     ??CrossCallReturnLabel_235:
   \   000018   12....       LCALL   ??AssocGetWithShort?relay
   \   00001B   12....       LCALL   ??ZDSecMgrAssocDeviceAuth?relay
   2062          
   2063            return status;
   \                     ??ZDSecMgrDeviceJoinDirect_0:
   \   00001E   A9..         MOV     R1,?V0 + 0
   \   000020   02....       LJMP    ??Subroutine133_0 & 0xFFFF
   2064          }
   2065          
   2066          /******************************************************************************
   2067           * @fn          ZDSecMgrDeviceJoinFwd
   2068           *
   2069           * @brief       Forward join to Trust Center.
   2070           *
   2071           * @param       device - [in] ZDSecMgrDevice_t, device info
   2072           *
   2073           * @return      ZStatus_t
   2074           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2075          ZStatus_t ZDSecMgrDeviceJoinFwd( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceJoinFwd:
   2076          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 8
   \   000004   74F8         MOV     A,#-0x8
   \   000006   12....       LCALL   ?ALLOC_XSTACK8
   2077            ZStatus_t               status;
   2078            APSME_UpdateDeviceReq_t req;
   2079          
   2080          
   2081            // forward any joining device to the Trust Center -- the Trust Center will
   2082            // decide if the device is allowed to join
   2083            status = ZSuccess;
   2084          
   2085            // forward authorization to the Trust Center
   2086            req.dstAddr    = APSME_TRUSTCENTER_NWKADDR;
   \   000009   85..82       MOV     DPL,?XSP + 0
   \   00000C   85..83       MOV     DPH,?XSP + 1
   \   00000F   E4           CLR     A
   \   000010   F0           MOVX    @DPTR,A
   \   000011   A3           INC     DPTR
   \   000012   F0           MOVX    @DPTR,A
   2087            req.devAddr    = device->nwkAddr;
   \   000013   8A82         MOV     DPL,R2
   \   000015   8B83         MOV     DPH,R3
   \   000017   12....       LCALL   ??Subroutine124_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_242:
   \   00001A   12....       LCALL   ?XSTACK_DISP0_8
   \   00001D   12....       LCALL   ?Subroutine17 & 0xFFFF
   2088            req.devExtAddr = device->extAddr;
   \                     ??CrossCallReturnLabel_5:
   \   000020   12....       LCALL   ?XSTACK_DISP0_8
   \   000023   E8           MOV     A,R0
   \   000024   F0           MOVX    @DPTR,A
   \   000025   A3           INC     DPTR
   \   000026   E9           MOV     A,R1
   \   000027   12....       LCALL   ?Subroutine26 & 0xFFFF
   2089          
   2090            // set security status, option for router to reject if policy set
   2091            if ( (device->devStatus & DEV_HIGH_SEC_STATUS) )
   \                     ??CrossCallReturnLabel_27:
   \   00002A   E0           MOVX    A,@DPTR
   \   00002B   A2E7         MOV     C,0xE0 /* A   */.7
   \   00002D   502E         JNC     ??ZDSecMgrDeviceJoinFwd_0
   2092            {
   2093              if ( device->devStatus & DEV_REJOIN_STATUS )
   \   00002F   A2E6         MOV     C,0xE0 /* A   */.6
   \   000031   5021         JNC     ??ZDSecMgrDeviceJoinFwd_1
   2094              {
   2095                if ( device->secure == TRUE )
   \   000033   8A82         MOV     DPL,R2
   \   000035   8B83         MOV     DPH,R3
   \   000037   A3           INC     DPTR
   \   000038   A3           INC     DPTR
   \   000039   A3           INC     DPTR
   \   00003A   A3           INC     DPTR
   \   00003B   A3           INC     DPTR
   \   00003C   A3           INC     DPTR
   \   00003D   E0           MOVX    A,@DPTR
   \   00003E   6401         XRL     A,#0x1
   \   000040   7009         JNZ     ??ZDSecMgrDeviceJoinFwd_2
   2096                  req.status = APSME_UD_HIGH_SECURED_REJOIN;
   \   000042   7406         MOV     A,#0x6
   \   000044   12....       LCALL   ?XSTACK_DISP0_8
   \   000047   7404         MOV     A,#0x4
   \   000049   803D         SJMP    ??ZDSecMgrDeviceJoinFwd_3
   2097                else
   2098                  req.status = APSME_UD_HIGH_UNSECURED_REJOIN;
   \                     ??ZDSecMgrDeviceJoinFwd_2:
   \   00004B   7406         MOV     A,#0x6
   \   00004D   12....       LCALL   ?XSTACK_DISP0_8
   \   000050   7407         MOV     A,#0x7
   \   000052   8034         SJMP    ??ZDSecMgrDeviceJoinFwd_3
   2099              }
   2100              else
   2101                req.status = APSME_UD_HIGH_UNSECURED_JOIN;
   \                     ??ZDSecMgrDeviceJoinFwd_1:
   \   000054   7406         MOV     A,#0x6
   \   000056   12....       LCALL   ?XSTACK_DISP0_8
   \   000059   7405         MOV     A,#0x5
   \   00005B   802B         SJMP    ??ZDSecMgrDeviceJoinFwd_3
   2102            }
   2103            else
   2104            {
   2105              if ( device->devStatus & DEV_REJOIN_STATUS )
   \                     ??ZDSecMgrDeviceJoinFwd_0:
   \   00005D   A2E6         MOV     C,0xE0 /* A   */.6
   \   00005F   5020         JNC     ??ZDSecMgrDeviceJoinFwd_4
   2106              {
   2107                if ( device->secure == TRUE )
   \   000061   8A82         MOV     DPL,R2
   \   000063   8B83         MOV     DPH,R3
   \   000065   A3           INC     DPTR
   \   000066   A3           INC     DPTR
   \   000067   A3           INC     DPTR
   \   000068   A3           INC     DPTR
   \   000069   A3           INC     DPTR
   \   00006A   A3           INC     DPTR
   \   00006B   E0           MOVX    A,@DPTR
   \   00006C   6401         XRL     A,#0x1
   \   00006E   7008         JNZ     ??ZDSecMgrDeviceJoinFwd_5
   2108                  req.status = APSME_UD_STANDARD_SECURED_REJOIN;
   \   000070   7406         MOV     A,#0x6
   \   000072   12....       LCALL   ?XSTACK_DISP0_8
   \   000075   E4           CLR     A
   \   000076   8010         SJMP    ??ZDSecMgrDeviceJoinFwd_3
   2109                else
   2110                  req.status = APSME_UD_STANDARD_UNSECURED_REJOIN;
   \                     ??ZDSecMgrDeviceJoinFwd_5:
   \   000078   7406         MOV     A,#0x6
   \   00007A   12....       LCALL   ?XSTACK_DISP0_8
   \   00007D   7403         MOV     A,#0x3
   \   00007F   8007         SJMP    ??ZDSecMgrDeviceJoinFwd_3
   2111              }
   2112              else
   2113                req.status = APSME_UD_STANDARD_UNSECURED_JOIN;
   \                     ??ZDSecMgrDeviceJoinFwd_4:
   \   000081   7406         MOV     A,#0x6
   \   000083   12....       LCALL   ?XSTACK_DISP0_8
   \   000086   7401         MOV     A,#0x1
   \                     ??ZDSecMgrDeviceJoinFwd_3:
   \   000088   F0           MOVX    @DPTR,A
   2114            }
   2115          
   2116            if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   2117              req.apsSecure = TRUE;
   2118            else
   2119              req.apsSecure = FALSE;
   \   000089   7407         MOV     A,#0x7
   \   00008B   12....       LCALL   ?XSTACK_DISP0_8
   \   00008E   E4           CLR     A
   \   00008F   12....       LCALL   ??Subroutine127_0 & 0xFFFF
   2120          
   2121            // send and APSME_UPDATE_DEVICE request to the trust center
   2122            status = APSME_UpdateDeviceReq( &req );
   2123          
   2124            return status;
   \                     ??CrossCallReturnLabel_260:
   \   000092   12....       LCALL   ??APSME_UpdateDeviceReq?relay
   \   000095   7408         MOV     A,#0x8
   \   000097   02....       LJMP    ??Subroutine111_0 & 0xFFFF
   2125          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine17:
   \   000000   12....       LCALL   ?Subroutine87 & 0xFFFF
   \                     ??CrossCallReturnLabel_248:
   \   000003   8A82         MOV     DPL,R2
   \   000005   8B83         MOV     DPH,R3
   \   000007   A3           INC     DPTR
   \   000008   A3           INC     DPTR
   \   000009   12....       LCALL   ?Subroutine94 & 0xFFFF
   \                     ??CrossCallReturnLabel_321:
   \   00000C   7404         MOV     A,#0x4
   \   00000E   22           RET
   2126          
   2127          /******************************************************************************
   2128           * @fn          ZDSecMgrDeviceNew
   2129           *
   2130           * @brief       Process a new device.
   2131           *
   2132           * @param       device - [in] ZDSecMgrDevice_t, device info
   2133           *
   2134           * @return      ZStatus_t
   2135           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2136          ZStatus_t ZDSecMgrDeviceNew( ZDSecMgrDevice_t* joiner )
   \                     ZDSecMgrDeviceNew:
   2137          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   2138            ZStatus_t status;
   2139          
   2140            if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   2141            {
   2142              // try to join this device
   2143              status = ZDSecMgrDeviceJoinDirect( joiner );
   2144            }
   2145            else
   2146            {
   2147              status = ZDSecMgrDeviceJoinFwd( joiner );
   2148            }
   2149          
   2150            return status;
   \   000004                ; Setup parameters for call to function ZDSecMgrDeviceJoinDirect
   \   000004   12....       LCALL   ??ZDSecMgrDeviceJoinDirect?relay
   \   000007   80..         SJMP    ??Subroutine125_0
   2151          }
   2152          
   2153          /******************************************************************************
   2154           * @fn          ZDSecMgrAssocDeviceAuth
   2155           *
   2156           * @brief       Set associated device status to authenticated
   2157           *
   2158           * @param       assoc - [in, out] associated_devices_t
   2159           *
   2160           * @return      none
   2161           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2162          void ZDSecMgrAssocDeviceAuth( associated_devices_t* assoc )
   \                     ZDSecMgrAssocDeviceAuth:
   2163          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   2164            if ( assoc != NULL )
   \   000004   EA           MOV     A,R2
   \   000005   7001         JNZ     ??ZDSecMgrAssocDeviceAuth_0
   \   000007   EB           MOV     A,R3
   \                     ??ZDSecMgrAssocDeviceAuth_0:
   \   000008   600D         JZ      ??ZDSecMgrAssocDeviceAuth_1
   2165            {
   2166              assoc->devStatus |= DEV_SEC_AUTH_STATUS;
   \   00000A   8A82         MOV     DPL,R2
   \   00000C   8B83         MOV     DPH,R3
   \   00000E   A3           INC     DPTR
   \   00000F   A3           INC     DPTR
   \   000010   A3           INC     DPTR
   \   000011   A3           INC     DPTR
   \   000012   A3           INC     DPTR
   \   000013   E0           MOVX    A,@DPTR
   \   000014   D2E3         SETB    0xE0 /* A   */.3
   \   000016   F0           MOVX    @DPTR,A
   2167            }
   2168          }
   \                     ??ZDSecMgrAssocDeviceAuth_1:
   \   000017   80..         SJMP    ??Subroutine125_0
   2169          
   2170          /******************************************************************************
   2171           * @fn          ZDSecMgrAuthInitiate
   2172           *
   2173           * @brief       Initiate entity authentication
   2174           *
   2175           * @param       responder - [in] responder EXT address
   2176           *
   2177           * @return      none
   2178           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2179          void ZDSecMgrAuthInitiate( uint8* responder )
   \                     ZDSecMgrAuthInitiate:
   2180          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 7
   \   000005   74F9         MOV     A,#-0x7
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   2181            APSME_AuthenticateReq_t req;
   2182          
   2183          
   2184            // make sure NWK address is available
   2185            if ( APSME_LookupNwkAddr( responder, &req.nwkAddr ) )
   \   00000E                ; Setup parameters for call to function APSME_LookupNwkAddr
   \   00000E   85..82       MOV     DPL,?XSP + 0
   \   000011   85..83       MOV     DPH,?XSP + 1
   \   000014   AC82         MOV     R4,DPL
   \   000016   AD83         MOV     R5,DPH
   \   000018   12....       LCALL   ??APSME_LookupNwkAddr?relay
   \   00001B   E9           MOV     A,R1
   \   00001C   601F         JZ      ??ZDSecMgrAuthInitiate_0
   2186            {
   2187              // set request fields
   2188              req.extAddr   = responder;
   \   00001E   7402         MOV     A,#0x2
   \   000020   12....       LCALL   ?XSTACK_DISP0_8
   \   000023   EE           MOV     A,R6
   \   000024   F0           MOVX    @DPTR,A
   \   000025   A3           INC     DPTR
   \   000026   EF           MOV     A,R7
   \   000027   F0           MOVX    @DPTR,A
   2189              req.action    = APSME_EA_INITIATE;
   \   000028   7406         MOV     A,#0x6
   \   00002A   12....       LCALL   ?XSTACK_DISP0_8
   \   00002D   E4           CLR     A
   \   00002E   F0           MOVX    @DPTR,A
   2190              req.challenge = NULL;
   \   00002F   7404         MOV     A,#0x4
   \   000031   12....       LCALL   ?XSTACK_DISP0_8
   \   000034   E4           CLR     A
   \   000035   F0           MOVX    @DPTR,A
   \   000036   A3           INC     DPTR
   \   000037   12....       LCALL   ??Subroutine127_0 & 0xFFFF
   2191          
   2192              // start EA processing
   2193              APSME_AuthenticateReq( &req );
   2194            }
   \                     ??CrossCallReturnLabel_261:
   \   00003A   12....       LCALL   ??APSME_AuthenticateReq?relay
   2195          }
   \                     ??ZDSecMgrAuthInitiate_0:
   \   00003D   7407         MOV     A,#0x7
   \   00003F   02....       LJMP    ??Subroutine132_0 & 0xFFFF
   2196          
   2197          /******************************************************************************
   2198           * @fn          ZDSecMgrAuthNwkKey
   2199           *
   2200           * @brief       Handle next step in authentication process
   2201           *
   2202           * @param       none
   2203           *
   2204           * @return      none
   2205           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2206          void ZDSecMgrAuthNwkKey()
   \                     ZDSecMgrAuthNwkKey:
   2207          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   2208            if ( devState == DEV_END_DEVICE_UNAUTH )
   \   000004   90....       MOV     DPTR,#devState
   \   000007   E0           MOVX    A,@DPTR
   \   000008   6405         XRL     A,#0x5
   \   00000A   700C         JNZ     ??ZDSecMgrAuthNwkKey_0
   2209            {
   2210              if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   2211              {
   2212                uint8 parent[Z_EXTADDR_LEN];
   2213          
   2214                // get parent's EXT address
   2215                NLME_GetCoordExtAddr( parent );
   2216          
   2217                // begin entity authentication with parent
   2218                ZDSecMgrAuthInitiate( parent );
   2219              }
   2220              else // ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_RESIDENTIAL )
   2221              {
   2222                // inform ZDO that device has been authenticated
   2223                osal_set_event ( ZDAppTaskID, ZDO_DEVICE_AUTH );
   \   00000C                ; Setup parameters for call to function osal_set_event
   \   00000C   7A80         MOV     R2,#-0x80
   \   00000E   7B00         MOV     R3,#0x0
   \   000010   90....       MOV     DPTR,#ZDAppTaskID
   \   000013   E0           MOVX    A,@DPTR
   \   000014   F9           MOV     R1,A
   \   000015   12....       LCALL   ??osal_set_event?relay
   2224              }
   2225            }
   2226          }
   \                     ??ZDSecMgrAuthNwkKey_0:
   \   000018   80..         SJMP    ??Subroutine125_0
   2227          
   2228          /******************************************************************************
   2229           * PUBLIC FUNCTIONS
   2230           */
   2231          /******************************************************************************
   2232           * @fn          ZDSecMgrInit
   2233           *
   2234           * @brief       Initialize ZigBee Device Security Manager.
   2235           *
   2236           * @param       state - device initialization state
   2237           *
   2238           * @return      none
   2239           */
   2240          #if ( ADDRMGR_CALLBACK_ENABLED == 1 )
   2241          void ZDSecMgrAddrMgrCB( uint8 update, AddrMgrEntry_t* newEntry, AddrMgrEntry_t* oldEntry );
   2242          void ZDSecMgrAddrMgrCB( uint8           update,
   2243                                  AddrMgrEntry_t* newEntry,
   2244                                  AddrMgrEntry_t* oldEntry )
   2245          {
   2246            (void)update;
   2247            (void)newEntry;
   2248            (void)oldEntry;
   2249          }
   2250          #endif // ( ADDRMGR_CALLBACK_ENABLED == 1 )
   2251          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine4:
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   \   000004                ; Setup parameters for call to function APSME_SecurityNM
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   \   000004                ; Setup parameters for call to function APSME_SecurityNM
   \   000004   12....       LCALL   ??APSME_SecurityNM?relay
   \   000007                REQUIRE ??Subroutine125_0
   \   000007                ; // Fall through to label ??Subroutine125_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2252          void ZDSecMgrInit(uint8 state)
   \                     ZDSecMgrInit:
   \   000000   80..         SJMP    ?Subroutine4
   2253          {
   2254            if ( (ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH)
   2255                || (ZG_CHECK_SECURITY_MODE == ZG_SECURITY_SE_STANDARD) )
   2256            {
   2257              // initialize sub modules
   2258              ZDSecMgrEntryInit(state);
   2259          
   2260              if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   2261              {
   2262                ZDSecMgrCtrlInit();
   2263              }
   2264          
   2265              // register with Address Manager
   2266              #if ( ADDRMGR_CALLBACK_ENABLED == 1 )
   2267              AddrMgrRegister( ADDRMGR_REG_SECURITY, ZDSecMgrAddrMgrCB );
   2268              #endif
   2269            }
   2270          
   2271            if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   2272            {
   2273              // configure SKA slot data
   2274              APSME_SKA_SlotInit( ZDSECMGR_SKA_SLOT_MAX );
   2275            }
   2276            else if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_SE_STANDARD )
   2277            {
   2278              APSME_TCAddrSetup( zgTrustCenterAddr );    
   2279            }
   2280          
   2281            if ( ZG_SECURE_ENABLED )
   2282            {
   2283              if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   2284              {
   2285                // setup joining permissions
   2286                ZDSecMgrPermitJoiningEnabled = TRUE;
   2287                ZDSecMgrPermitJoiningTimed   = FALSE;
   2288              }
   2289            }
   2290          
   2291            
   2292            // configure security based on security mode and type of device
   2293            ZDSecMgrConfig();
   2294          }
   2295          
   2296          /******************************************************************************
   2297           * @fn          ZDSecMgrConfig
   2298           *
   2299           * @brief       Configure ZigBee Device Security Manager.
   2300           *
   2301           * @param       none
   2302           *
   2303           * @return      none
   2304           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2305          void ZDSecMgrConfig( void )
   \                     ZDSecMgrConfig:
   \   000000   80..         SJMP    ?Subroutine4
   2306          {
   2307            if ( ZG_SECURE_ENABLED )
   2308            {
   2309              SSP_Init();
   2310          
   2311              if ( (ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH)
   2312                  || (ZG_CHECK_SECURITY_MODE == ZG_SECURITY_SE_STANDARD) )
   2313              {
   2314                if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   2315                {
   2316                  // COMMERCIAL MODE - COORDINATOR DEVICE
   2317                  APSME_SecurityCM_CD();
   2318                }
   2319                else if ( ZSTACK_ROUTER_BUILD )
   2320                {
   2321                  // COMMERCIAL MODE - ROUTER DEVICE
   2322                  APSME_SecurityCM_RD();
   2323                }
   2324                else
   2325                {
   2326                  // COMMERCIAL MODE - END DEVICE
   2327                  APSME_SecurityCM_ED();
   2328                }
   2329              }
   2330              else // ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_RESIDENTIAL )
   2331              {
   2332                if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   2333                {
   2334                  // RESIDENTIAL MODE - COORDINATOR DEVICE
   2335                  APSME_SecurityRM_CD();
   2336                }
   2337                else if ( ZSTACK_ROUTER_BUILD )
   2338                {
   2339                  // RESIDENTIAL MODE - ROUTER DEVICE
   2340                  APSME_SecurityRM_RD();
   2341                }
   2342                else
   2343                {
   2344                  // RESIDENTIAL MODE - END DEVICE
   2345                  APSME_SecurityRM_ED();
   2346                }
   2347              }
   2348            }
   2349            else
   2350            {
   2351              // NO SECURITY
   2352              APSME_SecurityNM();
   2353            }
   2354          }
   2355          
   2356          /******************************************************************************
   2357           * @fn          ZDSecMgrPermitJoining
   2358           *
   2359           * @brief       Process request to change joining permissions.
   2360           *
   2361           * @param       duration - [in] timed duration for join in seconds
   2362           *                         - 0x00 not allowed
   2363           *                         - 0xFF allowed without timeout
   2364           *
   2365           * @return      uint8 - success(TRUE:FALSE)
   2366           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2367          uint8 ZDSecMgrPermitJoining( uint8 duration )
   \                     ZDSecMgrPermitJoining:
   2368          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   \   000004   E9           MOV     A,R1
   \   000005   FA           MOV     R2,A
   2369            uint8 accept;
   2370          
   2371          
   2372            ZDSecMgrPermitJoiningTimed = FALSE;
   \   000006   E4           CLR     A
   \   000007   90....       MOV     DPTR,#ZDSecMgrPermitJoiningTimed
   \   00000A   F0           MOVX    @DPTR,A
   2373          
   2374            if ( duration > 0 )
   \   00000B   EA           MOV     A,R2
   \   00000C   6012         JZ      ??ZDSecMgrPermitJoining_0
   2375            {
   2376              ZDSecMgrPermitJoiningEnabled = TRUE;
   \   00000E   7401         MOV     A,#0x1
   \   000010   90....       MOV     DPTR,#ZDSecMgrPermitJoiningEnabled
   \   000013   F0           MOVX    @DPTR,A
   2377          
   2378              if ( duration != 0xFF )
   \   000014   74FF         MOV     A,#-0x1
   \   000016   6A           XRL     A,R2
   \   000017   600C         JZ      ??ZDSecMgrPermitJoining_1
   2379              {
   2380                ZDSecMgrPermitJoiningTimed = TRUE;
   \   000019   7401         MOV     A,#0x1
   \   00001B   90....       MOV     DPTR,#ZDSecMgrPermitJoiningTimed
   \   00001E   8004         SJMP    ??ZDSecMgrPermitJoining_2
   2381              }
   2382            }
   2383            else
   2384            {
   2385              ZDSecMgrPermitJoiningEnabled = FALSE;
   \                     ??ZDSecMgrPermitJoining_0:
   \   000020   E4           CLR     A
   \   000021   90....       MOV     DPTR,#ZDSecMgrPermitJoiningEnabled
   \                     ??ZDSecMgrPermitJoining_2:
   \   000024   F0           MOVX    @DPTR,A
   2386            }
   2387          
   2388            accept = TRUE;
   2389          
   2390            return accept;
   \                     ??ZDSecMgrPermitJoining_1:
   \   000025   7901         MOV     R1,#0x1
   \   000027   02....       LJMP    ??Subroutine125_0 & 0xFFFF
   2391          }
   2392          
   2393          /******************************************************************************
   2394           * @fn          ZDSecMgrPermitJoiningTimeout
   2395           *
   2396           * @brief       Process permit joining timeout
   2397           *
   2398           * @param       none
   2399           *
   2400           * @return      none
   2401           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2402          void ZDSecMgrPermitJoiningTimeout( void )
   \                     ZDSecMgrPermitJoiningTimeout:
   2403          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   2404            if ( ZDSecMgrPermitJoiningTimed == TRUE )
   \   000004   90....       MOV     DPTR,#ZDSecMgrPermitJoiningTimed
   \   000007   E0           MOVX    A,@DPTR
   \   000008   6401         XRL     A,#0x1
   \   00000A   7009         JNZ     ??ZDSecMgrPermitJoiningTimeout_0
   2405            {
   2406              ZDSecMgrPermitJoiningEnabled = FALSE;
   \   00000C   E4           CLR     A
   \   00000D   90....       MOV     DPTR,#ZDSecMgrPermitJoiningEnabled
   \   000010   F0           MOVX    @DPTR,A
   2407              ZDSecMgrPermitJoiningTimed   = FALSE;
   \   000011   90....       MOV     DPTR,#ZDSecMgrPermitJoiningTimed
   \   000014   F0           MOVX    @DPTR,A
   2408            }
   2409          }
   \                     ??ZDSecMgrPermitJoiningTimeout_0:
   \   000015   02....       LJMP    ??Subroutine125_0 & 0xFFFF
   2410          
   2411          /******************************************************************************
   2412           * @fn          ZDSecMgrNewDeviceEvent
   2413           *
   2414           * @brief       Process a the new device event, if found reset new device
   2415           *              event/timer.
   2416           *
   2417           * @param       none
   2418           *
   2419           * @return      uint8 - found(TRUE:FALSE)
   2420           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2421          uint8 ZDSecMgrNewDeviceEvent( void )
   \                     ZDSecMgrNewDeviceEvent:
   2422          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 23
   \   000005   74E9         MOV     A,#-0x17
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   2423            uint8                 found;
   2424            ZDSecMgrDevice_t      device;
   2425            AddrMgrEntry_t        addrEntry;
   2426            associated_devices_t* assoc;
   2427            ZStatus_t             status;
   2428          
   2429            // initialize return results
   2430            found = FALSE;
   \   00000A   75..00       MOV     ?V0 + 0,#0x0
   2431          
   2432            // look for device in the security init state
   2433            assoc = AssocMatchDeviceStatus( DEV_SEC_INIT_STATUS );
   \   00000D                ; Setup parameters for call to function AssocMatchDeviceStatus
   \   00000D   7904         MOV     R1,#0x4
   \   00000F   12....       LCALL   ??AssocMatchDeviceStatus?relay
   \   000012   8A..         MOV     ?V0 + 2,R2
   \   000014   8B..         MOV     ?V0 + 3,R3
   \   000016   AE..         MOV     R6,?V0 + 2
   \   000018   AF..         MOV     R7,?V0 + 3
   2434          
   2435            if ( assoc != NULL )
   \   00001A   EE           MOV     A,R6
   \   00001B   7001         JNZ     ??ZDSecMgrNewDeviceEvent_0
   \   00001D   EF           MOV     A,R7
   \                     ??ZDSecMgrNewDeviceEvent_0:
   \   00001E   7003         JNZ     $+5
   \   000020   02....       LJMP    ??ZDSecMgrNewDeviceEvent_1 & 0xFFFF
   2436            {
   2437              // device found
   2438              found = TRUE;
   \   000023   75..01       MOV     ?V0 + 0,#0x1
   2439          
   2440              // check for preconfigured security
   2441              if ( zgPreConfigKeys == TRUE )
   \   000026   90....       MOV     DPTR,#zgPreConfigKeys
   \   000029   E0           MOVX    A,@DPTR
   \   00002A   6401         XRL     A,#0x1
   \   00002C   7003         JNZ     ??ZDSecMgrNewDeviceEvent_2
   2442              {
   2443                // set association status to authenticated
   2444                ZDSecMgrAssocDeviceAuth( assoc );
   \   00002E                ; Setup parameters for call to function ZDSecMgrAssocDeviceAuth
   \   00002E   12....       LCALL   ??ZDSecMgrAssocDeviceAuth?relay
   2445              }
   2446          
   2447              // set up device info
   2448              addrEntry.user  = ADDRMGR_USER_DEFAULT;
   \                     ??ZDSecMgrNewDeviceEvent_2:
   \   000031   740A         MOV     A,#0xa
   \   000033   12....       LCALL   ?XSTACK_DISP0_8
   \   000036   E4           CLR     A
   \   000037   F0           MOVX    @DPTR,A
   2449              addrEntry.index = assoc->addrIdx;
   \   000038   12....       LCALL   ?Subroutine67 & 0xFFFF
   \                     ??CrossCallReturnLabel_319:
   \   00003B   7415         MOV     A,#0x15
   \   00003D   12....       LCALL   ?XSTACK_DISP0_8
   \   000040   12....       LCALL   ?Subroutine19 & 0xFFFF
   2450              AddrMgrEntryGet( &addrEntry );
   \                     ??CrossCallReturnLabel_11:
   \   000043   12....       LCALL   ?XSTACK_DISP0_8
   \   000046   AA82         MOV     R2,DPL
   \   000048   AB83         MOV     R3,DPH
   \   00004A   12....       LCALL   ??AddrMgrEntryGet?relay
   2451          
   2452              device.nwkAddr    = assoc->shortAddr;
   \   00004D   8E82         MOV     DPL,R6
   \   00004F   8F83         MOV     DPH,R7
   \   000051   12....       LCALL   ?Subroutine32 & 0xFFFF
   2453              device.extAddr    = addrEntry.extAddr;
   \                     ??CrossCallReturnLabel_245:
   \   000054   12....       LCALL   ?XSTACK_DISP0_8
   \   000057   A882         MOV     R0,DPL
   \   000059   A983         MOV     R1,DPH
   \   00005B   7402         MOV     A,#0x2
   \   00005D   12....       LCALL   ?XSTACK_DISP0_8
   \   000060   12....       LCALL   ??Subroutine113_0 & 0xFFFF
   2454              device.parentAddr = NLME_GetShortAddr();
   \                     ??CrossCallReturnLabel_198:
   \   000063                ; Setup parameters for call to function NLME_GetShortAddr
   \   000063   12....       LCALL   ??NLME_GetShortAddr?relay
   \   000066   7404         MOV     A,#0x4
   \   000068   12....       LCALL   ?XSTACK_DISP0_8
   \   00006B   12....       LCALL   ?Subroutine29 & 0xFFFF
   2455              device.secure     = FALSE;
   \                     ??CrossCallReturnLabel_39:
   \   00006E   7406         MOV     A,#0x6
   \   000070   12....       LCALL   ?XSTACK_DISP0_8
   \   000073   E4           CLR     A
   \   000074   F0           MOVX    @DPTR,A
   2456              device.devStatus  = assoc->devStatus;
   \   000075   8E82         MOV     DPL,R6
   \   000077   8F83         MOV     DPH,R7
   \   000079   A3           INC     DPTR
   \   00007A   A3           INC     DPTR
   \   00007B   A3           INC     DPTR
   \   00007C   A3           INC     DPTR
   \   00007D   A3           INC     DPTR
   \   00007E   E0           MOVX    A,@DPTR
   \   00007F   C0E0         PUSH    A
   \   000081   7407         MOV     A,#0x7
   \   000083   12....       LCALL   ?XSTACK_DISP0_8
   \   000086   D0E0         POP     A
   \   000088   12....       LCALL   ??Subroutine127_0 & 0xFFFF
   2457          
   2458              // process new device
   2459              status = ZDSecMgrDeviceNew( &device );
   \                     ??CrossCallReturnLabel_262:
   \   00008B   12....       LCALL   ??ZDSecMgrDeviceNew?relay
   \   00008E   E9           MOV     A,R1
   \   00008F   FA           MOV     R2,A
   2460          
   2461              if ( status == ZSuccess )
   \   000090   700F         JNZ     ??ZDSecMgrNewDeviceEvent_3
   2462              {
   2463                assoc->devStatus &= ~DEV_SEC_INIT_STATUS;
   \   000092   8E82         MOV     DPL,R6
   \   000094   8F83         MOV     DPH,R7
   \   000096   A3           INC     DPTR
   \   000097   A3           INC     DPTR
   \   000098   A3           INC     DPTR
   \   000099   A3           INC     DPTR
   \   00009A   A3           INC     DPTR
   \   00009B   E0           MOVX    A,@DPTR
   \   00009C   C2E2         CLR     0xE0 /* A   */.2
   \   00009E   F0           MOVX    @DPTR,A
   \   00009F   8011         SJMP    ??ZDSecMgrNewDeviceEvent_1
   2464              }
   2465              else if ( status == ZNwkUnknownDevice )
   \                     ??ZDSecMgrNewDeviceEvent_3:
   \   0000A1   74C8         MOV     A,#-0x38
   \   0000A3   6A           XRL     A,R2
   \   0000A4   700C         JNZ     ??ZDSecMgrNewDeviceEvent_1
   2466              {
   2467                AssocRemove( addrEntry.extAddr );
   \   0000A6                ; Setup parameters for call to function AssocRemove
   \   0000A6   740D         MOV     A,#0xd
   \   0000A8   12....       LCALL   ?XSTACK_DISP0_8
   \   0000AB   AA82         MOV     R2,DPL
   \   0000AD   AB83         MOV     R3,DPH
   \   0000AF   12....       LCALL   ??AssocRemove?relay
   2468              }
   2469            }
   2470          
   2471            return found;
   \                     ??ZDSecMgrNewDeviceEvent_1:
   \   0000B2   A9..         MOV     R1,?V0 + 0
   \   0000B4   7417         MOV     A,#0x17
   \   0000B6   80..         SJMP    ??Subroutine128_0
   2472          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine32:
   \   000000   12....       LCALL   ?Subroutine90 & 0xFFFF
   \                     ??CrossCallReturnLabel_139:
   \   000003                REQUIRE ??Subroutine126_0
   \   000003                ; // Fall through to label ??Subroutine126_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine67:
   \   000000   8E82         MOV     DPL,R6
   \   000002   8F83         MOV     DPH,R7
   \   000004                REQUIRE ??Subroutine143_0
   \   000004                ; // Fall through to label ??Subroutine143_0
   2473          
   2474          /******************************************************************************
   2475           * @fn          ZDSecMgrEvent
   2476           *
   2477           * @brief       Handle ZDO Security Manager event/timer(ZDO_SECMGR_EVENT).
   2478           *
   2479           * @param       none
   2480           *
   2481           * @return      none
   2482           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2483          void ZDSecMgrEvent( void )
   \                     ZDSecMgrEvent:
   2484          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 23
   \   000005   74E9         MOV     A,#-0x17
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   2485            uint8            action;
   2486            uint8            restart;
   2487            uint16           index;
   2488            AddrMgrEntry_t   entry;
   2489            ZDSecMgrDevice_t device;
   2490          
   2491          
   2492            // verify data is available
   2493            if ( ZDSecMgrCtrlData != NULL )
   \   00000A   90....       MOV     DPTR,#ZDSecMgrCtrlData
   \   00000D   E0           MOVX    A,@DPTR
   \   00000E   7002         JNZ     ??ZDSecMgrEvent_0
   \   000010   A3           INC     DPTR
   \   000011   E0           MOVX    A,@DPTR
   \                     ??ZDSecMgrEvent_0:
   \   000012   7003         JNZ     $+5
   \   000014   02....       LJMP    ??ZDSecMgrEvent_1 & 0xFFFF
   2494            {
   2495              action  = FALSE;
   \   000017   75..00       MOV     ?V0 + 0,#0x0
   2496              restart = FALSE;
   \   00001A   75..00       MOV     ?V0 + 1,#0x0
   2497          
   2498              // update all the counters
   2499              for ( index = 0; index < ZDSECMGR_ENTRY_MAX; index++ )
   \   00001D   7E00         MOV     R6,#0x0
   \   00001F   7F00         MOV     R7,#0x0
   2500              {
   2501                if ( ZDSecMgrCtrlData[index].state !=  ZDSECMGR_CTRL_NONE )
   \                     ??ZDSecMgrEvent_2:
   \   000021   12....       LCALL   ?Subroutine93 & 0xFFFF
   \                     ??CrossCallReturnLabel_142:
   \   000024   E0           MOVX    A,@DPTR
   \   000025   7003         JNZ     $+5
   \   000027   02....       LJMP    ??ZDSecMgrEvent_3 & 0xFFFF
   2502                {
   2503                  if ( ZDSecMgrCtrlData[index].cntr != 0 )
   \   00002A   12....       LCALL   ?Subroutine47 & 0xFFFF
   \                     ??CrossCallReturnLabel_66:
   \   00002D   6005         JZ      ??ZDSecMgrEvent_4
   2504                  {
   2505                    ZDSecMgrCtrlData[index].cntr--;
   \   00002F   12....       LCALL   ?Subroutine47 & 0xFFFF
   2506                  }
   \                     ??CrossCallReturnLabel_67:
   \   000032   14           DEC     A
   \   000033   F0           MOVX    @DPTR,A
   2507          
   2508                  if ( ( action == FALSE ) && ( ZDSecMgrCtrlData[index].cntr == 0 ) )
   \                     ??ZDSecMgrEvent_4:
   \   000034   E5..         MOV     A,?V0 + 0
   \   000036   6003         JZ      $+5
   \   000038   02....       LJMP    ??ZDSecMgrEvent_5 & 0xFFFF
   \   00003B   12....       LCALL   ?Subroutine47 & 0xFFFF
   \                     ??CrossCallReturnLabel_68:
   \   00003E   6003         JZ      $+5
   \   000040   02....       LJMP    ??ZDSecMgrEvent_5 & 0xFFFF
   2509                  {
   2510                    action = TRUE;
   \   000043   75..01       MOV     ?V0 + 0,#0x1
   \   000046   EE           MOV     A,R6
   \   000047   F8           MOV     R0,A
   \   000048   EF           MOV     A,R7
   \   000049   F9           MOV     R1,A
   \   00004A   E8           MOV     A,R0
   \   00004B   75F007       MOV     B,#0x7
   \   00004E   A4           MUL     AB
   \   00004F   F8           MOV     R0,A
   \   000050   AAF0         MOV     R2,B
   \   000052   75F007       MOV     B,#0x7
   \   000055   E9           MOV     A,R1
   \   000056   A4           MUL     AB
   \   000057   2A           ADD     A,R2
   \   000058   F9           MOV     R1,A
   \   000059   90....       MOV     DPTR,#ZDSecMgrCtrlData
   \   00005C   12....       LCALL   ?Subroutine98 & 0xFFFF
   \                     ??CrossCallReturnLabel_149:
   \   00005F   F9           MOV     R1,A
   \   000060   8882         MOV     DPL,R0
   \   000062   8983         MOV     DPH,R1
   \   000064   12....       LCALL   ??Subroutine122_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_237:
   \   000067   7404         MOV     A,#0x4
   \   000069   12....       LCALL   ?XSTACK_DISP0_8
   \   00006C   12....       LCALL   ?Subroutine29 & 0xFFFF
   2511          
   2512                    // update from control data
   2513                    device.parentAddr = ZDSecMgrCtrlData[index].parentAddr;
   2514                    device.secure     = ZDSecMgrCtrlData[index].secure;
   \                     ??CrossCallReturnLabel_40:
   \   00006F   8882         MOV     DPL,R0
   \   000071   8983         MOV     DPH,R1
   \   000073   A3           INC     DPTR
   \   000074   A3           INC     DPTR
   \   000075   A3           INC     DPTR
   \   000076   A3           INC     DPTR
   \   000077   E0           MOVX    A,@DPTR
   \   000078   C0E0         PUSH    A
   \   00007A   7406         MOV     A,#0x6
   \   00007C   12....       LCALL   ?XSTACK_DISP0_8
   \   00007F   D0E0         POP     A
   \   000081   F0           MOVX    @DPTR,A
   2515                    device.ctrl       = &ZDSecMgrCtrlData[index];
   \   000082   7408         MOV     A,#0x8
   \   000084   12....       LCALL   ?XSTACK_DISP0_8
   \   000087   12....       LCALL   ?Subroutine19 & 0xFFFF
   2516          
   2517                    // set the user and address index
   2518                    entry.user  = ADDRMGR_USER_SECURITY;
   \                     ??CrossCallReturnLabel_12:
   \   00008A   12....       LCALL   ?XSTACK_DISP0_8
   \   00008D   7402         MOV     A,#0x2
   \   00008F   12....       LCALL   ?Subroutine24 & 0xFFFF
   2519                    entry.index = ZDSecMgrCtrlData[index].entry->ami;
   \                     ??CrossCallReturnLabel_23:
   \   000092   12....       LCALL   ??Subroutine144_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_316:
   \   000095   7415         MOV     A,#0x15
   \   000097   12....       LCALL   ?XSTACK_DISP0_8
   \   00009A   12....       LCALL   ?Subroutine19 & 0xFFFF
   2520          
   2521                    // get the address data
   2522                    AddrMgrEntryGet( &entry );
   \                     ??CrossCallReturnLabel_13:
   \   00009D   12....       LCALL   ?XSTACK_DISP0_8
   \   0000A0   AA82         MOV     R2,DPL
   \   0000A2   AB83         MOV     R3,DPH
   \   0000A4   12....       LCALL   ??AddrMgrEntryGet?relay
   2523          
   2524                    // set device address data
   2525                    device.nwkAddr = entry.nwkAddr;
   \   0000A7   740B         MOV     A,#0xb
   \   0000A9   12....       LCALL   ?XSTACK_DISP0_8
   \   0000AC   12....       LCALL   ?Subroutine32 & 0xFFFF
   2526                    device.extAddr = entry.extAddr;
   2527          
   2528                    // update from entry data
   2529                    ZDSecMgrDeviceCtrlHandler( &device );
   2530                  }
   \                     ??CrossCallReturnLabel_246:
   \   0000AF   12....       LCALL   ?XSTACK_DISP0_8
   \   0000B2   A882         MOV     R0,DPL
   \   0000B4   A983         MOV     R1,DPH
   \   0000B6   7402         MOV     A,#0x2
   \   0000B8   12....       LCALL   ?XSTACK_DISP0_8
   \   0000BB   12....       LCALL   ?Subroutine15 & 0xFFFF
   \                     ??CrossCallReturnLabel_2:
   \   0000BE   12....       LCALL   ??ZDSecMgrDeviceCtrlHandler?relay
   \   0000C1   8003         SJMP    ??ZDSecMgrEvent_3
   2531                  else
   2532                  {
   2533                    restart = TRUE;
   \                     ??ZDSecMgrEvent_5:
   \   0000C3   75..01       MOV     ?V0 + 1,#0x1
   2534                  }
   2535                }
   2536              }
   \                     ??ZDSecMgrEvent_3:
   \   0000C6   12....       LCALL   ?Subroutine34 & 0xFFFF
   \                     ??CrossCallReturnLabel_46:
   \   0000C9   5003         JNC     $+5
   \   0000CB   02....       LJMP    ??ZDSecMgrEvent_2 & 0xFFFF
   2537          
   2538              // check for timer restart
   2539              if ( restart == TRUE )
   \   0000CE   7401         MOV     A,#0x1
   \   0000D0   65..         XRL     A,?V0 + 1
   \   0000D2   7010         JNZ     ??ZDSecMgrEvent_1
   2540              {
   2541                osal_start_timerEx(ZDAppTaskID, ZDO_SECMGR_EVENT, 100 );
   \   0000D4                ; Setup parameters for call to function osal_start_timerEx
   \   0000D4   7C64         MOV     R4,#0x64
   \   0000D6   7D00         MOV     R5,#0x0
   \   0000D8   7A00         MOV     R2,#0x0
   \   0000DA   7B01         MOV     R3,#0x1
   \   0000DC   90....       MOV     DPTR,#ZDAppTaskID
   \   0000DF   E0           MOVX    A,@DPTR
   \   0000E0   F9           MOV     R1,A
   \   0000E1   12....       LCALL   ??osal_start_timerEx?relay
   2542              }
   2543            }
   2544          }
   \                     ??ZDSecMgrEvent_1:
   \   0000E4   7417         MOV     A,#0x17
   \   0000E6   02....       LJMP    ??Subroutine118_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine47:
   \   000000   12....       LCALL   ?Subroutine93 & 0xFFFF
   \                     ??CrossCallReturnLabel_143:
   \   000003   A3           INC     DPTR
   \   000004   E0           MOVX    A,@DPTR
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine93:
   \   000000   EE           MOV     A,R6
   \   000001   F8           MOV     R0,A
   \   000002   EF           MOV     A,R7
   \   000003   F9           MOV     R1,A
   \   000004   E8           MOV     A,R0
   \   000005   75F007       MOV     B,#0x7
   \   000008   A4           MUL     AB
   \   000009   F8           MOV     R0,A
   \   00000A   AAF0         MOV     R2,B
   \   00000C   75F007       MOV     B,#0x7
   \   00000F   E9           MOV     A,R1
   \   000010   A4           MUL     AB
   \   000011   2A           ADD     A,R2
   \   000012   F9           MOV     R1,A
   \   000013   90....       MOV     DPTR,#ZDSecMgrCtrlData
   \   000016   E0           MOVX    A,@DPTR
   \   000017   28           ADD     A,R0
   \   000018   FA           MOV     R2,A
   \   000019   A3           INC     DPTR
   \   00001A   E0           MOVX    A,@DPTR
   \   00001B   39           ADDC    A,R1
   \   00001C   8A82         MOV     DPL,R2
   \   00001E   F583         MOV     DPH,A
   \   000020   A3           INC     DPTR
   \   000021   A3           INC     DPTR
   \   000022   A3           INC     DPTR
   \   000023   A3           INC     DPTR
   \   000024   A3           INC     DPTR
   \   000025   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine15:
   \   000000   12....       LCALL   ?Subroutine85 & 0xFFFF
   \                     ??CrossCallReturnLabel_279:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine85:
   \   000000   E8           MOV     A,R0
   \   000001   F0           MOVX    @DPTR,A
   \   000002   A3           INC     DPTR
   \   000003   E9           MOV     A,R1
   \   000004                REQUIRE ??Subroutine138_0
   \   000004                ; // Fall through to label ??Subroutine138_0
   2545          
   2546          /******************************************************************************
   2547           * @fn          ZDSecMgrEstablishKeyCfm
   2548           *
   2549           * @brief       Process the ZDO_EstablishKeyCfm_t message.
   2550           *
   2551           * @param       cfm - [in] ZDO_EstablishKeyCfm_t confirmation
   2552           *
   2553           * @return      none
   2554           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2555          void ZDSecMgrEstablishKeyCfm( ZDO_EstablishKeyCfm_t* cfm )
   \                     ZDSecMgrEstablishKeyCfm:
   2556          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   2557            // send the NWK key
   2558            if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   2559            {
   2560              // update control for specified EXT address
   2561              ZDSecMgrDeviceCtrlUpdate( cfm->partExtAddr, ZDSECMGR_CTRL_SKKE_DONE );
   \   000004                ; Setup parameters for call to function ZDSecMgrDeviceCtrlUpdate
   \   000004   7905         MOV     R1,#0x5
   \   000006   EA           MOV     A,R2
   \   000007   2402         ADD     A,#0x2
   \   000009   0A           INC     R2
   \   00000A   0A           INC     R2
   \   00000B   EB           MOV     A,R3
   \   00000C   3400         ADDC    A,#0x0
   \   00000E   FB           MOV     R3,A
   \   00000F   12....       LCALL   ??ZDSecMgrDeviceCtrlUpdate?relay
   2562            }
   2563            else
   2564            {
   2565              // this should be done when receiving the NWK key
   2566              // if devState ==
   2567              //if ( devState == DEV_END_DEVICE_UNAUTH )
   2568                  //osal_set_event( ZDAppTaskID, ZDO_DEVICE_AUTH );
   2569          
   2570              // if not in joining state -- this should trigger an event for an
   2571              // end point that requested SKKE
   2572              // if ( devState == DEV_END_DEVICE )
   2573             //       devState == DEV_ROUTER;
   2574          
   2575            }
   2576          }
   \   000012   02....       LJMP    ??Subroutine125_0 & 0xFFFF
   2577          
   2578          uint8 ZDSecMgrTCExtAddrCheck( uint8* extAddr );

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2579          uint8 ZDSecMgrTCExtAddrCheck( uint8* extAddr )
   \                     ZDSecMgrTCExtAddrCheck:
   2580          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 8
   \   000005   74F8         MOV     A,#-0x8
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   2581            uint8  match;
   2582            uint8  lookup[Z_EXTADDR_LEN];
   2583          
   2584            match = FALSE;
   \   00000E   75..00       MOV     ?V0 + 0,#0x0
   2585          
   2586            if ( AddrMgrExtAddrLookup( APSME_TRUSTCENTER_NWKADDR, lookup ) )
   \   000011                ; Setup parameters for call to function AddrMgrExtAddrLookup
   \   000011   85..82       MOV     DPL,?XSP + 0
   \   000014   85..83       MOV     DPH,?XSP + 1
   \   000017   AC82         MOV     R4,DPL
   \   000019   AD83         MOV     R5,DPH
   \   00001B   7A00         MOV     R2,#0x0
   \   00001D   7B00         MOV     R3,#0x0
   \   00001F   12....       LCALL   ??AddrMgrExtAddrLookup?relay
   \   000022   E9           MOV     A,R1
   \   000023   6014         JZ      ??ZDSecMgrTCExtAddrCheck_0
   2587            {
   2588              match = AddrMgrExtAddrEqual( lookup, extAddr );
   \   000025                ; Setup parameters for call to function AddrMgrExtAddrEqual
   \   000025   EE           MOV     A,R6
   \   000026   FC           MOV     R4,A
   \   000027   EF           MOV     A,R7
   \   000028   FD           MOV     R5,A
   \   000029   85..82       MOV     DPL,?XSP + 0
   \   00002C   85..83       MOV     DPH,?XSP + 1
   \   00002F   AA82         MOV     R2,DPL
   \   000031   AB83         MOV     R3,DPH
   \   000033   12....       LCALL   ??AddrMgrExtAddrEqual?relay
   \   000036   E9           MOV     A,R1
   \   000037   F5..         MOV     ?V0 + 0,A
   2589            }
   2590          
   2591            return match;
   \                     ??ZDSecMgrTCExtAddrCheck_0:
   \   000039   A9..         MOV     R1,?V0 + 0
   \   00003B   7408         MOV     A,#0x8
   \   00003D   80..         SJMP    ??Subroutine132_0
   2592          }
   2593          
   2594          void ZDSecMgrTCDataLoad( uint8* extAddr );

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2595          void ZDSecMgrTCDataLoad( uint8* extAddr )
   \                     ZDSecMgrTCDataLoad:
   2596          {
   \   000000   74F5         MOV     A,#-0xb
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 20
   \   000005   74EC         MOV     A,#-0x14
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   2597            uint16 ami;
   2598            uint16 keyNvId;   
   2599            uint8 masterKey[SEC_KEY_LEN];
   2600          
   2601            if ( !ZDSecMgrTCDataLoaded )
   \   00000A   90....       MOV     DPTR,#ZDSecMgrTCDataLoaded
   \   00000D   E0           MOVX    A,@DPTR
   \   00000E   7077         JNZ     ??ZDSecMgrTCDataLoad_0
   2602            {
   2603              if ( ZDSecMgrAddrStore( APSME_TRUSTCENTER_NWKADDR, extAddr, &ami ) == ZSuccess )
   \   000010                ; Setup parameters for call to function ZDSecMgrAddrStore
   \   000010   85..82       MOV     DPL,?XSP + 0
   \   000013   85..83       MOV     DPH,?XSP + 1
   \   000016   8582..       MOV     ?V0 + 0,DPL
   \   000019   8583..       MOV     ?V0 + 1,DPH
   \   00001C   78..         MOV     R0,#?V0 + 0
   \   00001E   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000021   EA           MOV     A,R2
   \   000022   FC           MOV     R4,A
   \   000023   EB           MOV     A,R3
   \   000024   FD           MOV     R5,A
   \   000025   7A00         MOV     R2,#0x0
   \   000027   7B00         MOV     R3,#0x0
   \   000029   12....       LCALL   ??ZDSecMgrAddrStore?relay
   \   00002C   7402         MOV     A,#0x2
   \   00002E   12....       LCALL   ?DEALLOC_XSTACK8
   \   000031   E9           MOV     A,R1
   \   000032   704D         JNZ     ??ZDSecMgrTCDataLoad_1
   2604              {
   2605                // if preconfigured load key
   2606                if ( zgPreConfigKeys == TRUE )
   \   000034   90....       MOV     DPTR,#zgPreConfigKeys
   \   000037   E0           MOVX    A,@DPTR
   \   000038   6401         XRL     A,#0x1
   \   00003A   7045         JNZ     ??ZDSecMgrTCDataLoad_1
   2607                {
   2608                  if ( ZDSecMgrMasterKeyLookup( ami, &keyNvId ) != ZSuccess )
   \   00003C                ; Setup parameters for call to function ZDSecMgrMasterKeyLookup
   \   00003C   7402         MOV     A,#0x2
   \   00003E   12....       LCALL   ?XSTACK_DISP0_8
   \   000041   12....       LCALL   ?Subroutine48 & 0xFFFF
   \                     ??CrossCallReturnLabel_223:
   \   000044   603B         JZ      ??ZDSecMgrTCDataLoad_1
   2609                  {
   2610                    // temporary copy
   2611                    osal_memcpy( masterKey, ZDSecMgrTCMasterKey, SEC_KEY_LEN);
   \   000046                ; Setup parameters for call to function osal_memcpy
   \   000046   75....       MOV     ?V0 + 0,#(ZDSecMgrTCMasterKey & 0xff)
   \   000049   75....       MOV     ?V0 + 1,#((ZDSecMgrTCMasterKey >> 8) & 0xff)
   \   00004C   75..80       MOV     ?V0 + 2,#-0x80
   \   00004F   78..         MOV     R0,#?V0 + 0
   \   000051   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000054   7C10         MOV     R4,#0x10
   \   000056   7D00         MOV     R5,#0x0
   \   000058   7407         MOV     A,#0x7
   \   00005A   12....       LCALL   ?XSTACK_DISP0_8
   \   00005D   12....       LCALL   ?Subroutine78 & 0xFFFF
   \                     ??CrossCallReturnLabel_227:
   \   000060   12....       LCALL   ?DEALLOC_XSTACK8
   2612          
   2613                    ZDSecMgrMasterKeyStore( ami, masterKey );
   \   000063                ; Setup parameters for call to function ZDSecMgrMasterKeyStore
   \   000063   7404         MOV     A,#0x4
   \   000065   12....       LCALL   ?XSTACK_DISP0_8
   \   000068   AC82         MOV     R4,DPL
   \   00006A   AD83         MOV     R5,DPH
   \   00006C   12....       LCALL   ?Subroutine68 & 0xFFFF
   2614                      
   2615                    // remove copy of key in RAM  
   2616                    osal_memset( masterKey, 0x00, SEC_KEY_LEN );
   \                     ??CrossCallReturnLabel_102:
   \   00006F                ; Setup parameters for call to function osal_memset
   \   00006F   7C10         MOV     R4,#0x10
   \   000071   7D00         MOV     R5,#0x0
   \   000073   7900         MOV     R1,#0x0
   \   000075   7404         MOV     A,#0x4
   \   000077   12....       LCALL   ?XSTACK_DISP0_8
   \   00007A   AA82         MOV     R2,DPL
   \   00007C   AB83         MOV     R3,DPH
   \   00007E   12....       LCALL   ??osal_memset?relay
   2617                  }
   2618                }
   2619              }
   2620          
   2621              ZDSecMgrTCDataLoaded = TRUE;
   \                     ??ZDSecMgrTCDataLoad_1:
   \   000081   7401         MOV     A,#0x1
   \   000083   90....       MOV     DPTR,#ZDSecMgrTCDataLoaded
   \   000086   F0           MOVX    @DPTR,A
   2622            }
   2623          }
   \                     ??ZDSecMgrTCDataLoad_0:
   \   000087   7414         MOV     A,#0x14
   \   000089   02....       LJMP    ?Subroutine6 & 0xFFFF
   2624          
   2625          /******************************************************************************
   2626           * @fn          ZDSecMgrEstablishKeyInd
   2627           *
   2628           * @brief       Process the ZDO_EstablishKeyInd_t message.
   2629           *
   2630           * @param       ind - [in] ZDO_EstablishKeyInd_t indication
   2631           *
   2632           * @return      none
   2633           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2634          void ZDSecMgrEstablishKeyInd( ZDO_EstablishKeyInd_t* ind )
   \                     ZDSecMgrEstablishKeyInd:
   2635          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 17
   \   000005   74EF         MOV     A,#-0x11
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   2636            ZDSecMgrDevice_t        device;
   2637            APSME_EstablishKeyRsp_t rsp;
   2638          
   2639          
   2640            // load Trust Center data if needed
   2641            ZDSecMgrTCDataLoad( ind->initExtAddr );
   \   00000E   EE           MOV     A,R6
   \   00000F   2404         ADD     A,#0x4
   \   000011   F5..         MOV     ?V0 + 0,A
   \   000013   EF           MOV     A,R7
   \   000014   3400         ADDC    A,#0x0
   \   000016   F5..         MOV     ?V0 + 1,A
   \   000018                ; Setup parameters for call to function ZDSecMgrTCDataLoad
   \   000018   AA..         MOV     R2,?V0 + 0
   \   00001A   FB           MOV     R3,A
   \   00001B   12....       LCALL   ??ZDSecMgrTCDataLoad?relay
   2642          
   2643            if ( ZDSecMgrTCExtAddrCheck( ind->initExtAddr ) )
   \   00001E                ; Setup parameters for call to function ZDSecMgrTCExtAddrCheck
   \   00001E   AA..         MOV     R2,?V0 + 0
   \   000020   AB..         MOV     R3,?V0 + 1
   \   000022   12....       LCALL   ??ZDSecMgrTCExtAddrCheck?relay
   \   000025   E9           MOV     A,R1
   \   000026   6013         JZ      ??ZDSecMgrEstablishKeyInd_0
   2644            {
   2645              //IF (ind->srcAddr == APSME_TRUSTCENTER_NWKADDR)
   2646              //OR
   2647              //!ZDSecMgrTCAuthenticated
   2648              //devtag.0604.critical
   2649                  //how is the parentAddr used here
   2650          
   2651              // initial SKKE from Trust Center via parent
   2652              device.nwkAddr    = APSME_TRUSTCENTER_NWKADDR;
   \   000028   7407         MOV     A,#0x7
   \   00002A   12....       LCALL   ?XSTACK_DISP0_8
   \   00002D   12....       LCALL   ?Subroutine21 & 0xFFFF
   2653              device.parentAddr = ind->srcAddr;
   2654            }
   \                     ??CrossCallReturnLabel_17:
   \   000030   740B         MOV     A,#0xb
   \   000032   12....       LCALL   ?XSTACK_DISP0_8
   \   000035   E8           MOV     A,R0
   \   000036   F0           MOVX    @DPTR,A
   \   000037   A3           INC     DPTR
   \   000038   E9           MOV     A,R1
   \   000039   8016         SJMP    ??ZDSecMgrEstablishKeyInd_1
   2655            else
   2656            {
   2657              // Trust Center direct or E2E SKKE
   2658              device.nwkAddr    = ind->srcAddr;
   \                     ??ZDSecMgrEstablishKeyInd_0:
   \   00003B   12....       LCALL   ?Subroutine67 & 0xFFFF
   \                     ??CrossCallReturnLabel_320:
   \   00003E   7407         MOV     A,#0x7
   \   000040   12....       LCALL   ?XSTACK_DISP0_8
   \   000043   12....       LCALL   ??Subroutine113_0 & 0xFFFF
   2659              device.parentAddr = INVALID_NODE_ADDR;
   \                     ??CrossCallReturnLabel_199:
   \   000046   740B         MOV     A,#0xb
   \   000048   12....       LCALL   ?XSTACK_DISP0_8
   \   00004B   74FE         MOV     A,#-0x2
   \   00004D   F0           MOVX    @DPTR,A
   \   00004E   A3           INC     DPTR
   \   00004F   74FF         MOV     A,#-0x1
   2660            }
   \                     ??ZDSecMgrEstablishKeyInd_1:
   \   000051   12....       LCALL   ?Subroutine88 & 0xFFFF
   2661          
   2662            device.extAddr = ind->initExtAddr;
   \                     ??CrossCallReturnLabel_269:
   \   000054   7409         MOV     A,#0x9
   \   000056   12....       LCALL   ?XSTACK_DISP0_8
   \   000059   E8           MOV     A,R0
   \   00005A   F0           MOVX    @DPTR,A
   \   00005B   A3           INC     DPTR
   \   00005C   E9           MOV     A,R1
   \   00005D   12....       LCALL   ?Subroutine25 & 0xFFFF
   2663            //devtag.pro.security.0724.todo - verify usage
   2664            device.secure  = ind->nwkSecure;
   \                     ??CrossCallReturnLabel_24:
   \   000060   C0E0         PUSH    A
   \   000062   740D         MOV     A,#0xd
   \   000064   12....       LCALL   ?XSTACK_DISP0_8
   \   000067   D0E0         POP     A
   \   000069   F0           MOVX    @DPTR,A
   2665          
   2666            // validate device for SKKE
   2667            if ( ZDSecMgrDeviceValidateSKKE( &device ) == ZSuccess )
   \   00006A                ; Setup parameters for call to function ZDSecMgrDeviceValidateSKKE
   \   00006A   7407         MOV     A,#0x7
   \   00006C   12....       LCALL   ?XSTACK_DISP0_8
   \   00006F   AA82         MOV     R2,DPL
   \   000071   AB83         MOV     R3,DPH
   \   000073   12....       LCALL   ??ZDSecMgrDeviceValidateSKKE?relay
   \   000076   E9           MOV     A,R1
   \   000077   7009         JNZ     ??ZDSecMgrEstablishKeyInd_2
   2668            {
   2669              rsp.accept = TRUE;
   \   000079   7404         MOV     A,#0x4
   \   00007B   12....       LCALL   ?XSTACK_DISP0_8
   \   00007E   7401         MOV     A,#0x1
   \   000080   8006         SJMP    ??ZDSecMgrEstablishKeyInd_3
   2670            }
   2671            else
   2672            {
   2673              rsp.accept = FALSE;
   \                     ??ZDSecMgrEstablishKeyInd_2:
   \   000082   7404         MOV     A,#0x4
   \   000084   12....       LCALL   ?XSTACK_DISP0_8
   \   000087   E4           CLR     A
   \                     ??ZDSecMgrEstablishKeyInd_3:
   \   000088   F0           MOVX    @DPTR,A
   2674            }
   2675          
   2676            rsp.dstAddr     = ind->srcAddr;
   \   000089   12....       LCALL   ?Subroutine13 & 0xFFFF
   2677            rsp.initExtAddr = &ind->initExtAddr[0];
   \                     ??CrossCallReturnLabel_266:
   \   00008C   12....       LCALL   ?XSTACK_DISP0_8
   \   00008F   12....       LCALL   ??Subroutine113_0 & 0xFFFF
   2678            //devtag.0604.todo - remove obsolete
   2679            rsp.apsSecure   = ind->apsSecure;
   \                     ??CrossCallReturnLabel_200:
   \   000092   EE           MOV     A,R6
   \   000093   240D         ADD     A,#0xd
   \   000095   12....       LCALL   ??Subroutine136_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_273:
   \   000098   E0           MOVX    A,@DPTR
   \   000099   C0E0         PUSH    A
   \   00009B   7405         MOV     A,#0x5
   \   00009D   12....       LCALL   ?XSTACK_DISP0_8
   \   0000A0   D0E0         POP     A
   \   0000A2   12....       LCALL   ?Subroutine25 & 0xFFFF
   2680            rsp.nwkSecure   = ind->nwkSecure;
   \                     ??CrossCallReturnLabel_25:
   \   0000A5   C0E0         PUSH    A
   \   0000A7   7406         MOV     A,#0x6
   \   0000A9   12....       LCALL   ?XSTACK_DISP0_8
   \   0000AC   D0E0         POP     A
   \   0000AE   12....       LCALL   ??Subroutine127_0 & 0xFFFF
   2681          
   2682            APSME_EstablishKeyRsp( &rsp );
   \                     ??CrossCallReturnLabel_263:
   \   0000B1   12....       LCALL   ??APSME_EstablishKeyRsp?relay
   2683          }
   \   0000B4   7411         MOV     A,#0x11
   \   0000B6   02....       LJMP    ??Subroutine118_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine25:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   EE           MOV     A,R6
   \   000002   240E         ADD     A,#0xe
   \   000004   F582         MOV     DPL,A
   \   000006   EF           MOV     A,R7
   \   000007   3400         ADDC    A,#0x0
   \   000009   F583         MOV     DPH,A
   \   00000B   E0           MOVX    A,@DPTR
   \   00000C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine13:
   \   000000   8E82         MOV     DPL,R6
   \   000002   8F83         MOV     DPH,R7
   \   000004   A3           INC     DPTR
   \   000005   A3           INC     DPTR
   \   000006   12....       LCALL   ?Subroutine90 & 0xFFFF
   \                     ??CrossCallReturnLabel_137:
   \   000009   E8           MOV     A,R0
   \   00000A   F0           MOVX    @DPTR,A
   \   00000B   A3           INC     DPTR
   \   00000C   E9           MOV     A,R1
   \   00000D                REQUIRE ??Subroutine134_0
   \   00000D                ; // Fall through to label ??Subroutine134_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine134_0:
   \   000000   12....       LCALL   ?Subroutine88 & 0xFFFF
   \                     ??CrossCallReturnLabel_270:
   \   000003   7402         MOV     A,#0x2
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine88:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   EE           MOV     A,R6
   \   000002   2404         ADD     A,#0x4
   \   000004   F8           MOV     R0,A
   \   000005   EF           MOV     A,R7
   \   000006   3400         ADDC    A,#0x0
   \   000008   F9           MOV     R1,A
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine136_0:
   \   000000   F582         MOV     DPL,A
   \   000002   EF           MOV     A,R7
   \   000003                REQUIRE ??Subroutine137_0
   \   000003                ; // Fall through to label ??Subroutine137_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine137_0:
   \   000000   3400         ADDC    A,#0x0
   \   000002   F583         MOV     DPH,A
   \   000004   22           RET
   2684          //devtag.pro.security
   2685          #if 0
   2686          void ZDSecMgrEstablishKeyInd( ZDO_EstablishKeyInd_t* ind )
   2687          {
   2688            ZDSecMgrDevice_t        device;
   2689            APSME_EstablishKeyRsp_t rsp;
   2690          
   2691          
   2692            device.extAddr = ind->initExtAddr;
   2693            device.secure  = ind->secure;
   2694          
   2695            if ( ind->secure == FALSE )
   2696            {
   2697              // SKKE from Trust Center is not secured between child and parent
   2698              device.nwkAddr    = APSME_TRUSTCENTER_NWKADDR;
   2699              device.parentAddr = ind->srcAddr;
   2700            }
   2701            else
   2702            {
   2703              // SKKE from initiator should be secured
   2704              device.nwkAddr    = ind->srcAddr;
   2705              device.parentAddr = INVALID_NODE_ADDR;
   2706            }
   2707          
   2708            rsp.dstAddr     = ind->srcAddr;
   2709            rsp.initExtAddr = &ind->initExtAddr[0];
   2710            rsp.secure      = ind->secure;
   2711          
   2712            // validate device for SKKE
   2713            if ( ZDSecMgrDeviceValidateSKKE( &device ) == ZSuccess )
   2714            {
   2715              rsp.accept = TRUE;
   2716            }
   2717            else
   2718            {
   2719              rsp.accept = FALSE;
   2720            }
   2721          
   2722            APSME_EstablishKeyRsp( &rsp );
   2723          }
   2724          #endif
   2725          
   2726          /******************************************************************************
   2727           * @fn          ZDSecMgrTransportKeyInd
   2728           *
   2729           * @brief       Process the ZDO_TransportKeyInd_t message.
   2730           *
   2731           * @param       ind - [in] ZDO_TransportKeyInd_t indication
   2732           *
   2733           * @return      none
   2734           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2735          void ZDSecMgrTransportKeyInd( ZDO_TransportKeyInd_t* ind )
   \                     ZDSecMgrTransportKeyInd:
   2736          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 16
   \   000005   74F0         MOV     A,#-0x10
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   2737            uint8 index;
   2738            uint8 zgPreConfigKey[SEC_KEY_LEN];
   2739          
   2740            // load Trust Center data if needed
   2741            ZDSecMgrTCDataLoad( ind->srcExtAddr );
   \   00000E                ; Setup parameters for call to function ZDSecMgrTCDataLoad
   \   00000E   EE           MOV     A,R6
   \   00000F   2416         ADD     A,#0x16
   \   000011   FA           MOV     R2,A
   \   000012   EF           MOV     A,R7
   \   000013   3400         ADDC    A,#0x0
   \   000015   FB           MOV     R3,A
   \   000016   12....       LCALL   ??ZDSecMgrTCDataLoad?relay
   2742          
   2743            if ( ind->keyType == KEY_TYPE_TC_MASTER )
   \   000019   8E82         MOV     DPL,R6
   \   00001B   8F83         MOV     DPH,R7
   \   00001D   A3           INC     DPTR
   \   00001E   A3           INC     DPTR
   \   00001F   A3           INC     DPTR
   \   000020   A3           INC     DPTR
   \   000021   E0           MOVX    A,@DPTR
   \   000022   7003         JNZ     $+5
   \   000024   02....       LJMP    ??ZDSecMgrTransportKeyInd_0 & 0xFFFF
   2744            {
   2745              if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   2746              //ZDSecMgrTCMasterKey( ind );
   2747              {
   2748                if ( zgPreConfigKeys != TRUE )
   2749                {
   2750                  // devtag.pro.security.todo - check if Trust Center address is configured and correct
   2751                  ZDSecMgrMasterKeyLoad( ind->srcExtAddr, ind->key );
   2752                }
   2753                else
   2754                {
   2755                  // error condition - reject key
   2756                }
   2757              }
   2758            }
   2759            else if ( ( ind->keyType == KEY_TYPE_NWK      ) ||
   2760                      ( ind->keyType == 6                 ) ||
   2761                      ( ind->keyType == KEY_TYPE_NWK_HIGH )    )
   \   000027   6401         XRL     A,#0x1
   \   000029   601D         JZ      ??ZDSecMgrTransportKeyInd_1
   \   00002B   8E82         MOV     DPL,R6
   \   00002D   8F83         MOV     DPH,R7
   \   00002F   A3           INC     DPTR
   \   000030   A3           INC     DPTR
   \   000031   A3           INC     DPTR
   \   000032   A3           INC     DPTR
   \   000033   E0           MOVX    A,@DPTR
   \   000034   6406         XRL     A,#0x6
   \   000036   6010         JZ      ??ZDSecMgrTransportKeyInd_1
   \   000038   8E82         MOV     DPL,R6
   \   00003A   8F83         MOV     DPH,R7
   \   00003C   A3           INC     DPTR
   \   00003D   A3           INC     DPTR
   \   00003E   A3           INC     DPTR
   \   00003F   A3           INC     DPTR
   \   000040   E0           MOVX    A,@DPTR
   \   000041   6405         XRL     A,#0x5
   \   000043   6003         JZ      $+5
   \   000045   02....       LJMP    ??ZDSecMgrTransportKeyInd_0 & 0xFFFF
   2762            {
   2763              // check for dummy NWK key (all zeros)
   2764              for ( index = 0;
   \                     ??ZDSecMgrTransportKeyInd_1:
   \   000048   7A00         MOV     R2,#0x0
   \                     ??ZDSecMgrTransportKeyInd_2:
   \   00004A   8A..         MOV     ?V0 + 0,R2
   \   00004C   EE           MOV     A,R6
   \   00004D   25..         ADD     A,?V0 + 0
   \   00004F   12....       LCALL   ??Subroutine136_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_274:
   \   000052   A3           INC     DPTR
   \   000053   A3           INC     DPTR
   \   000054   A3           INC     DPTR
   \   000055   A3           INC     DPTR
   \   000056   A3           INC     DPTR
   \   000057   A3           INC     DPTR
   \   000058   E0           MOVX    A,@DPTR
   \   000059   7007         JNZ     ??ZDSecMgrTransportKeyInd_3
   2765                    ( (index < SEC_KEY_LEN) && (ind->key[index] == 0) );
   2766                    index++ );
   \   00005B   0A           INC     R2
   \   00005C   EA           MOV     A,R2
   \   00005D   C3           CLR     C
   \   00005E   9410         SUBB    A,#0x10
   \   000060   40E8         JC      ??ZDSecMgrTransportKeyInd_2
   2767          
   2768              if ( index == SEC_KEY_LEN )
   \                     ??ZDSecMgrTransportKeyInd_3:
   \   000062   7410         MOV     A,#0x10
   \   000064   6A           XRL     A,R2
   \   000065   7040         JNZ     ??ZDSecMgrTransportKeyInd_4
   2769              {
   2770                // load preconfigured key - once!!
   2771                if ( !_NIB.nwkKeyLoaded )
   \   000067   90....       MOV     DPTR,#(_NIB + 61)
   \   00006A   E0           MOVX    A,@DPTR
   \   00006B   705F         JNZ     ??ZDSecMgrTransportKeyInd_5
   2772                {
   2773                  ZDSecMgrReadKeyFromNv(ZCD_NV_PRECFGKEY, zgPreConfigKey);
   \   00006D                ; Setup parameters for call to function ZDSecMgrReadKeyFromNv
   \   00006D   85..82       MOV     DPL,?XSP + 0
   \   000070   85..83       MOV     DPH,?XSP + 1
   \   000073   AC82         MOV     R4,DPL
   \   000075   AD83         MOV     R5,DPH
   \   000077   7A62         MOV     R2,#0x62
   \   000079   7B00         MOV     R3,#0x0
   \   00007B   12....       LCALL   ??ZDSecMgrReadKeyFromNv?relay
   2774                  SSP_UpdateNwkKey( zgPreConfigKey, 0 );
   \   00007E                ; Setup parameters for call to function SSP_UpdateNwkKey
   \   00007E   7900         MOV     R1,#0x0
   \   000080   85..82       MOV     DPL,?XSP + 0
   \   000083   85..83       MOV     DPH,?XSP + 1
   \   000086   AA82         MOV     R2,DPL
   \   000088   AB83         MOV     R3,DPH
   \   00008A   12....       LCALL   ??SSP_UpdateNwkKey?relay
   2775                  SSP_SwitchNwkKey( 0 );
   \   00008D                ; Setup parameters for call to function SSP_SwitchNwkKey
   \   00008D   7900         MOV     R1,#0x0
   \   00008F   12....       LCALL   ??SSP_SwitchNwkKey?relay
   2776                  
   2777                  // clear local copy of key
   2778                  osal_memset(zgPreConfigKey, 0x00, SEC_KEY_LEN);
   \   000092                ; Setup parameters for call to function osal_memset
   \   000092   7C10         MOV     R4,#0x10
   \   000094   7D00         MOV     R5,#0x0
   \   000096   7900         MOV     R1,#0x0
   \   000098   85..82       MOV     DPL,?XSP + 0
   \   00009B   85..83       MOV     DPH,?XSP + 1
   \   00009E   AA82         MOV     R2,DPL
   \   0000A0   AB83         MOV     R3,DPH
   \   0000A2   12....       LCALL   ??osal_memset?relay
   \   0000A5   8025         SJMP    ??ZDSecMgrTransportKeyInd_5
   2779                }
   2780              }
   2781              else
   2782              {
   2783                SSP_UpdateNwkKey( ind->key, ind->keySeqNum );
   \                     ??ZDSecMgrTransportKeyInd_4:
   \   0000A7                ; Setup parameters for call to function SSP_UpdateNwkKey
   \   0000A7   8E82         MOV     DPL,R6
   \   0000A9   8F83         MOV     DPH,R7
   \   0000AB   A3           INC     DPTR
   \   0000AC   A3           INC     DPTR
   \   0000AD   A3           INC     DPTR
   \   0000AE   A3           INC     DPTR
   \   0000AF   A3           INC     DPTR
   \   0000B0   E0           MOVX    A,@DPTR
   \   0000B1   F9           MOV     R1,A
   \   0000B2   12....       LCALL   ?Subroutine101 & 0xFFFF
   \                     ??CrossCallReturnLabel_153:
   \   0000B5   12....       LCALL   ??SSP_UpdateNwkKey?relay
   2784                if ( !_NIB.nwkKeyLoaded )
   \   0000B8   90....       MOV     DPTR,#(_NIB + 61)
   \   0000BB   E0           MOVX    A,@DPTR
   \   0000BC   700E         JNZ     ??ZDSecMgrTransportKeyInd_5
   2785                {
   2786                  SSP_SwitchNwkKey( ind->keySeqNum );
   \   0000BE                ; Setup parameters for call to function SSP_SwitchNwkKey
   \   0000BE   8E82         MOV     DPL,R6
   \   0000C0   8F83         MOV     DPH,R7
   \   0000C2   A3           INC     DPTR
   \   0000C3   A3           INC     DPTR
   \   0000C4   A3           INC     DPTR
   \   0000C5   A3           INC     DPTR
   \   0000C6   A3           INC     DPTR
   \   0000C7   E0           MOVX    A,@DPTR
   \   0000C8   F9           MOV     R1,A
   \   0000C9   12....       LCALL   ??SSP_SwitchNwkKey?relay
   2787                }
   2788              }
   2789          
   2790              // handle next step in authentication process
   2791              ZDSecMgrAuthNwkKey();
   \                     ??ZDSecMgrTransportKeyInd_5:
   \   0000CC                ; Setup parameters for call to function ZDSecMgrAuthNwkKey
   \   0000CC   12....       LCALL   ??ZDSecMgrAuthNwkKey?relay
   2792            }
   2793            else if ( ind->keyType == KEY_TYPE_TC_LINK )
   2794            {
   2795              if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   2796              {
   2797                // This should not happen because TCLK should not be Tx
   2798              }
   2799            }
   2800            else if ( ind->keyType == KEY_TYPE_APP_MASTER )
   2801            {
   2802              if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   2803              {
   2804                uint16           ami;
   2805                AddrMgrEntry_t   entry;
   2806                ZDSecMgrEntry_t* entryZD;
   2807          
   2808                ZDSecMgrExtAddrLookup( ind->srcExtAddr, &ami );
   2809          
   2810                if ( ind->initiator == TRUE )
   2811                {
   2812                  // get the ami data
   2813                  entry.user  = ADDRMGR_USER_SECURITY;
   2814                  entry.index = ami;
   2815                  AddrMgrEntryGet( &entry );
   2816          
   2817                  if ( entry.nwkAddr != INVALID_NODE_ADDR )
   2818                  {
   2819                    APSME_EstablishKeyReq_t req;
   2820                    ZDSecMgrMasterKeyLoad( ind->srcExtAddr, ind->key );
   2821          
   2822                    ZDSecMgrEntryLookupAMI( ami, &entryZD );
   2823          
   2824                    if ( entryZD == NULL )
   2825                    {
   2826                      // get new entry
   2827                      if ( ZDSecMgrEntryNew( &entryZD ) == ZSuccess )
   2828                      {
   2829                        // finish setting up entry
   2830                        entryZD->ami = ami;
   2831                      }
   2832                    }
   2833          
   2834                    req.respExtAddr = ind->srcExtAddr;
   2835                    req.method      = APSME_SKKE_METHOD;
   2836                    req.dstAddr     = entry.nwkAddr;
   2837                    req.apsSecure   = FALSE;
   2838                    req.nwkSecure   = TRUE;
   2839                    APSME_EstablishKeyReq( &req );
   2840                  }
   2841                }
   2842                else
   2843                {
   2844                  if ( ami == INVALID_NODE_ADDR )
   2845                  {
   2846                    // store new EXT address
   2847                    ZDSecMgrAddrStore( INVALID_NODE_ADDR, ind->srcExtAddr, &ami );
   2848                  }
   2849          
   2850                  ZDSecMgrMasterKeyLoad( ind->srcExtAddr, ind->key );
   2851                }
   2852              }
   2853            }
   2854            else if ( ind->keyType == KEY_TYPE_APP_LINK )
   2855            {
   2856              if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   2857              {
   2858                uint16           ami;
   2859                ZDSecMgrEntry_t* entry;
   2860          
   2861                // get the address index
   2862                if ( ZDSecMgrExtAddrLookup( ind->srcExtAddr, &ami ) != ZSuccess )
   2863                {
   2864                  // store new EXT address
   2865                  ZDSecMgrAddrStore( INVALID_NODE_ADDR, ind->srcExtAddr, &ami );
   2866                  ZDP_NwkAddrReq( ind->srcExtAddr, ZDP_ADDR_REQTYPE_SINGLE, 0, 0 );
   2867                }
   2868          
   2869                ZDSecMgrEntryLookupAMI( ami, &entry );
   2870          
   2871                if ( entry == NULL )
   2872                {
   2873                  // get new entry
   2874                  if ( ZDSecMgrEntryNew( &entry ) == ZSuccess )
   2875                  {
   2876                    // finish setting up entry
   2877                    entry->ami = ami;
   2878                  }
   2879                }
   2880          
   2881                ZDSecMgrLinkKeySet( ind->srcExtAddr, ind->key );
   2882              }
   2883            }
   2884          }
   \                     ??ZDSecMgrTransportKeyInd_0:
   \   0000CF   7410         MOV     A,#0x10
   \   0000D1   02....       LJMP    ??Subroutine118_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine101:
   \   000000   EE           MOV     A,R6
   \   000001   2406         ADD     A,#0x6
   \   000003   FA           MOV     R2,A
   \   000004   EF           MOV     A,R7
   \   000005   3400         ADDC    A,#0x0
   \   000007   FB           MOV     R3,A
   \   000008   22           RET
   2885          
   2886          /******************************************************************************
   2887           * @fn          ZDSecMgrUpdateDeviceInd
   2888           *
   2889           * @brief       Process the ZDO_UpdateDeviceInd_t message.
   2890           *
   2891           * @param       ind - [in] ZDO_UpdateDeviceInd_t indication
   2892           *
   2893           * @return      none
   2894           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine10:
   \   000000   740A         MOV     A,#0xa
   \   000002                REQUIRE ??Subroutine111_0
   \   000002                ; // Fall through to label ??Subroutine111_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2895          void ZDSecMgrUpdateDeviceInd( ZDO_UpdateDeviceInd_t* ind )
   \                     ZDSecMgrUpdateDeviceInd:
   2896          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 10
   \   000004   74F6         MOV     A,#-0xa
   \   000006   12....       LCALL   ?ALLOC_XSTACK8
   2897            ZDSecMgrDevice_t device;
   2898          
   2899          
   2900            device.nwkAddr    = ind->devAddr;
   \   000009   EA           MOV     A,R2
   \   00000A   240C         ADD     A,#0xc
   \   00000C   F582         MOV     DPL,A
   \   00000E   EB           MOV     A,R3
   \   00000F   12....       LCALL   ??Subroutine137_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_271:
   \   000012   12....       LCALL   ?Subroutine33 & 0xFFFF
   2901            device.extAddr    = ind->devExtAddr;
   \                     ??CrossCallReturnLabel_206:
   \   000015   EA           MOV     A,R2
   \   000016   2404         ADD     A,#0x4
   \   000018   F8           MOV     R0,A
   \   000019   EB           MOV     A,R3
   \   00001A   3400         ADDC    A,#0x0
   \   00001C   F9           MOV     R1,A
   \   00001D   7402         MOV     A,#0x2
   \   00001F   12....       LCALL   ?XSTACK_DISP0_8
   \   000022   12....       LCALL   ?Subroutine17 & 0xFFFF
   2902            device.parentAddr = ind->srcAddr;
   \                     ??CrossCallReturnLabel_6:
   \   000025   12....       LCALL   ?XSTACK_DISP0_8
   \   000028   12....       LCALL   ?Subroutine15 & 0xFFFF
   2903          
   2904            //if ( ( ind->status == APSME_UD_SECURED_JOIN   ) ||
   2905            //     ( ind->status == APSME_UD_UNSECURED_JOIN )   )
   2906            //{
   2907            //  if ( ind->status == APSME_UD_SECURED_JOIN )
   2908            //  {
   2909            //    device.secure = TRUE;
   2910            //  }
   2911            //  else
   2912            //  {
   2913            //    device.secure = FALSE;
   2914            //  }
   2915          
   2916              // try to join this device
   2917              ZDSecMgrDeviceJoin( &device );
   \                     ??CrossCallReturnLabel_3:
   \   00002B   12....       LCALL   ??ZDSecMgrDeviceJoin?relay
   2918            //}
   2919          }
   \   00002E   02....       LJMP    ?Subroutine10 & 0xFFFF
   2920          
   2921          /******************************************************************************
   2922           * @fn          ZDSecMgrRemoveDeviceInd
   2923           *
   2924           * @brief       Process the ZDO_RemoveDeviceInd_t message.
   2925           *
   2926           * @param       ind - [in] ZDO_RemoveDeviceInd_t indication
   2927           *
   2928           * @return      none
   2929           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2930          void ZDSecMgrRemoveDeviceInd( ZDO_RemoveDeviceInd_t* ind )
   \                     ZDSecMgrRemoveDeviceInd:
   2931          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 10
   \   000005   74F6         MOV     A,#-0xa
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   2932            ZDSecMgrDevice_t device;
   2933          
   2934          
   2935            // only accept from Trust Center
   2936            if ( ind->srcAddr == APSME_TRUSTCENTER_NWKADDR )
   \   00000E   8E82         MOV     DPL,R6
   \   000010   8F83         MOV     DPH,R7
   \   000012   A3           INC     DPTR
   \   000013   A3           INC     DPTR
   \   000014   E0           MOVX    A,@DPTR
   \   000015   7002         JNZ     ??ZDSecMgrRemoveDeviceInd_0
   \   000017   A3           INC     DPTR
   \   000018   E0           MOVX    A,@DPTR
   \                     ??ZDSecMgrRemoveDeviceInd_0:
   \   000019   7027         JNZ     ??CrossCallReturnLabel_0
   2937            {
   2938              // look up NWK address
   2939              if ( APSME_LookupNwkAddr( ind->childExtAddr, &device.nwkAddr ) == TRUE )
   \   00001B                ; Setup parameters for call to function APSME_LookupNwkAddr
   \   00001B   85..82       MOV     DPL,?XSP + 0
   \   00001E   85..83       MOV     DPH,?XSP + 1
   \   000021   AC82         MOV     R4,DPL
   \   000023   AD83         MOV     R5,DPH
   \   000025   EE           MOV     A,R6
   \   000026   2404         ADD     A,#0x4
   \   000028   12....       LCALL   ?Subroutine46 & 0xFFFF
   \                     ??CrossCallReturnLabel_65:
   \   00002B   7015         JNZ     ??CrossCallReturnLabel_0
   2940              {
   2941                device.parentAddr = NLME_GetShortAddr();
   \   00002D                ; Setup parameters for call to function NLME_GetShortAddr
   \   00002D   12....       LCALL   ??NLME_GetShortAddr?relay
   \   000030   7404         MOV     A,#0x4
   \   000032   12....       LCALL   ?XSTACK_DISP0_8
   \   000035   EA           MOV     A,R2
   \   000036   F0           MOVX    @DPTR,A
   \   000037   A3           INC     DPTR
   \   000038   EB           MOV     A,R3
   \   000039   12....       LCALL   ??Subroutine134_0 & 0xFFFF
   2942                device.extAddr    = ind->childExtAddr;
   2943          
   2944                // remove device
   2945                ZDSecMgrDeviceRemove( &device );
   2946              }
   2947            }
   \                     ??CrossCallReturnLabel_268:
   \   00003C   12....       LCALL   ?XSTACK_DISP0_8
   \   00003F   12....       LCALL   ?Subroutine14 & 0xFFFF
   2948          }
   \                     ??CrossCallReturnLabel_0:
   \   000042   740A         MOV     A,#0xa
   \   000044   02....       LJMP    ??Subroutine132_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine14:
   \   000000   12....       LCALL   ?Subroutine85 & 0xFFFF
   \                     ??CrossCallReturnLabel_280:
   \   000003   12....       LCALL   ??ZDSecMgrDeviceRemove?relay
   \   000006   22           RET
   2949          
   2950          /******************************************************************************
   2951           * @fn          ZDSecMgrRequestKeyInd
   2952           *
   2953           * @brief       Process the ZDO_RequestKeyInd_t message.
   2954           *
   2955           * @param       ind - [in] ZDO_RequestKeyInd_t indication
   2956           *
   2957           * @return      none
   2958           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2959          void ZDSecMgrRequestKeyInd( ZDO_RequestKeyInd_t* ind )
   \                     ZDSecMgrRequestKeyInd:
   2960          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   2961            if ( ind->keyType == KEY_TYPE_NWK )
   \   000004   8A82         MOV     DPL,R2
   \   000006   8B83         MOV     DPH,R3
   \   000008   A3           INC     DPTR
   \   000009   A3           INC     DPTR
   \   00000A   A3           INC     DPTR
   \   00000B   A3           INC     DPTR
   \   00000C   E0           MOVX    A,@DPTR
   \   00000D   6401         XRL     A,#0x1
   \   00000F   6010         JZ      ??ZDSecMgrRequestKeyInd_0
   2962            {
   2963            }
   2964            else if ( ind->keyType == KEY_TYPE_APP_MASTER )
   \   000011   8A82         MOV     DPL,R2
   \   000013   8B83         MOV     DPH,R3
   \   000015   A3           INC     DPTR
   \   000016   A3           INC     DPTR
   \   000017   A3           INC     DPTR
   \   000018   A3           INC     DPTR
   \   000019   E0           MOVX    A,@DPTR
   \   00001A   6402         XRL     A,#0x2
   \   00001C   7003         JNZ     ??ZDSecMgrRequestKeyInd_0
   2965            {
   2966              ZDSecMgrAppKeyReq( ind );
   \   00001E                ; Setup parameters for call to function ZDSecMgrAppKeyReq
   \   00001E   12....       LCALL   ??ZDSecMgrAppKeyReq?relay
   2967            }
   2968            else if ( ind->keyType == KEY_TYPE_TC_LINK )
   2969            {
   2970            }
   2971            //else ignore
   2972          }
   \                     ??ZDSecMgrRequestKeyInd_0:
   \   000021   02....       LJMP    ??Subroutine125_0 & 0xFFFF
   2973          
   2974          /******************************************************************************
   2975           * @fn          ZDSecMgrSwitchKeyInd
   2976           *
   2977           * @brief       Process the ZDO_SwitchKeyInd_t message.
   2978           *
   2979           * @param       ind - [in] ZDO_SwitchKeyInd_t indication
   2980           *
   2981           * @return      none
   2982           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2983          void ZDSecMgrSwitchKeyInd( ZDO_SwitchKeyInd_t* ind )
   \                     ZDSecMgrSwitchKeyInd:
   2984          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   2985            SSP_SwitchNwkKey( ind->keySeqNum );
   \   000004                ; Setup parameters for call to function SSP_SwitchNwkKey
   \   000004   8A82         MOV     DPL,R2
   \   000006   8B83         MOV     DPH,R3
   \   000008   A3           INC     DPTR
   \   000009   A3           INC     DPTR
   \   00000A   A3           INC     DPTR
   \   00000B   A3           INC     DPTR
   \   00000C   E0           MOVX    A,@DPTR
   \   00000D   F9           MOV     R1,A
   \   00000E   12....       LCALL   ??SSP_SwitchNwkKey?relay
   2986          
   2987            // Save if nv
   2988            ZDApp_NVUpdate();
   \   000011                ; Setup parameters for call to function ZDApp_NVUpdate
   \   000011   12....       LCALL   ??ZDApp_NVUpdate?relay
   2989          }
   \   000014   02....       LJMP    ??Subroutine125_0 & 0xFFFF
   2990          
   2991          /******************************************************************************
   2992           * @fn          ZDSecMgrAuthenticateInd
   2993           *
   2994           * @brief       Process the ZDO_AuthenticateInd_t message.
   2995           *
   2996           * @param       ind - [in] ZDO_AuthenticateInd_t indication
   2997           *
   2998           * @return      none
   2999           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3000          void ZDSecMgrAuthenticateInd( ZDO_AuthenticateInd_t* ind )
   \                     ZDSecMgrAuthenticateInd:
   3001          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 20
   \   000005   74EC         MOV     A,#-0x14
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   3002            APSME_AuthenticateReq_t req;
   3003            AddrMgrEntry_t          entry;
   3004          
   3005          
   3006            // update the address manager
   3007            //---------------------------------------------------------------------------
   3008            // note:
   3009            // required for EA processing, but ultimately EA logic could also use the
   3010            // neighbor table to look up addresses -- also(IF using EA) the neighbor
   3011            // table is supposed to have authentication states for neighbors
   3012            //---------------------------------------------------------------------------
   3013            entry.user    = ADDRMGR_USER_SECURITY;
   \   00000E   7407         MOV     A,#0x7
   \   000010   12....       LCALL   ?XSTACK_DISP0_8
   \   000013   7402         MOV     A,#0x2
   \   000015   12....       LCALL   ?Subroutine22 & 0xFFFF
   3014            entry.nwkAddr = ind->aps.initNwkAddr;
   \                     ??CrossCallReturnLabel_19:
   \   000018   12....       LCALL   ?XSTACK_DISP0_8
   \   00001B   12....       LCALL   ??Subroutine113_0 & 0xFFFF
   3015            AddrMgrExtAddrSet( entry.extAddr, ind->aps.initExtAddr );
   \                     ??CrossCallReturnLabel_201:
   \   00001E                ; Setup parameters for call to function AddrMgrExtAddrSet
   \   00001E   EE           MOV     A,R6
   \   00001F   2404         ADD     A,#0x4
   \   000021   FC           MOV     R4,A
   \   000022   EF           MOV     A,R7
   \   000023   3400         ADDC    A,#0x0
   \   000025   FD           MOV     R5,A
   \   000026   740A         MOV     A,#0xa
   \   000028   12....       LCALL   ?XSTACK_DISP0_8
   \   00002B   AA82         MOV     R2,DPL
   \   00002D   AB83         MOV     R3,DPH
   \   00002F   12....       LCALL   ??AddrMgrExtAddrSet?relay
   3016          
   3017            if ( AddrMgrEntryUpdate( &entry ) == TRUE )
   \   000032                ; Setup parameters for call to function AddrMgrEntryUpdate
   \   000032   7407         MOV     A,#0x7
   \   000034   12....       LCALL   ?XSTACK_DISP0_8
   \   000037   AA82         MOV     R2,DPL
   \   000039   AB83         MOV     R3,DPH
   \   00003B   12....       LCALL   ??AddrMgrEntryUpdate?relay
   \   00003E   E9           MOV     A,R1
   \   00003F   6401         XRL     A,#0x1
   \   000041   7024         JNZ     ??ZDSecMgrAuthenticateInd_0
   3018            {
   3019              // set request fields
   3020              req.nwkAddr   = ind->aps.initNwkAddr;
   \   000043   12....       LCALL   ?Subroutine13 & 0xFFFF
   3021              req.extAddr   = ind->aps.initExtAddr;
   \                     ??CrossCallReturnLabel_267:
   \   000046   12....       LCALL   ?XSTACK_DISP0_8
   \   000049   12....       LCALL   ??Subroutine113_0 & 0xFFFF
   3022              req.action    = APSME_EA_ACCEPT;
   \                     ??CrossCallReturnLabel_202:
   \   00004C   7406         MOV     A,#0x6
   \   00004E   12....       LCALL   ?XSTACK_DISP0_8
   \   000051   7401         MOV     A,#0x1
   \   000053   F0           MOVX    @DPTR,A
   3023              req.challenge = ind->aps.challenge;
   \   000054   EE           MOV     A,R6
   \   000055   240C         ADD     A,#0xc
   \   000057   F8           MOV     R0,A
   \   000058   EF           MOV     A,R7
   \   000059   3400         ADDC    A,#0x0
   \   00005B   F9           MOV     R1,A
   \   00005C   7404         MOV     A,#0x4
   \   00005E   12....       LCALL   ?XSTACK_DISP0_8
   \   000061   12....       LCALL   ?Subroutine15 & 0xFFFF
   3024          
   3025              // start EA processing
   3026              APSME_AuthenticateReq( &req );
   3027            }
   \                     ??CrossCallReturnLabel_4:
   \   000064   12....       LCALL   ??APSME_AuthenticateReq?relay
   3028          }
   \                     ??ZDSecMgrAuthenticateInd_0:
   \   000067   7414         MOV     A,#0x14
   \   000069   02....       LJMP    ??Subroutine132_0 & 0xFFFF
   3029          
   3030          /******************************************************************************
   3031           * @fn          ZDSecMgrAuthenticateCfm
   3032           *
   3033           * @brief       Process the ZDO_AuthenticateCfm_t message.
   3034           *
   3035           * @param       cfm - [in] ZDO_AuthenticateCfm_t confirmation
   3036           *
   3037           * @return      none
   3038           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3039          void ZDSecMgrAuthenticateCfm( ZDO_AuthenticateCfm_t* cfm )
   \                     ZDSecMgrAuthenticateCfm:
   3040          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   3041            if ( cfm->aps.status == ZSuccess )
   \   000004   EA           MOV     A,R2
   \   000005   240B         ADD     A,#0xb
   \   000007   F582         MOV     DPL,A
   \   000009   EB           MOV     A,R3
   \   00000A   12....       LCALL   ??Subroutine137_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_272:
   \   00000D   E0           MOVX    A,@DPTR
   \   00000E   701F         JNZ     ??ZDSecMgrAuthenticateCfm_0
   3042            {
   3043              if ( ( cfm->aps.initiator == TRUE ) && ( devState == DEV_END_DEVICE_UNAUTH ) )
   \   000010   8A82         MOV     DPL,R2
   \   000012   8B83         MOV     DPH,R3
   \   000014   A3           INC     DPTR
   \   000015   A3           INC     DPTR
   \   000016   E0           MOVX    A,@DPTR
   \   000017   6401         XRL     A,#0x1
   \   000019   7014         JNZ     ??ZDSecMgrAuthenticateCfm_0
   \   00001B   90....       MOV     DPTR,#devState
   \   00001E   E0           MOVX    A,@DPTR
   \   00001F   6405         XRL     A,#0x5
   \   000021   700C         JNZ     ??ZDSecMgrAuthenticateCfm_0
   3044              {
   3045                // inform ZDO that device has been authenticated
   3046                osal_set_event ( ZDAppTaskID, ZDO_DEVICE_AUTH );
   \   000023                ; Setup parameters for call to function osal_set_event
   \   000023   7A80         MOV     R2,#-0x80
   \   000025   7B00         MOV     R3,#0x0
   \   000027   90....       MOV     DPTR,#ZDAppTaskID
   \   00002A   E0           MOVX    A,@DPTR
   \   00002B   F9           MOV     R1,A
   \   00002C   12....       LCALL   ??osal_set_event?relay
   3047              }
   3048            }
   3049          }
   \                     ??ZDSecMgrAuthenticateCfm_0:
   \   00002F   02....       LJMP    ??Subroutine125_0 & 0xFFFF
   3050          
   3051          #if ( ZG_BUILD_COORDINATOR_TYPE )
   3052          /******************************************************************************
   3053           * @fn          ZDSecMgrUpdateNwkKey
   3054           *
   3055           * @brief       Load a new NWK key and trigger a network wide update.
   3056           *
   3057           * @param       key       - [in] new NWK key
   3058           * @param       keySeqNum - [in] new NWK key sequence number
   3059           *
   3060           * @return      ZStatus_t
   3061           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3062          ZStatus_t ZDSecMgrUpdateNwkKey( uint8* key, uint8 keySeqNum, uint16 dstAddr )
   \                     ZDSecMgrUpdateNwkKey:
   3063          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 13
   \   000005   74F3         MOV     A,#-0xd
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   \   00000E   89..         MOV     ?V0 + 0,R1
   3064            ZStatus_t               status;
   3065            APSME_TransportKeyReq_t req;
   3066          
   3067            // initialize common elements of local variables
   3068            if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   3069              req.keyType   = KEY_TYPE_NWK_HIGH;
   3070            else
   3071              req.keyType   = KEY_TYPE_NWK;
   \   000010   7402         MOV     A,#0x2
   \   000012   12....       LCALL   ?XSTACK_DISP0_8
   \   000015   7401         MOV     A,#0x1
   \   000017   12....       LCALL   ?Subroutine27 & 0xFFFF
   3072          
   3073            req.dstAddr   = dstAddr;
   \                     ??CrossCallReturnLabel_29:
   \   00001A   EC           MOV     A,R4
   \   00001B   F0           MOVX    @DPTR,A
   \   00001C   A3           INC     DPTR
   \   00001D   ED           MOV     A,R5
   \   00001E   F0           MOVX    @DPTR,A
   3074            req.keySeqNum = keySeqNum;
   \   00001F   7403         MOV     A,#0x3
   \   000021   12....       LCALL   ?XSTACK_DISP0_8
   \   000024   E9           MOV     A,R1
   \   000025   F0           MOVX    @DPTR,A
   3075            req.key       = key;
   \   000026   7404         MOV     A,#0x4
   \   000028   12....       LCALL   ?XSTACK_DISP0_8
   \   00002B   EE           MOV     A,R6
   \   00002C   F0           MOVX    @DPTR,A
   \   00002D   A3           INC     DPTR
   \   00002E   EF           MOV     A,R7
   \   00002F   F0           MOVX    @DPTR,A
   3076            req.extAddr   = NULL;
   \   000030   7406         MOV     A,#0x6
   \   000032   12....       LCALL   ?XSTACK_DISP0_8
   \   000035   E4           CLR     A
   \   000036   F0           MOVX    @DPTR,A
   \   000037   A3           INC     DPTR
   \   000038   F0           MOVX    @DPTR,A
   3077            req.nwkSecure = TRUE;
   \   000039   740A         MOV     A,#0xa
   \   00003B   12....       LCALL   ?XSTACK_DISP0_8
   \   00003E   7401         MOV     A,#0x1
   \   000040   F0           MOVX    @DPTR,A
   3078            req.apsSecure = TRUE;
   \   000041   7409         MOV     A,#0x9
   \   000043   12....       LCALL   ?XSTACK_DISP0_8
   \   000046   7401         MOV     A,#0x1
   \   000048   F0           MOVX    @DPTR,A
   3079            req.tunnel    = NULL;
   \   000049   740B         MOV     A,#0xb
   \   00004B   12....       LCALL   ?XSTACK_DISP0_8
   \   00004E   E4           CLR     A
   \   00004F   F0           MOVX    @DPTR,A
   \   000050   A3           INC     DPTR
   \   000051   12....       LCALL   ??Subroutine127_0 & 0xFFFF
   3080          
   3081            if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   3082            {
   3083              ZDSecMgrEntry_t*        entry;
   3084              uint16                  index;
   3085              AddrMgrEntry_t          addrEntry;
   3086          
   3087              addrEntry.user = ADDRMGR_USER_SECURITY;
   3088          
   3089              status = ZFailure;
   3090          
   3091              // verify data is available
   3092              if ( ZDSecMgrEntries != NULL )
   3093              {
   3094                // find available entry
   3095                for ( index = 0; index < ZDSECMGR_ENTRY_MAX ; index++ )
   3096                {
   3097                  if ( ZDSecMgrEntries[index].ami != INVALID_NODE_ADDR )
   3098                  {
   3099                    // return successful result
   3100                    entry = &ZDSecMgrEntries[index];
   3101          
   3102                    // get NWK address
   3103                    addrEntry.index = entry->ami;
   3104                    if ( AddrMgrEntryGet( &addrEntry ) == TRUE )
   3105                    {
   3106                      req.dstAddr = addrEntry.nwkAddr;
   3107                      req.extAddr = addrEntry.extAddr;
   3108                      status = APSME_TransportKeyReq( &req );
   3109                    }
   3110                  }
   3111                }
   3112              }
   3113            }
   3114            else // ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_RESIDENTIAL )
   3115            {
   3116              status = APSME_TransportKeyReq( &req );
   \                     ??CrossCallReturnLabel_264:
   \   000054   12....       LCALL   ??APSME_TransportKeyReq?relay
   \   000057   E9           MOV     A,R1
   \   000058   F5..         MOV     ?V0 + 1,A
   3117            }
   3118          
   3119            SSP_UpdateNwkKey( key, keySeqNum );
   \   00005A                ; Setup parameters for call to function SSP_UpdateNwkKey
   \   00005A   A9..         MOV     R1,?V0 + 0
   \   00005C   EE           MOV     A,R6
   \   00005D   FA           MOV     R2,A
   \   00005E   EF           MOV     A,R7
   \   00005F   FB           MOV     R3,A
   \   000060   12....       LCALL   ??SSP_UpdateNwkKey?relay
   3120          
   3121            // Save if nv
   3122            ZDApp_NVUpdate();
   \   000063                ; Setup parameters for call to function ZDApp_NVUpdate
   \   000063   12....       LCALL   ??ZDApp_NVUpdate?relay
   3123          
   3124            return status;
   \   000066   A9..         MOV     R1,?V0 + 1
   \   000068   740D         MOV     A,#0xd
   \   00006A   02....       LJMP    ??Subroutine118_0 & 0xFFFF
   3125          }
   3126          #endif // ( ZG_BUILD_COORDINATOR_TYPE )
   3127          
   3128          #if ( ZG_BUILD_COORDINATOR_TYPE )
   3129          /******************************************************************************
   3130           * @fn          ZDSecMgrSwitchNwkKey
   3131           *
   3132           * @brief       Causes the NWK key to switch via a network wide command.
   3133           *
   3134           * @param       keySeqNum - [in] new NWK key sequence number
   3135           *
   3136           * @return      ZStatus_t
   3137           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3138          ZStatus_t ZDSecMgrSwitchNwkKey( uint8 keySeqNum, uint16 dstAddr )
   \                     ZDSecMgrSwitchNwkKey:
   3139          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 3
   \   000005   74FD         MOV     A,#-0x3
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   E9           MOV     A,R1
   \   00000B   FE           MOV     R6,A
   3140            ZStatus_t            status;
   3141            APSME_SwitchKeyReq_t req;
   3142          
   3143            // initialize common elements of local variables
   3144            req.dstAddr = dstAddr;
   \   00000C   12....       LCALL   ?Subroutine28 & 0xFFFF
   3145            req.keySeqNum = keySeqNum;
   \                     ??CrossCallReturnLabel_32:
   \   00000F   12....       LCALL   ?XSTACK_DISP0_8
   \   000012   E9           MOV     A,R1
   \   000013   12....       LCALL   ??Subroutine127_0 & 0xFFFF
   3146          
   3147            if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   3148            {
   3149              ZDSecMgrEntry_t*     entry;
   3150              uint16               index;
   3151              AddrMgrEntry_t       addrEntry;
   3152          
   3153              addrEntry.user = ADDRMGR_USER_SECURITY;
   3154          
   3155              status = ZFailure;
   3156          
   3157              // verify data is available
   3158              if ( ZDSecMgrEntries != NULL )
   3159              {
   3160                // find available entry
   3161                for ( index = 0; index < ZDSECMGR_ENTRY_MAX ; index++ )
   3162                {
   3163                  if ( ZDSecMgrEntries[index].ami != INVALID_NODE_ADDR )
   3164                  {
   3165                    // return successful result
   3166                    entry = &ZDSecMgrEntries[index];
   3167          
   3168                    // get NWK address
   3169                    addrEntry.index = entry->ami;
   3170          
   3171                    if ( AddrMgrEntryGet( &addrEntry ) == TRUE )
   3172                    {
   3173                      req.dstAddr = addrEntry.nwkAddr;
   3174                      status = APSME_SwitchKeyReq( &req );
   3175                    }
   3176                  }
   3177                }
   3178              }
   3179            }
   3180            else // ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_RESIDENTIAL )
   3181            {
   3182              status = APSME_SwitchKeyReq( &req );
   \                     ??CrossCallReturnLabel_265:
   \   000016   12....       LCALL   ??APSME_SwitchKeyReq?relay
   \   000019   E9           MOV     A,R1
   \   00001A   FF           MOV     R7,A
   3183            }
   3184          
   3185            SSP_SwitchNwkKey( keySeqNum );
   \   00001B                ; Setup parameters for call to function SSP_SwitchNwkKey
   \   00001B   EE           MOV     A,R6
   \   00001C   F9           MOV     R1,A
   \   00001D   12....       LCALL   ??SSP_SwitchNwkKey?relay
   3186          
   3187            // Save if nv
   3188            ZDApp_NVUpdate();
   \   000020                ; Setup parameters for call to function ZDApp_NVUpdate
   \   000020   12....       LCALL   ??ZDApp_NVUpdate?relay
   3189          
   3190            return status;
   \   000023   EF           MOV     A,R7
   \   000024   F9           MOV     R1,A
   \   000025   7403         MOV     A,#0x3
   \   000027   02....       LJMP    ??Subroutine132_0 & 0xFFFF
   3191          }
   3192          #endif // ( ZG_BUILD_COORDINATOR_TYPE )
   3193          
   3194          #if ( ZG_BUILD_JOINING_TYPE )
   3195          /******************************************************************************
   3196           * @fn          ZDSecMgrRequestAppKey
   3197           *
   3198           * @brief       Request an application key with partner.
   3199           *
   3200           * @param       partNwkAddr - [in] partner network address
   3201           *
   3202           * @return      ZStatus_t
   3203           */
   3204          ZStatus_t ZDSecMgrRequestAppKey( uint16 partNwkAddr )
   3205          {
   3206            ZStatus_t             status;
   3207            APSME_RequestKeyReq_t req;
   3208            uint8                 partExtAddr[Z_EXTADDR_LEN];
   3209          
   3210          
   3211            if ( AddrMgrExtAddrLookup( partNwkAddr, partExtAddr ) )
   3212            {
   3213              req.dstAddr = 0;
   3214              req.keyType = KEY_TYPE_APP_MASTER;
   3215              req.partExtAddr = partExtAddr;
   3216              status = APSME_RequestKeyReq( &req );
   3217            }
   3218            else
   3219            {
   3220              status = ZFailure;
   3221            }
   3222          
   3223            return status;
   3224          }
   3225          #endif // ( ZG_BUILD_JOINING_TYPE )
   3226          
   3227          #if ( ZG_BUILD_JOINING_TYPE )
   3228          /******************************************************************************
   3229           * @fn          ZDSecMgrSetupPartner
   3230           *
   3231           * @brief       Setup for application key partner.
   3232           *
   3233           * @param       partNwkAddr - [in] partner network address
   3234           *
   3235           * @return      ZStatus_t
   3236           */
   3237          ZStatus_t ZDSecMgrSetupPartner( uint16 partNwkAddr, uint8* partExtAddr )
   3238          {
   3239            AddrMgrEntry_t entry;
   3240            ZStatus_t      status;
   3241          
   3242            status = ZFailure;
   3243          
   3244            // update the address manager
   3245            entry.user    = ADDRMGR_USER_SECURITY;
   3246            entry.nwkAddr = partNwkAddr;
   3247            AddrMgrExtAddrSet( entry.extAddr, partExtAddr );
   3248          
   3249            if ( AddrMgrEntryUpdate( &entry ) == TRUE )
   3250            {
   3251              status = ZSuccess;
   3252          
   3253              // check for address discovery
   3254              if ( partNwkAddr == INVALID_NODE_ADDR )
   3255              {
   3256                status = ZDP_NwkAddrReq( partExtAddr, ZDP_ADDR_REQTYPE_SINGLE, 0, 0 );
   3257              }
   3258              else if ( !AddrMgrExtAddrValid( partExtAddr ) )
   3259              {
   3260                status = ZDP_IEEEAddrReq( partNwkAddr, ZDP_ADDR_REQTYPE_SINGLE, 0, 0 );
   3261              }
   3262            }
   3263          
   3264            return status;
   3265          }
   3266          #endif // ( ZG_BUILD_JOINING_TYPE )
   3267          
   3268          #if ( ZG_BUILD_COORDINATOR_TYPE )
   3269          /******************************************************************************
   3270           * @fn          ZDSecMgrAppKeyTypeSet
   3271           *
   3272           * @brief       Set application key type.
   3273           *
   3274           * @param       keyType - [in] application key type (KEY_TYPE_APP_MASTER@2 or
   3275           *                                                   KEY_TYPE_APP_LINK@3
   3276           *
   3277           * @return      ZStatus_t
   3278           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3279          ZStatus_t ZDSecMgrAppKeyTypeSet( uint8 keyType )
   \                     ZDSecMgrAppKeyTypeSet:
   3280          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   \   000004   E9           MOV     A,R1
   \   000005   FA           MOV     R2,A
   3281            if ( keyType == KEY_TYPE_APP_LINK )
   \   000006   7403         MOV     A,#0x3
   \   000008   6A           XRL     A,R2
   \   000009   7004         JNZ     ??ZDSecMgrAppKeyTypeSet_0
   3282            {
   3283              ZDSecMgrAppKeyType = KEY_TYPE_APP_LINK;
   \   00000B   7403         MOV     A,#0x3
   \   00000D   8002         SJMP    ??ZDSecMgrAppKeyTypeSet_1
   3284            }
   3285            else
   3286            {
   3287              ZDSecMgrAppKeyType = KEY_TYPE_APP_MASTER;
   \                     ??ZDSecMgrAppKeyTypeSet_0:
   \   00000F   7402         MOV     A,#0x2
   \                     ??ZDSecMgrAppKeyTypeSet_1:
   \   000011   90....       MOV     DPTR,#ZDSecMgrAppKeyType
   \   000014   F0           MOVX    @DPTR,A
   3288            }
   3289          
   3290            return ZSuccess;
   \   000015   7900         MOV     R1,#0x0
   \   000017   02....       LJMP    ??Subroutine125_0 & 0xFFFF
   3291          }
   3292          #endif
   3293          
   3294          /******************************************************************************
   3295           * ZigBee Device Security Manager - Stub Implementations
   3296           */
   3297          /******************************************************************************
   3298           * @fn          ZDSecMgrMasterKeyGet (stubs APSME_MasterKeyGet)
   3299           *
   3300           * @brief       Get MASTER key for specified EXT address.
   3301           *
   3302           * @param       extAddr - [in] EXT address
   3303           * @param       pKeyNvId - [out] MASTER key NV ID
   3304           *
   3305           * @return      ZStatus_t
   3306           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3307          ZStatus_t ZDSecMgrMasterKeyGet( uint8* extAddr, uint16* pKeyNvId )
   \                     APSME_MasterKeyGet:
   3308          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EC           MOV     A,R4
   \   00000B   FE           MOV     R6,A
   \   00000C   ED           MOV     A,R5
   \   00000D   FF           MOV     R7,A
   3309            ZStatus_t status;
   3310            uint16 ami;
   3311          
   3312          
   3313            // lookup entry for specified EXT address
   3314            status = ZDSecMgrExtAddrLookup( extAddr, &ami );
   \   00000E                ; Setup parameters for call to function ZDSecMgrExtAddrLookup
   \   00000E   85..82       MOV     DPL,?XSP + 0
   \   000011   85..83       MOV     DPH,?XSP + 1
   \   000014   AC82         MOV     R4,DPL
   \   000016   AD83         MOV     R5,DPH
   \   000018   12....       LCALL   ??ZDSecMgrExtAddrLookup?relay
   \   00001B   E9           MOV     A,R1
   \   00001C   F5..         MOV     ?V0 + 0,A
   3315          
   3316            if ( status == ZSuccess )
   \   00001E   7012         JNZ     ??APSME_MasterKeyGet_0
   3317            {
   3318              ZDSecMgrMasterKeyLookup( ami, pKeyNvId );
   \   000020                ; Setup parameters for call to function ZDSecMgrMasterKeyLookup
   \   000020   EE           MOV     A,R6
   \   000021   FC           MOV     R4,A
   \   000022   EF           MOV     A,R7
   \   000023   FD           MOV     R5,A
   \   000024   85..82       MOV     DPL,?XSP + 0
   \   000027   85..83       MOV     DPH,?XSP + 1
   \   00002A   12....       LCALL   ??Subroutine123_0 & 0xFFFF
   3319            }
   \                     ??CrossCallReturnLabel_236:
   \   00002D   12....       LCALL   ??ZDSecMgrMasterKeyLookup?relay
   \   000030   8008         SJMP    ??APSME_MasterKeyGet_1
   3320            else
   3321            {
   3322              *pKeyNvId = SEC_NO_KEY_NV_ID;
   \                     ??APSME_MasterKeyGet_0:
   \   000032   8E82         MOV     DPL,R6
   \   000034   8F83         MOV     DPH,R7
   \   000036   E4           CLR     A
   \   000037   F0           MOVX    @DPTR,A
   \   000038   A3           INC     DPTR
   \   000039   F0           MOVX    @DPTR,A
   3323            }
   3324          
   3325            return status;
   \                     ??APSME_MasterKeyGet_1:
   \   00003A   02....       LJMP    ?Subroutine1 & 0xFFFF
   3326          }
   3327          
   3328          /******************************************************************************
   3329           * @fn          ZDSecMgrLinkKeySet (stubs APSME_LinkKeySet)
   3330           *
   3331           * @brief       Set <APSME_LinkKeyData_t> for specified NWK address.
   3332           *
   3333           * @param       extAddr - [in] EXT address
   3334           * @param       data    - [in] APSME_LinkKeyData_t
   3335           *
   3336           * @return      ZStatus_t
   3337           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3338          ZStatus_t ZDSecMgrLinkKeySet( uint8* extAddr, uint8* key )
   \                     APSME_LinkKeySet:
   3339          {
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV     A,#-0x4
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EC           MOV     A,R4
   \   00000B   FE           MOV     R6,A
   \   00000C   ED           MOV     A,R5
   \   00000D   FF           MOV     R7,A
   3340            ZStatus_t status;
   3341            ZDSecMgrEntry_t* entry;
   3342            APSME_LinkKeyData_t *pApsLinkKey = NULL;
   3343            uint16 Index;
   3344          
   3345            // lookup entry index for specified EXT address
   3346            status = ZDSecMgrEntryLookupExtGetIndex( extAddr, &entry, &Index ); 
   \   00000E                ; Setup parameters for call to function ZDSecMgrEntryLookupExtGetIndex
   \   00000E   7402         MOV     A,#0x2
   \   000010   12....       LCALL   ?XSTACK_DISP0_8
   \   000013   8582..       MOV     ?V0 + 0,DPL
   \   000016   8583..       MOV     ?V0 + 1,DPH
   \   000019   78..         MOV     R0,#?V0 + 0
   \   00001B   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00001E   7402         MOV     A,#0x2
   \   000020   12....       LCALL   ?XSTACK_DISP0_8
   \   000023   AC82         MOV     R4,DPL
   \   000025   AD83         MOV     R5,DPH
   \   000027   12....       LCALL   ??ZDSecMgrEntryLookupExtGetIndex?relay
   \   00002A   7402         MOV     A,#0x2
   \   00002C   12....       LCALL   ?DEALLOC_XSTACK8
   \   00002F   E9           MOV     A,R1
   \   000030   F5..         MOV     ?V0 + 0,A
   3347          
   3348            if ( status == ZSuccess )
   \   000032   6003         JZ      $+5
   \   000034   02....       LJMP    ??APSME_LinkKeySet_0 & 0xFFFF
   3349            {
   3350              // point to NV item
   3351              entry->keyNvId = ZCD_NV_APS_LINK_KEY_DATA_START + Index;
   \   000037   7402         MOV     A,#0x2
   \   000039   12....       LCALL   ?XSTACK_DISP0_8
   \   00003C   E0           MOVX    A,@DPTR
   \   00003D   2401         ADD     A,#0x1
   \   00003F   F8           MOV     R0,A
   \   000040   A3           INC     DPTR
   \   000041   E0           MOVX    A,@DPTR
   \   000042   3402         ADDC    A,#0x2
   \   000044   F9           MOV     R1,A
   \   000045   85..82       MOV     DPL,?XSP + 0
   \   000048   85..83       MOV     DPH,?XSP + 1
   \   00004B   12....       LCALL   ?Subroutine73 & 0xFFFF
   \                     ??CrossCallReturnLabel_109:
   \   00004E   A3           INC     DPTR
   \   00004F   A3           INC     DPTR
   \   000050   12....       LCALL   ??Subroutine113_0 & 0xFFFF
   3352          
   3353              pApsLinkKey = (APSME_LinkKeyData_t *)osal_mem_alloc(sizeof(APSME_LinkKeyData_t));
   \                     ??CrossCallReturnLabel_203:
   \   000053                ; Setup parameters for call to function osal_mem_alloc
   \   000053   12....       LCALL   ?Subroutine75 & 0xFFFF
   3354          
   3355              if (pApsLinkKey != NULL)
   \                     ??CrossCallReturnLabel_114:
   \   000056   7001         JNZ     ??APSME_LinkKeySet_1
   \   000058   EB           MOV     A,R3
   \                     ??APSME_LinkKeySet_1:
   \   000059   7003         JNZ     $+5
   \   00005B   02....       LJMP    ??APSME_LinkKeySet_0 & 0xFFFF
   3356              {
   3357                // read the key form NV, keyNvId must be ZCD_NV_APS_LINK_KEY_DATA_START based
   3358                osal_nv_read( entry->keyNvId, 0, 
   3359                             sizeof(APSME_LinkKeyData_t), pApsLinkKey );
   \   00005E                ; Setup parameters for call to function osal_nv_read
   \   00005E   78..         MOV     R0,#?V0 + 2
   \   000060   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000063   75..18       MOV     ?V0 + 4,#0x18
   \   000066   75..00       MOV     ?V0 + 5,#0x0
   \   000069   78..         MOV     R0,#?V0 + 4
   \   00006B   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00006E   7C00         MOV     R4,#0x0
   \   000070   7D00         MOV     R5,#0x0
   \   000072   7404         MOV     A,#0x4
   \   000074   12....       LCALL   ?XSTACK_DISP0_8
   \   000077   12....       LCALL   ??Subroutine141_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_291:
   \   00007A   12....       LCALL   ?Subroutine52 & 0xFFFF
   \                     ??CrossCallReturnLabel_74:
   \   00007D   12....       LCALL   ?DEALLOC_XSTACK8
   3360                
   3361                // set new values of the key 
   3362                osal_memcpy( pApsLinkKey->key, key, SEC_KEY_LEN );
   \   000080                ; Setup parameters for call to function osal_memcpy
   \   000080   8E..         MOV     ?V0 + 4,R6
   \   000082   8F..         MOV     ?V0 + 5,R7
   \   000084   75..00       MOV     ?V0 + 6,#0x0
   \   000087   78..         MOV     R0,#?V0 + 4
   \   000089   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   00008C   7C10         MOV     R4,#0x10
   \   00008E   7D00         MOV     R5,#0x0
   \   000090   AA..         MOV     R2,?V0 + 2
   \   000092   AB..         MOV     R3,?V0 + 3
   \   000094   12....       LCALL   ??Subroutine121_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_229:
   \   000097   12....       LCALL   ?DEALLOC_XSTACK8
   3363                pApsLinkKey->rxFrmCntr = 0;
   \   00009A   90....       MOV     DPTR,#__Constant_0
   \   00009D   78..         MOV     R0,#?V0 + 4
   \   00009F   12....       LCALL   ?L_MOV_X
   \   0000A2   12....       LCALL   ?Subroutine42 & 0xFFFF
   \                     ??CrossCallReturnLabel_289:
   \   0000A5   12....       LCALL   ?L_MOV_TO_X
   3364                pApsLinkKey->txFrmCntr = 0;
   \   0000A8   90....       MOV     DPTR,#__Constant_0
   \   0000AB   78..         MOV     R0,#?V0 + 4
   \   0000AD   12....       LCALL   ?L_MOV_X
   \   0000B0   E5..         MOV     A,?V0 + 2
   \   0000B2   2410         ADD     A,#0x10
   \   0000B4   12....       LCALL   ??Subroutine139_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_287:
   \   0000B7   12....       LCALL   ?L_MOV_TO_X
   3365                
   3366                osal_nv_write( entry->keyNvId, 0, 
   3367                              sizeof(APSME_LinkKeyData_t), pApsLinkKey );
   \   0000BA                ; Setup parameters for call to function osal_nv_write
   \   0000BA   78..         MOV     R0,#?V0 + 2
   \   0000BC   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000BF   75..18       MOV     ?V0 + 4,#0x18
   \   0000C2   75..00       MOV     ?V0 + 5,#0x0
   \   0000C5   78..         MOV     R0,#?V0 + 4
   \   0000C7   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000CA   7C00         MOV     R4,#0x0
   \   0000CC   7D00         MOV     R5,#0x0
   \   0000CE   7404         MOV     A,#0x4
   \   0000D0   12....       LCALL   ?XSTACK_DISP0_8
   \   0000D3   12....       LCALL   ?Subroutine56 & 0xFFFF
   \                     ??CrossCallReturnLabel_80:
   \   0000D6   12....       LCALL   ??Subroutine109_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_176:
   \   0000D9   12....       LCALL   ?DEALLOC_XSTACK8
   3368                
   3369                // clear copy of key in RAM 
   3370                osal_memset(pApsLinkKey, 0x00, sizeof(APSME_LinkKeyData_t));
   \   0000DC                ; Setup parameters for call to function osal_memset
   \   0000DC   12....       LCALL   ?Subroutine40 & 0xFFFF
   3371                
   3372                osal_mem_free(pApsLinkKey);
   \                     ??CrossCallReturnLabel_56:
   \   0000DF   12....       LCALL   ?Subroutine57 & 0xFFFF
   \                     ??CrossCallReturnLabel_292:
   \   0000E2   12....       LCALL   ?Subroutine66 & 0xFFFF
   \                     ??CrossCallReturnLabel_100:
   \   0000E5   75F009       MOV     B,#0x9
   \   0000E8   A4           MUL     AB
   \   0000E9   F8           MOV     R0,A
   \   0000EA   AAF0         MOV     R2,B
   \   0000EC   75F009       MOV     B,#0x9
   \   0000EF   E9           MOV     A,R1
   \   0000F0   A4           MUL     AB
   \   0000F1   2A           ADD     A,R2
   \   0000F2   F9           MOV     R1,A
   \   0000F3   E8           MOV     A,R0
   \   0000F4   24..         ADD     A,#(ApsLinkKeyFrmCntr & 0xff)
   \   0000F6   FA           MOV     R2,A
   \   0000F7   E9           MOV     A,R1
   \   0000F8   34..         ADDC    A,#((ApsLinkKeyFrmCntr >> 8) & 0xff)
   \   0000FA   FB           MOV     R3,A
   \   0000FB   90....       MOV     DPTR,#__Constant_0
   \   0000FE   78..         MOV     R0,#?V0 + 4
   \   000100   12....       LCALL   ?L_MOV_X
   \   000103   EA           MOV     A,R2
   \   000104   24F7         ADD     A,#-0x9
   \   000106   F582         MOV     DPL,A
   \   000108   EB           MOV     A,R3
   \   000109   34ED         ADDC    A,#-0x13
   \   00010B   F583         MOV     DPH,A
   \   00010D   78..         MOV     R0,#?V0 + 4
   \   00010F   12....       LCALL   ?L_MOV_TO_X
   3373                
   3374                // set initial values for counters in RAM
   3375                ApsLinkKeyFrmCntr[entry->keyNvId - ZCD_NV_APS_LINK_KEY_DATA_START].txFrmCntr = 0;
   3376                ApsLinkKeyFrmCntr[entry->keyNvId - ZCD_NV_APS_LINK_KEY_DATA_START].rxFrmCntr = 0;
   \   000112   90....       MOV     DPTR,#__Constant_0
   \   000115   78..         MOV     R0,#?V0 + 4
   \   000117   12....       LCALL   ?L_MOV_X
   \   00011A   EA           MOV     A,R2
   \   00011B   24FB         ADD     A,#-0x5
   \   00011D   F582         MOV     DPL,A
   \   00011F   EB           MOV     A,R3
   \   000120   34ED         ADDC    A,#-0x13
   \   000122   F583         MOV     DPH,A
   \   000124   78..         MOV     R0,#?V0 + 4
   \   000126   12....       LCALL   ?L_MOV_TO_X
   3377              }
   3378            }
   3379          
   3380            return status;
   \                     ??APSME_LinkKeySet_0:
   \   000129   A9..         MOV     R1,?V0 + 0
   \   00012B   7404         MOV     A,#0x4
   \   00012D   12....       LCALL   ?DEALLOC_XSTACK8
   \   000130                REQUIRE ?Subroutine7
   \   000130                ; // Fall through to label ?Subroutine7
   3381          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine7:
   \   000000   7F08         MOV     R7,#0x8
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine42:
   \   000000   E5..         MOV     A,?V0 + 2
   \   000002   2414         ADD     A,#0x14
   \   000004                REQUIRE ??Subroutine139_0
   \   000004                ; // Fall through to label ??Subroutine139_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine139_0:
   \   000000   F582         MOV     DPL,A
   \   000002   E5..         MOV     A,?V0 + 3
   \   000004                REQUIRE ??Subroutine140_0
   \   000004                ; // Fall through to label ??Subroutine140_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine140_0:
   \   000000   3400         ADDC    A,#0x0
   \   000002   F583         MOV     DPH,A
   \   000004   78..         MOV     R0,#?V0 + 4
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine57:
   \   000000   85..82       MOV     DPL,?XSP + 0
   \   000003   85..83       MOV     DPH,?XSP + 1
   \   000006                REQUIRE ??Subroutine141_0
   \   000006                ; // Fall through to label ??Subroutine141_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine141_0:
   \   000000   12....       LCALL   ?Subroutine95 & 0xFFFF
   \                     ??CrossCallReturnLabel_299:
   \   000003   A3           INC     DPTR
   \   000004   A3           INC     DPTR
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine56:
   \   000000   12....       LCALL   ?Subroutine95 & 0xFFFF
   \                     ??CrossCallReturnLabel_297:
   \   000003   A3           INC     DPTR
   \   000004   A3           INC     DPTR
   \   000005   12....       LCALL   ??Subroutine117_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_309:
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine73:
   \   000000   12....       LCALL   ??Subroutine117_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_310:
   \   000003   F583         MOV     DPH,A
   \   000005   8A82         MOV     DPL,R2
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine40:
   \   000000   7C18         MOV     R4,#0x18
   \   000002   7D00         MOV     R5,#0x0
   \   000004   7900         MOV     R1,#0x0
   \   000006   AA..         MOV     R2,?V0 + 2
   \   000008   AB..         MOV     R3,?V0 + 3
   \   00000A   12....       LCALL   ??osal_memset?relay
   \   00000D                ; Setup parameters for call to function osal_mem_free
   \   00000D                ; Setup parameters for call to function osal_mem_free
   \   00000D   AA..         MOV     R2,?V0 + 2
   \   00000F   AB..         MOV     R3,?V0 + 3
   \   000011   12....       LCALL   ??osal_mem_free?relay
   \   000014   22           RET
   3382          
   3383          /******************************************************************************
   3384           * @fn          ZDSecMgrAuthenticationSet
   3385           *
   3386           * @brief       Mark the specific device as authenticated or not
   3387           *
   3388           * @param       extAddr - [in] EXT address
   3389           * @param       option  - [in] authenticated or not
   3390           *
   3391           * @return      ZStatus_t
   3392           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3393          ZStatus_t ZDSecMgrAuthenticationSet( uint8* extAddr, ZDSecMgr_Authentication_Option option )
   \                     ZDSecMgrAuthenticationSet:
   3394          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   E9           MOV     A,R1
   \   00000B   FE           MOV     R6,A
   3395            ZStatus_t        status;
   3396            ZDSecMgrEntry_t* entry;
   3397          
   3398          
   3399            // lookup entry index for specified EXT address
   3400            status = ZDSecMgrEntryLookupExt( extAddr, &entry );
   \   00000C                ; Setup parameters for call to function ZDSecMgrEntryLookupExt
   \   00000C   85..82       MOV     DPL,?XSP + 0
   \   00000F   85..83       MOV     DPH,?XSP + 1
   \   000012   AC82         MOV     R4,DPL
   \   000014   AD83         MOV     R5,DPH
   \   000016   12....       LCALL   ??ZDSecMgrEntryLookupExt?relay
   \   000019   E9           MOV     A,R1
   3401          
   3402            if ( status == ZSuccess )
   \   00001A   7007         JNZ     ??ZDSecMgrAuthenticationSet_0
   3403            {
   3404              entry->authenticateOption = option;
   \   00001C   12....       LCALL   ?Subroutine57 & 0xFFFF
   3405            }
   \                     ??CrossCallReturnLabel_293:
   \   00001F   A3           INC     DPTR
   \   000020   A3           INC     DPTR
   \   000021   EE           MOV     A,R6
   \   000022   F0           MOVX    @DPTR,A
   3406          
   3407            return status;
   \                     ??ZDSecMgrAuthenticationSet_0:
   \   000023   02....       LJMP    ??Subroutine131_0 & 0xFFFF
   3408          }
   3409          
   3410          /******************************************************************************
   3411           * @fn          ZDSecMgrAuthenticationCheck
   3412           *
   3413           * @brief       Check if the specific device has been authenticated or not
   3414           *              For non-trust center device, always return true
   3415           *
   3416           * @param       shortAddr - [in] short address
   3417           *
   3418           * @return      TRUE @ authenticated with CBKE
   3419           *              FALSE @ not authenticated
   3420           */
   3421          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3422          uint8 ZDSecMgrAuthenticationCheck( uint16 shortAddr )
   \                     ZDSecMgrAuthenticationCheck:
   3423          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   3424          #if defined (TC_LINKKEY_JOIN)
   3425          
   3426            ZDSecMgrEntry_t* entry;
   3427            uint8 extAddr[Z_EXTADDR_LEN];
   3428          
   3429            // If the local device is not the trust center, always return TRUE
   3430            if ( NLME_GetShortAddr() != TCshortAddr )
   3431            {
   3432              return TRUE;
   3433            }
   3434            // Otherwise, check the authentication option
   3435            else if ( AddrMgrExtAddrLookup( shortAddr, extAddr ) )
   3436            {
   3437              // lookup entry index for specified EXT address
   3438              if ( ZDSecMgrEntryLookupExt( extAddr, &entry ) == ZSuccess )
   3439              {
   3440                if ( entry->authenticateOption != ZDSecMgr_Not_Authenticated )
   3441                {
   3442                  return TRUE;
   3443                }
   3444                else
   3445                {
   3446                  return FALSE;
   3447                }
   3448              }
   3449            }
   3450            return FALSE;
   3451          
   3452          #else
   3453            (void)shortAddr;  // Intentionally unreferenced parameter
   3454            
   3455            // For non AMI/SE Profile, perform no check and always return true.
   3456            return TRUE;
   \   000000   7901         MOV     R1,#0x1
   \   000002   02....       LJMP    ?BRET
   3457          
   3458          #endif // TC_LINKKEY_JOIN
   3459          }
   3460          
   3461          
   3462          /******************************************************************************
   3463           * @fn          ZDSecMgrLinkKeyNVIdGet (stubs APSME_LinkKeyNVIdGet)
   3464           *
   3465           * @brief       Get Key NV ID for specified NWK address.
   3466           *
   3467           * @param       extAddr - [in] EXT address
   3468           * @param       keyNvId - [out] NV ID
   3469           *
   3470           * @return      ZStatus_t
   3471           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3472          ZStatus_t ZDSecMgrLinkKeyNVIdGet(uint8* extAddr, uint16 *pKeyNvId)
   \                     APSME_LinkKeyNVIdGet:
   3473          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EC           MOV     A,R4
   \   00000B   FE           MOV     R6,A
   \   00000C   ED           MOV     A,R5
   \   00000D   FF           MOV     R7,A
   3474            ZStatus_t status;
   3475            ZDSecMgrEntry_t* entry;
   3476          
   3477            // lookup entry index for specified NWK address
   3478            status = ZDSecMgrEntryLookupExt( extAddr, &entry );
   \   00000E                ; Setup parameters for call to function ZDSecMgrEntryLookupExt
   \   00000E   85..82       MOV     DPL,?XSP + 0
   \   000011   85..83       MOV     DPH,?XSP + 1
   \   000014   AC82         MOV     R4,DPL
   \   000016   AD83         MOV     R5,DPH
   \   000018   12....       LCALL   ??ZDSecMgrEntryLookupExt?relay
   \   00001B   E9           MOV     A,R1
   3479          
   3480            if ( status == ZSuccess )
   \   00001C   7014         JNZ     ??APSME_LinkKeyNVIdGet_0
   3481            {
   3482              // return the index to the NV table
   3483              *pKeyNvId = entry->keyNvId;
   \   00001E   85..82       MOV     DPL,?XSP + 0
   \   000021   85..83       MOV     DPH,?XSP + 1
   \   000024   12....       LCALL   ?Subroutine56 & 0xFFFF
   3484            }
   \                     ??CrossCallReturnLabel_81:
   \   000027   FB           MOV     R3,A
   \   000028   8E82         MOV     DPL,R6
   \   00002A   8F83         MOV     DPH,R7
   \   00002C   EA           MOV     A,R2
   \   00002D   F0           MOVX    @DPTR,A
   \   00002E   A3           INC     DPTR
   \   00002F   EB           MOV     A,R3
   \   000030   8007         SJMP    ??APSME_LinkKeyNVIdGet_1
   3485            else
   3486            {
   3487              *pKeyNvId = SEC_NO_KEY_NV_ID;
   \                     ??APSME_LinkKeyNVIdGet_0:
   \   000032   8E82         MOV     DPL,R6
   \   000034   8F83         MOV     DPH,R7
   \   000036   E4           CLR     A
   \   000037   F0           MOVX    @DPTR,A
   \   000038   A3           INC     DPTR
   \                     ??APSME_LinkKeyNVIdGet_1:
   \   000039   F0           MOVX    @DPTR,A
   3488            }
   3489          
   3490            return status;
   \   00003A   02....       LJMP    ??Subroutine131_0 & 0xFFFF
   3491          }
   3492          
   3493          /******************************************************************************
   3494           * @fn          ZDSecMgrIsLinkKeyValid (stubs APSME_IsLinkKeyValid)
   3495           *
   3496           * @brief       Verifies if Link Key in NV has been set.
   3497           *
   3498           * @param       extAddr - [in] EXT address
   3499           *
   3500           * @return      TRUE - Link Key has been established
   3501           *              FALSE - Link Key in NV has default value.
   3502           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3503          uint8 ZDSecMgrIsLinkKeyValid(uint8* extAddr)
   \                     APSME_IsLinkKeyValid:
   3504          {
   \   000000   74F1         MOV     A,#-0xf
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 15
   \   000005                ; Auto size: 18
   \   000005   74EE         MOV     A,#-0x12
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   3505            APSME_LinkKeyData_t *pKeyData = NULL;
   3506            uint16 apsLinkKeyNvId;
   3507            uint8 nullKey[SEC_KEY_LEN];
   3508            uint8 status = FALSE;
   \   00000E   75..00       MOV     ?V0 + 0,#0x0
   3509          
   3510            // initialize default vealue to compare to
   3511            osal_memset(nullKey, 0x00, SEC_KEY_LEN);
   \   000011                ; Setup parameters for call to function osal_memset
   \   000011   7C10         MOV     R4,#0x10
   \   000013   7D00         MOV     R5,#0x0
   \   000015   7900         MOV     R1,#0x0
   \   000017   7402         MOV     A,#0x2
   \   000019   12....       LCALL   ?XSTACK_DISP0_8
   \   00001C   12....       LCALL   ?Subroutine41 & 0xFFFF
   3512          
   3513            // check for APS link NV ID
   3514            APSME_LinkKeyNVIdGet( extAddr, &apsLinkKeyNvId );
   \                     ??CrossCallReturnLabel_58:
   \   00001F   AC82         MOV     R4,DPL
   \   000021   AD83         MOV     R5,DPH
   \   000023   EE           MOV     A,R6
   \   000024   FA           MOV     R2,A
   \   000025   EF           MOV     A,R7
   \   000026   FB           MOV     R3,A
   \   000027   12....       LCALL   ??APSME_LinkKeyNVIdGet?relay
   3515          
   3516            if (apsLinkKeyNvId != SEC_NO_KEY_NV_ID )
   \   00002A   85..82       MOV     DPL,?XSP + 0
   \   00002D   85..83       MOV     DPH,?XSP + 1
   \   000030   E0           MOVX    A,@DPTR
   \   000031   7002         JNZ     ??APSME_IsLinkKeyValid_0
   \   000033   A3           INC     DPTR
   \   000034   E0           MOVX    A,@DPTR
   \                     ??APSME_IsLinkKeyValid_0:
   \   000035   605D         JZ      ??APSME_IsLinkKeyValid_1
   3517            {
   3518              pKeyData = (APSME_LinkKeyData_t *)osal_mem_alloc(sizeof(APSME_LinkKeyData_t));
   \   000037                ; Setup parameters for call to function osal_mem_alloc
   \   000037   12....       LCALL   ?Subroutine75 & 0xFFFF
   3519              
   3520              if (pKeyData != NULL)
   \                     ??CrossCallReturnLabel_115:
   \   00003A   7001         JNZ     ??APSME_IsLinkKeyValid_2
   \   00003C   EB           MOV     A,R3
   \                     ??APSME_IsLinkKeyValid_2:
   \   00003D   6055         JZ      ??APSME_IsLinkKeyValid_1
   3521              {
   3522                // retrieve key from NV
   3523                if ( osal_nv_read( apsLinkKeyNvId, 0, 
   3524                                  sizeof(APSME_LinkKeyData_t), pKeyData) == ZSUCCESS)
   \   00003F                ; Setup parameters for call to function osal_nv_read
   \   00003F   78..         MOV     R0,#?V0 + 2
   \   000041   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000044   75..18       MOV     ?V0 + 4,#0x18
   \   000047   75..00       MOV     ?V0 + 5,#0x0
   \   00004A   78..         MOV     R0,#?V0 + 4
   \   00004C   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00004F   7C00         MOV     R4,#0x0
   \   000051   7D00         MOV     R5,#0x0
   \   000053   7404         MOV     A,#0x4
   \   000055   12....       LCALL   ?XSTACK_DISP0_8
   \   000058   12....       LCALL   ?Subroutine52 & 0xFFFF
   \                     ??CrossCallReturnLabel_75:
   \   00005B   12....       LCALL   ?DEALLOC_XSTACK8
   \   00005E   E9           MOV     A,R1
   \   00005F   7033         JNZ     ??APSME_IsLinkKeyValid_1
   3525                {
   3526                  // if stored key is different than default value, then a key has been established
   3527                  if (!osal_memcmp(pKeyData, nullKey, SEC_KEY_LEN))
   \   000061                ; Setup parameters for call to function osal_memcmp
   \   000061   7402         MOV     A,#0x2
   \   000063   12....       LCALL   ?XSTACK_DISP0_8
   \   000066   A982         MOV     R1,DPL
   \   000068   AA83         MOV     R2,DPH
   \   00006A   89..         MOV     ?V0 + 4,R1
   \   00006C   8A..         MOV     ?V0 + 5,R2
   \   00006E   75..00       MOV     ?V0 + 6,#0x0
   \   000071   78..         MOV     R0,#?V0 + 4
   \   000073   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000076   7C10         MOV     R4,#0x10
   \   000078   7D00         MOV     R5,#0x0
   \   00007A   85..82       MOV     DPL,?V0 + 2
   \   00007D   85..83       MOV     DPH,?V0 + 3
   \   000080   A982         MOV     R1,DPL
   \   000082   AA83         MOV     R2,DPH
   \   000084   7B00         MOV     R3,#0x0
   \   000086   12....       LCALL   ??osal_memcmp?relay
   \   000089   7403         MOV     A,#0x3
   \   00008B   12....       LCALL   ?DEALLOC_XSTACK8
   \   00008E   E9           MOV     A,R1
   \   00008F   7003         JNZ     ??APSME_IsLinkKeyValid_1
   3528                  {
   3529                    status = TRUE;
   \   000091   75..01       MOV     ?V0 + 0,#0x1
   3530                  }
   3531                }
   3532              }
   3533            }
   3534          
   3535            return status;
   \                     ??APSME_IsLinkKeyValid_1:
   \   000094   A9..         MOV     R1,?V0 + 0
   \   000096   02....       LJMP    ?Subroutine3 & 0xFFFF
   3536          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine41:
   \   000000   AA82         MOV     R2,DPL
   \   000002   AB83         MOV     R3,DPH
   \   000004   12....       LCALL   ??osal_memset?relay
   \   000007                ; Setup parameters for call to function APSME_LinkKeyNVIdGet
   \   000007                ; Setup parameters for call to function osal_nv_item_init
   \   000007   85..82       MOV     DPL,?XSP + 0
   \   00000A   85..83       MOV     DPH,?XSP + 1
   \   00000D   22           RET
   3537          
   3538          /******************************************************************************
   3539           * @fn          ZDSecMgrKeyFwdToChild (stubs APSME_KeyFwdToChild)
   3540           *
   3541           * @brief       Verify and process key transportation to child.
   3542           *
   3543           * @param       ind - [in] APSME_TransportKeyInd_t
   3544           *
   3545           * @return      uint8 - success(TRUE:FALSE)
   3546           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3547          uint8 ZDSecMgrKeyFwdToChild( APSME_TransportKeyInd_t* ind )
   \                     APSME_KeyFwdToChild:
   3548          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   3549            uint8 success;
   3550          
   3551            success = FALSE;
   \   000005   7E00         MOV     R6,#0x0
   3552          
   3553            // verify from Trust Center
   3554            if ( ind->srcAddr == APSME_TRUSTCENTER_NWKADDR )
   \   000007   8A82         MOV     DPL,R2
   \   000009   8B83         MOV     DPH,R3
   \   00000B   E0           MOVX    A,@DPTR
   \   00000C   7002         JNZ     ??APSME_KeyFwdToChild_0
   \   00000E   A3           INC     DPTR
   \   00000F   E0           MOVX    A,@DPTR
   \                     ??APSME_KeyFwdToChild_0:
   \   000010   7032         JNZ     ??APSME_KeyFwdToChild_1
   3555            {
   3556              success = TRUE;
   \   000012   0E           INC     R6
   3557          
   3558              // check for initial NWK key
   3559              if ( ( ind->keyType == KEY_TYPE_NWK      ) ||
   3560                   ( ind->keyType == 6                 ) ||
   3561                   ( ind->keyType == KEY_TYPE_NWK_HIGH )    )
   \   000013   8A82         MOV     DPL,R2
   \   000015   8B83         MOV     DPH,R3
   \   000017   A3           INC     DPTR
   \   000018   A3           INC     DPTR
   \   000019   E0           MOVX    A,@DPTR
   \   00001A   6401         XRL     A,#0x1
   \   00001C   6016         JZ      ??APSME_KeyFwdToChild_2
   \   00001E   8A82         MOV     DPL,R2
   \   000020   8B83         MOV     DPH,R3
   \   000022   A3           INC     DPTR
   \   000023   A3           INC     DPTR
   \   000024   E0           MOVX    A,@DPTR
   \   000025   6406         XRL     A,#0x6
   \   000027   600B         JZ      ??APSME_KeyFwdToChild_2
   \   000029   8A82         MOV     DPL,R2
   \   00002B   8B83         MOV     DPH,R3
   \   00002D   A3           INC     DPTR
   \   00002E   A3           INC     DPTR
   \   00002F   E0           MOVX    A,@DPTR
   \   000030   6405         XRL     A,#0x5
   \   000032   7010         JNZ     ??APSME_KeyFwdToChild_1
   3562              {
   3563                // set association status to authenticated
   3564                ZDSecMgrAssocDeviceAuth( AssocGetWithExt( ind->dstExtAddr ) );
   \                     ??APSME_KeyFwdToChild_2:
   \   000034                ; Setup parameters for call to function ZDSecMgrAssocDeviceAuth
   \   000034                ; Setup parameters for call to function AssocGetWithExt
   \   000034   8A82         MOV     DPL,R2
   \   000036   8B83         MOV     DPH,R3
   \   000038   A3           INC     DPTR
   \   000039   A3           INC     DPTR
   \   00003A   A3           INC     DPTR
   \   00003B   A3           INC     DPTR
   \   00003C   A3           INC     DPTR
   \   00003D   A3           INC     DPTR
   \   00003E   12....       LCALL   ?Subroutine70 & 0xFFFF
   3565              }
   3566            }
   \                     ??CrossCallReturnLabel_106:
   \   000041   12....       LCALL   ??ZDSecMgrAssocDeviceAuth?relay
   3567          
   3568            return success;
   \                     ??APSME_KeyFwdToChild_1:
   \   000044   EE           MOV     A,R6
   \   000045   F9           MOV     R1,A
   \   000046   02....       LJMP    ??Subroutine133_0 & 0xFFFF
   3569          }
   3570          
   3571          /******************************************************************************
   3572           * @fn          ZDSecMgrAddLinkKey
   3573           *
   3574           * @brief       Add the application link key to ZDSecMgr. Also mark the device
   3575           *              as authenticated in the authenticateOption. Note that this function
   3576           *              is hardwared to CBKE right now.
   3577           *
   3578           * @param       shortAddr - short address of the partner device
   3579           * @param       extAddr - extended address of the partner device
   3580           * @param       key - link key
   3581           *
   3582           * @return      ZStatus_t
   3583           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3584          ZStatus_t ZDSecMgrAddLinkKey( uint16 shortAddr, uint8 *extAddr, uint8 *key)
   \                     ZDSecMgrAddLinkKey:
   3585          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV     A,#-0x4
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EC           MOV     A,R4
   \   00000B   FE           MOV     R6,A
   \   00000C   ED           MOV     A,R5
   \   00000D   FF           MOV     R7,A
   \   00000E   7410         MOV     A,#0x10
   \   000010   12....       LCALL   ?XSTACK_DISP0_8
   \   000013   E0           MOVX    A,@DPTR
   \   000014   F5..         MOV     ?V0 + 0,A
   \   000016   A3           INC     DPTR
   \   000017   E0           MOVX    A,@DPTR
   \   000018   F5..         MOV     ?V0 + 1,A
   3586            uint16           ami;
   3587            ZDSecMgrEntry_t* entry;
   3588          
   3589            /* Store the device address in the addr manager */
   3590            if( ZDSecMgrAddrStore( shortAddr, extAddr, &ami ) != ZSuccess )
   \   00001A                ; Setup parameters for call to function ZDSecMgrAddrStore
   \   00001A   7402         MOV     A,#0x2
   \   00001C   12....       LCALL   ?XSTACK_DISP0_8
   \   00001F   8582..       MOV     ?V0 + 2,DPL
   \   000022   8583..       MOV     ?V0 + 3,DPH
   \   000025   78..         MOV     R0,#?V0 + 2
   \   000027   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00002A   12....       LCALL   ??ZDSecMgrAddrStore?relay
   \   00002D   7402         MOV     A,#0x2
   \   00002F   12....       LCALL   ?DEALLOC_XSTACK8
   \   000032   E9           MOV     A,R1
   \   000033   6004         JZ      ??ZDSecMgrAddLinkKey_0
   3591            {
   3592              /* Adding to Addr Manager fails */
   3593              return ZFailure;
   \   000035   7901         MOV     R1,#0x1
   \   000037   804A         SJMP    ??ZDSecMgrAddLinkKey_1
   3594            }
   3595          
   3596            /* Lookup entry using specified address index */
   3597            ZDSecMgrEntryLookupAMI( ami, &entry );
   \                     ??ZDSecMgrAddLinkKey_0:
   \   000039                ; Setup parameters for call to function ZDSecMgrEntryLookupAMI
   \   000039   85..82       MOV     DPL,?XSP + 0
   \   00003C   85..83       MOV     DPH,?XSP + 1
   \   00003F   AC82         MOV     R4,DPL
   \   000041   AD83         MOV     R5,DPH
   \   000043   7402         MOV     A,#0x2
   \   000045   12....       LCALL   ?XSTACK_DISP0_8
   \   000048   12....       LCALL   ?Subroutine65 & 0xFFFF
   3598          
   3599            // If no existing entry, create one
   3600            if ( entry == NULL )
   \                     ??CrossCallReturnLabel_97:
   \   00004B   85..82       MOV     DPL,?XSP + 0
   \   00004E   85..83       MOV     DPH,?XSP + 1
   \   000051   E0           MOVX    A,@DPTR
   \   000052   7002         JNZ     ??ZDSecMgrAddLinkKey_2
   \   000054   A3           INC     DPTR
   \   000055   E0           MOVX    A,@DPTR
   \                     ??ZDSecMgrAddLinkKey_2:
   \   000056   701E         JNZ     ??CrossCallReturnLabel_204
   3601            {
   3602              if ( ZDSecMgrEntryNew( &entry ) == ZSuccess )
   \   000058                ; Setup parameters for call to function ZDSecMgrEntryNew
   \   000058   85..82       MOV     DPL,?XSP + 0
   \   00005B   85..83       MOV     DPH,?XSP + 1
   \   00005E   AA82         MOV     R2,DPL
   \   000060   AB83         MOV     R3,DPH
   \   000062   12....       LCALL   ??ZDSecMgrEntryNew?relay
   \   000065   E9           MOV     A,R1
   \   000066   7020         JNZ     ??ZDSecMgrAddLinkKey_3
   3603              {
   3604                entry->ami = ami;
   \   000068   7402         MOV     A,#0x2
   \   00006A   12....       LCALL   ?XSTACK_DISP0_8
   \   00006D   12....       LCALL   ?Subroutine62 & 0xFFFF
   3605              }
   \                     ??CrossCallReturnLabel_91:
   \   000070   12....       LCALL   ?Subroutine73 & 0xFFFF
   \                     ??CrossCallReturnLabel_110:
   \   000073   12....       LCALL   ??Subroutine113_0 & 0xFFFF
   3606              else
   3607              {
   3608                /* Security Manager full */
   3609                return ZBufferFull;
   3610              }
   3611            }
   3612            // Write the link key
   3613            APSME_LinkKeySet( extAddr, key );
   \                     ??CrossCallReturnLabel_204:
   \   000076                ; Setup parameters for call to function APSME_LinkKeySet
   \   000076   AC..         MOV     R4,?V0 + 0
   \   000078   AD..         MOV     R5,?V0 + 1
   \   00007A   EE           MOV     A,R6
   \   00007B   FA           MOV     R2,A
   \   00007C   EF           MOV     A,R7
   \   00007D   FB           MOV     R3,A
   \   00007E   12....       LCALL   ??APSME_LinkKeySet?relay
   3614          
   3615          #if defined (TC_LINKKEY_JOIN)
   3616            // Mark the device as authenticated.
   3617            ZDSecMgrAuthenticationSet( extAddr, ZDSecMgr_Authenticated_CBCK );
   3618          #endif
   3619          
   3620          #if defined NV_RESTORE
   3621            ZDSecMgrWriteNV();  // Write the new established link key to NV.
   3622          #endif
   3623            
   3624            return ZSuccess;
   \   000081   7900         MOV     R1,#0x0
   \                     ??ZDSecMgrAddLinkKey_1:
   \   000083   7404         MOV     A,#0x4
   \   000085   02....       LJMP    ??Subroutine128_0 & 0xFFFF
   \                     ??ZDSecMgrAddLinkKey_3:
   \   000088   7911         MOV     R1,#0x11
   \   00008A   80F7         SJMP    ??ZDSecMgrAddLinkKey_1
   3625          }
   3626          
   3627          #if defined ( NV_RESTORE )
   3628          /******************************************************************************
   3629           * @fn          ZDSecMgrInitNV
   3630           *
   3631           * @brief       Initialize the SecMgr entry data in NV with all values set to 0
   3632           *
   3633           * @param       none
   3634           *
   3635           * @return      uint8 - <osal_nv_item_init> return codes
   3636           */
   3637          uint8 ZDSecMgrInitNV(void)
   3638          {
   3639            
   3640            uint8 rtrn = osal_nv_item_init(ZCD_NV_APS_LINK_KEY_TABLE, 
   3641                          (sizeof(nvDeviceListHdr_t) + (sizeof(ZDSecMgrEntry_t) * ZDSECMGR_ENTRY_MAX)), NULL);
   3642            
   3643            // If the item does not already exist, set all values to 0 
   3644            if (rtrn != SUCCESS)  
   3645            {
   3646              nvDeviceListHdr_t hdr;
   3647              hdr.numRecs = 0;
   3648              osal_nv_write(ZCD_NV_APS_LINK_KEY_TABLE, 0, sizeof(nvDeviceListHdr_t), &hdr);
   3649            }
   3650          
   3651            return rtrn;
   3652          }
   3653          #endif // NV_RESTORE
   3654          
   3655          #if defined ( NV_RESTORE )
   3656          /*********************************************************************
   3657           * @fn      ZDSecMgrWriteNV()
   3658           *
   3659           * @brief   Save off the APS link key list to NV
   3660           *
   3661           * @param   none
   3662           *
   3663           * @return  none
   3664           */
   3665          static void ZDSecMgrWriteNV( void )
   3666          {
   3667            uint16 i;
   3668            nvDeviceListHdr_t hdr;
   3669          
   3670            hdr.numRecs = 0;
   3671          
   3672            if (ZDSecMgrEntries != NULL)
   3673            {
   3674              for ( i = 0; i < ZDSECMGR_ENTRY_MAX; i++ )
   3675              {
   3676                if ( ZDSecMgrEntries[i].ami != INVALID_NODE_ADDR )
   3677                {
   3678                  // Save off the record
   3679                  osal_nv_write( ZCD_NV_APS_LINK_KEY_TABLE,
   3680                          (uint16)((sizeof(nvDeviceListHdr_t)) + (hdr.numRecs * sizeof(ZDSecMgrEntry_t))),
   3681                                  sizeof(ZDSecMgrEntry_t), &ZDSecMgrEntries[i] );
   3682                  hdr.numRecs++;
   3683                }
   3684              }
   3685            }
   3686          
   3687            // Save off the header
   3688            osal_nv_write( ZCD_NV_APS_LINK_KEY_TABLE, 0, sizeof( nvDeviceListHdr_t ), &hdr );
   3689          }
   3690          #endif // NV_RESTORE
   3691          
   3692          #if defined ( NV_RESTORE )
   3693          /******************************************************************************
   3694           * @fn          ZDSecMgrRestoreFromNV
   3695           *
   3696           * @brief       Restore the APS Link Key entry data from NV. It does not restore
   3697           *              the key data itself as they remain in NV until they are used. 
   3698           *              Only list data is restored.
   3699           *
   3700           * @param       none
   3701           *
   3702           * @return      None.
   3703           */
   3704          static void ZDSecMgrRestoreFromNV( void )
   3705          {
   3706            nvDeviceListHdr_t hdr;
   3707            APSME_LinkKeyData_t *pApsLinkKey = NULL;
   3708            
   3709            if ((osal_nv_read(ZCD_NV_APS_LINK_KEY_TABLE, 0, sizeof(nvDeviceListHdr_t), &hdr) == ZSUCCESS) &&
   3710                (hdr.numRecs <= ZDSECMGR_ENTRY_MAX))
   3711            {
   3712              uint8 x;
   3713          
   3714              pApsLinkKey = (APSME_LinkKeyData_t *)osal_mem_alloc(sizeof(APSME_LinkKeyData_t));
   3715              
   3716              for (x = 0; x < hdr.numRecs; x++)
   3717              {
   3718                if ( osal_nv_read( ZCD_NV_APS_LINK_KEY_TABLE,
   3719                                  (uint16)(sizeof(nvDeviceListHdr_t) + (x * sizeof(ZDSecMgrEntry_t))),
   3720                                  sizeof(ZDSecMgrEntry_t), &ZDSecMgrEntries[x] ) == SUCCESS )
   3721                {
   3722                  // update data only for valid entries 
   3723                  if ( ZDSecMgrEntries[x].ami != INVALID_NODE_ADDR )
   3724                  {
   3725                    if (pApsLinkKey != NULL)
   3726                    {
   3727                      // read the key form NV, keyNvId must be ZCD_NV_APS_LINK_KEY_DATA_START based
   3728                      osal_nv_read( ZDSecMgrEntries[x].keyNvId, 0, 
   3729                                   sizeof(APSME_LinkKeyData_t), pApsLinkKey );
   3730                      
   3731                      // set new values for the counter 
   3732                      pApsLinkKey->txFrmCntr += ( MAX_APS_FRAMECOUNTER_CHANGES + 1 );
   3733          
   3734                      // restore values for counters in RAM
   3735                      ApsLinkKeyFrmCntr[ZDSecMgrEntries[x].keyNvId - ZCD_NV_APS_LINK_KEY_DATA_START].txFrmCntr = 
   3736                                                      pApsLinkKey->txFrmCntr;
   3737          
   3738                      ApsLinkKeyFrmCntr[ZDSecMgrEntries[x].keyNvId - ZCD_NV_APS_LINK_KEY_DATA_START].rxFrmCntr = 
   3739                                                      pApsLinkKey->rxFrmCntr;
   3740                      
   3741                      osal_nv_write( ZDSecMgrEntries[x].keyNvId, 0, 
   3742                                    sizeof(APSME_LinkKeyData_t), pApsLinkKey );
   3743                      
   3744                      // clear copy of key in RAM 
   3745                      osal_memset(pApsLinkKey, 0x00, sizeof(APSME_LinkKeyData_t));
   3746                    }
   3747                  }
   3748                }
   3749              }
   3750              
   3751              if (pApsLinkKey != NULL)
   3752              {
   3753                osal_mem_free(pApsLinkKey);
   3754              }    
   3755            }
   3756          }
   3757          #endif // NV_RESTORE
   3758          
   3759          /*********************************************************************
   3760           * @fn          ZDSecMgrSetDefaultNV
   3761           *
   3762           * @brief       Write the defaults to NV for Entry table and for APS key data table
   3763           *
   3764           * @param       none
   3765           *
   3766           * @return      none
   3767           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine36:
   \   000000   7C00         MOV     R4,#0x0
   \   000002   7D00         MOV     R5,#0x0
   \   000004   7401         MOV     A,#0x1
   \   000006   2E           ADD     A,R6
   \   000007   FA           MOV     R2,A
   \   000008   7402         MOV     A,#0x2
   \   00000A                REQUIRE ??Subroutine108_0
   \   00000A                ; // Fall through to label ??Subroutine108_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3768          void ZDSecMgrSetDefaultNV( void )
   \                     ZDSecMgrSetDefaultNV:
   3769          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 7
   \   000005   74F9         MOV     A,#-0x7
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   3770            uint16 i;
   3771            nvDeviceListHdr_t hdr;
   3772            ZDSecMgrEntry_t secMgrEntry;
   3773            APSME_LinkKeyData_t *pApsLinkKey = NULL;
   3774              
   3775            // Initialize the header
   3776            hdr.numRecs = 0;
   \   00000A   85..82       MOV     DPL,?XSP + 0
   \   00000D   85..83       MOV     DPH,?XSP + 1
   \   000010   E4           CLR     A
   \   000011   F0           MOVX    @DPTR,A
   \   000012   A3           INC     DPTR
   \   000013   12....       LCALL   ?Subroutine27 & 0xFFFF
   3777          
   3778            // clear the header
   3779            osal_nv_write(ZCD_NV_APS_LINK_KEY_TABLE, 0, sizeof(nvDeviceListHdr_t), &hdr);
   \                     ??CrossCallReturnLabel_30:
   \   000016   8582..       MOV     ?V0 + 0,DPL
   \   000019   8583..       MOV     ?V0 + 1,DPH
   \   00001C   78..         MOV     R0,#?V0 + 0
   \   00001E   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000021   75..02       MOV     ?V0 + 0,#0x2
   \   000024   75..00       MOV     ?V0 + 1,#0x0
   \   000027   78..         MOV     R0,#?V0 + 0
   \   000029   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00002C   7C00         MOV     R4,#0x0
   \   00002E   7D00         MOV     R5,#0x0
   \   000030   7A4C         MOV     R2,#0x4c
   \   000032   7B00         MOV     R3,#0x0
   \   000034   12....       LCALL   ??Subroutine110_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_178:
   \   000037   12....       LCALL   ?DEALLOC_XSTACK8
   3780            
   3781            osal_memset( &secMgrEntry, 0x00, sizeof(ZDSecMgrEntry_t) );
   \   00003A                ; Setup parameters for call to function osal_memset
   \   00003A   7C05         MOV     R4,#0x5
   \   00003C   7D00         MOV     R5,#0x0
   \   00003E   7900         MOV     R1,#0x0
   \   000040   7402         MOV     A,#0x2
   \   000042   12....       LCALL   ?XSTACK_DISP0_8
   \   000045   12....       LCALL   ?Subroutine39 & 0xFFFF
   3782          
   3783            for ( i = 0; i < ZDSECMGR_ENTRY_MAX; i++ )
   3784            {
   3785              // Clear the record
   3786              osal_nv_write( ZCD_NV_APS_LINK_KEY_TABLE,
   3787                          (uint16)((sizeof(nvDeviceListHdr_t)) + (i * sizeof(ZDSecMgrEntry_t))),
   3788                                  sizeof(ZDSecMgrEntry_t), &secMgrEntry );
   \                     ??CrossCallReturnLabel_161:
   \   000048                ; Setup parameters for call to function osal_nv_write
   \   000048   7402         MOV     A,#0x2
   \   00004A   12....       LCALL   ?XSTACK_DISP0_8
   \   00004D   8582..       MOV     ?V0 + 0,DPL
   \   000050   8583..       MOV     ?V0 + 1,DPH
   \   000053   78..         MOV     R0,#?V0 + 0
   \   000055   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000058   75..05       MOV     ?V0 + 0,#0x5
   \   00005B   75..00       MOV     ?V0 + 1,#0x0
   \   00005E   78..         MOV     R0,#?V0 + 0
   \   000060   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000063   EE           MOV     A,R6
   \   000064   F8           MOV     R0,A
   \   000065   EF           MOV     A,R7
   \   000066   F9           MOV     R1,A
   \   000067   E8           MOV     A,R0
   \   000068   75F005       MOV     B,#0x5
   \   00006B   A4           MUL     AB
   \   00006C   F8           MOV     R0,A
   \   00006D   AAF0         MOV     R2,B
   \   00006F   75F005       MOV     B,#0x5
   \   000072   E9           MOV     A,R1
   \   000073   A4           MUL     AB
   \   000074   2A           ADD     A,R2
   \   000075   F9           MOV     R1,A
   \   000076   7402         MOV     A,#0x2
   \   000078   28           ADD     A,R0
   \   000079   FC           MOV     R4,A
   \   00007A   E4           CLR     A
   \   00007B   39           ADDC    A,R1
   \   00007C   FD           MOV     R5,A
   \   00007D   7A4C         MOV     R2,#0x4c
   \   00007F   7B00         MOV     R3,#0x0
   \   000081   12....       LCALL   ??Subroutine110_0 & 0xFFFF
   3789            }
   \                     ??CrossCallReturnLabel_179:
   \   000084   12....       LCALL   ?DEALLOC_XSTACK8
   \   000087   12....       LCALL   ?Subroutine34 & 0xFFFF
   \                     ??CrossCallReturnLabel_47:
   \   00008A   40BC         JC      ??CrossCallReturnLabel_161
   3790          
   3791            pApsLinkKey = (APSME_LinkKeyData_t *)osal_mem_alloc(sizeof(APSME_LinkKeyData_t));
   \   00008C                ; Setup parameters for call to function osal_mem_alloc
   \   00008C   7A18         MOV     R2,#0x18
   \   00008E   12....       LCALL   ?Subroutine80 & 0xFFFF
   3792          
   3793            if (pApsLinkKey != NULL)
   \                     ??CrossCallReturnLabel_121:
   \   000091   7001         JNZ     ??ZDSecMgrSetDefaultNV_0
   \   000093   EB           MOV     A,R3
   \                     ??ZDSecMgrSetDefaultNV_0:
   \   000094   602B         JZ      ??ZDSecMgrSetDefaultNV_1
   3794            {
   3795              osal_memset( pApsLinkKey, 0x00, sizeof(APSME_LinkKeyData_t) );
   \   000096                ; Setup parameters for call to function osal_memset
   \   000096   7C18         MOV     R4,#0x18
   \   000098   7D00         MOV     R5,#0x0
   \   00009A   7900         MOV     R1,#0x0
   \   00009C   12....       LCALL   ??Subroutine105_0 & 0xFFFF
   3796          
   3797              for ( i = 0; i < ZDSECMGR_ENTRY_MAX; i++ )
   3798              {
   3799                // Clear the record
   3800                osal_nv_write( (ZCD_NV_APS_LINK_KEY_DATA_START + i), 0,
   3801                              sizeof(APSME_LinkKeyData_t), pApsLinkKey);
   \                     ??CrossCallReturnLabel_162:
   \   00009F                ; Setup parameters for call to function osal_nv_write
   \   00009F   78..         MOV     R0,#?V0 + 0
   \   0000A1   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000A4   75..18       MOV     ?V0 + 2,#0x18
   \   0000A7   75..00       MOV     ?V0 + 3,#0x0
   \   0000AA   78..         MOV     R0,#?V0 + 2
   \   0000AC   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000AF   12....       LCALL   ?Subroutine36 & 0xFFFF
   3802              }
   \                     ??CrossCallReturnLabel_170:
   \   0000B2   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000B5   12....       LCALL   ?Subroutine34 & 0xFFFF
   \                     ??CrossCallReturnLabel_48:
   \   0000B8   40E5         JC      ??CrossCallReturnLabel_162
   3803              
   3804              osal_mem_free(pApsLinkKey);
   \   0000BA                ; Setup parameters for call to function osal_mem_free
   \   0000BA   AA..         MOV     R2,?V0 + 0
   \   0000BC   AB..         MOV     R3,?V0 + 1
   \   0000BE   12....       LCALL   ??osal_mem_free?relay
   3805            }
   3806          }
   \                     ??ZDSecMgrSetDefaultNV_1:
   \   0000C1   7407         MOV     A,#0x7
   \   0000C3   02....       LJMP    ??Subroutine128_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine80:
   \   000000   7B00         MOV     R3,#0x0
   \   000002   12....       LCALL   ??osal_mem_alloc?relay
   \   000005   8A..         MOV     ?V0 + 0,R2
   \   000007   8B..         MOV     ?V0 + 1,R3
   \   000009   EA           MOV     A,R2
   \   00000A   22           RET
   3807          
   3808          /******************************************************************************
   3809           * @fn          ZDSecMgrAPSRemove
   3810           *
   3811           * @brief       Remove device from network.
   3812           *
   3813           * @param       nwkAddr - device's NWK address
   3814           * @param       extAddr - device's Extended address
   3815           * @param       parentAddr - parent's NWK address
   3816           *
   3817           * @return      ZStatus_t
   3818           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3819          ZStatus_t ZDSecMgrAPSRemove( uint16 nwkAddr, uint8 *extAddr, uint16 parentAddr )
   \                     ZDSecMgrAPSRemove:
   3820          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 10
   \   000004   74F6         MOV     A,#-0xa
   \   000006   12....       LCALL   ?ALLOC_XSTACK8
   \   000009   740A         MOV     A,#0xa
   \   00000B   12....       LCALL   ?XSTACK_DISP0_8
   \   00000E   12....       LCALL   ??Subroutine144_0 & 0xFFFF
   3821            ZDSecMgrDevice_t device;
   3822          
   3823            if ( ( nwkAddr == INVALID_NODE_ADDR ) ||
   3824                 ( extAddr == NULL )              ||
   3825                 ( parentAddr == INVALID_NODE_ADDR ) )
   \                     ??CrossCallReturnLabel_317:
   \   000011   74FE         MOV     A,#-0x2
   \   000013   6A           XRL     A,R2
   \   000014   7003         JNZ     ??ZDSecMgrAPSRemove_0
   \   000016   74FF         MOV     A,#-0x1
   \   000018   6B           XRL     A,R3
   \                     ??ZDSecMgrAPSRemove_0:
   \   000019   6010         JZ      ??ZDSecMgrAPSRemove_1
   \   00001B   EC           MOV     A,R4
   \   00001C   7001         JNZ     ??ZDSecMgrAPSRemove_2
   \   00001E   ED           MOV     A,R5
   \                     ??ZDSecMgrAPSRemove_2:
   \   00001F   600A         JZ      ??ZDSecMgrAPSRemove_1
   \   000021   74FE         MOV     A,#-0x2
   \   000023   68           XRL     A,R0
   \   000024   7003         JNZ     ??ZDSecMgrAPSRemove_3
   \   000026   74FF         MOV     A,#-0x1
   \   000028   69           XRL     A,R1
   \                     ??ZDSecMgrAPSRemove_3:
   \   000029   7004         JNZ     ??ZDSecMgrAPSRemove_4
   3826            {
   3827              return ( ZFailure );
   \                     ??ZDSecMgrAPSRemove_1:
   \   00002B   7901         MOV     R1,#0x1
   \   00002D   8015         SJMP    ??ZDSecMgrAPSRemove_5
   3828            }
   3829          
   3830            device.nwkAddr = nwkAddr;
   \                     ??ZDSecMgrAPSRemove_4:
   \   00002F   12....       LCALL   ?Subroutine28 & 0xFFFF
   3831            device.extAddr = extAddr;
   \                     ??CrossCallReturnLabel_33:
   \   000032   12....       LCALL   ?XSTACK_DISP0_8
   \   000035   EC           MOV     A,R4
   \   000036   F0           MOVX    @DPTR,A
   \   000037   A3           INC     DPTR
   \   000038   ED           MOV     A,R5
   \   000039   F0           MOVX    @DPTR,A
   3832            device.parentAddr = parentAddr;
   \   00003A   7404         MOV     A,#0x4
   \   00003C   12....       LCALL   ?XSTACK_DISP0_8
   \   00003F   12....       LCALL   ?Subroutine14 & 0xFFFF
   3833          
   3834            // remove device
   3835            ZDSecMgrDeviceRemove( &device );
   3836          
   3837            return ( ZSuccess );
   \                     ??CrossCallReturnLabel_1:
   \   000042   7900         MOV     R1,#0x0
   \                     ??ZDSecMgrAPSRemove_5:
   \   000044   02....       LJMP    ?Subroutine10 & 0xFFFF
   3838          }
   3839          
   3840          /******************************************************************************
   3841           * @fn          APSME_TCLinkKeyInit
   3842           *
   3843           * @brief       Initialize the NV table for preconfigured TC link key
   3844           *               
   3845           *              When zgUseDefaultTCL is set to TRUE, the default preconfig
   3846           *              Trust Center Link Key is written to NV. A single tclk is used   
   3847           *              by all devices joining the network.
   3848           *              
   3849           * @param       setDefault - TRUE to set default values
   3850           *
   3851           * @return      none
   3852           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine5:
   \   000000   7420         MOV     A,#0x20
   \   000002                REQUIRE ??Subroutine128_0
   \   000002                ; // Fall through to label ??Subroutine128_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3853          void APSME_TCLinkKeyInit(uint8 setDefault)
   \                     APSME_TCLinkKeyInit:
   3854          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 32
   \   000005   74E0         MOV     A,#-0x20
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   3855            uint8             i;
   3856            APSME_TCLinkKey_t tcLinkKey;
   3857            uint8             rtrn;
   3858            
   3859            // Initialize all NV items for preconfigured TCLK 
   3860            for( i = 0; i < ZDSECMGR_TC_DEVICE_MAX; i++ )
   3861            {
   3862              // Making sure data is cleared for every key all the time
   3863              osal_memset( &tcLinkKey, 0x00, sizeof(APSME_TCLinkKey_t) );
   \   00000A                ; Setup parameters for call to function osal_memset
   \   00000A   7C20         MOV     R4,#0x20
   \   00000C   7D00         MOV     R5,#0x0
   \   00000E   7900         MOV     R1,#0x0
   \   000010   85..82       MOV     DPL,?XSP + 0
   \   000013   85..83       MOV     DPH,?XSP + 1
   \   000016   AA82         MOV     R2,DPL
   \   000018   AB83         MOV     R3,DPH
   \   00001A   12....       LCALL   ??osal_memset?relay
   3864          
   3865              // Initialize first element of the table with the default TCLK
   3866              if((i == 0) && ( zgUseDefaultTCLK == TRUE ))
   \   00001D   90....       MOV     DPTR,#zgUseDefaultTCLK
   \   000020   E0           MOVX    A,@DPTR
   \   000021   6401         XRL     A,#0x1
   \   000023   7030         JNZ     ??APSME_TCLinkKeyInit_0
   3867              {
   3868                osal_memset( tcLinkKey.extAddr, 0xFF, Z_EXTADDR_LEN );
   \   000025                ; Setup parameters for call to function osal_memset
   \   000025   7C08         MOV     R4,#0x8
   \   000027   7D00         MOV     R5,#0x0
   \   000029   79FF         MOV     R1,#-0x1
   \   00002B   85..82       MOV     DPL,?XSP + 0
   \   00002E   85..83       MOV     DPH,?XSP + 1
   \   000031   AA82         MOV     R2,DPL
   \   000033   AB83         MOV     R3,DPH
   \   000035   12....       LCALL   ??osal_memset?relay
   3869                osal_memcpy( tcLinkKey.key, defaultTCLinkKey, SEC_KEY_LEN);
   \   000038                ; Setup parameters for call to function osal_memcpy
   \   000038   75....       MOV     ?V0 + 0,#(defaultTCLinkKey & 0xff)
   \   00003B   75....       MOV     ?V0 + 1,#((defaultTCLinkKey >> 8) & 0xff)
   \   00003E   75..80       MOV     ?V0 + 2,#-0x80
   \   000041   78..         MOV     R0,#?V0 + 0
   \   000043   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000046   7C10         MOV     R4,#0x10
   \   000048   7D00         MOV     R5,#0x0
   \   00004A   740B         MOV     A,#0xb
   \   00004C   12....       LCALL   ?XSTACK_DISP0_8
   \   00004F   12....       LCALL   ?Subroutine78 & 0xFFFF
   3870              }
   \                     ??CrossCallReturnLabel_228:
   \   000052   12....       LCALL   ?DEALLOC_XSTACK8
   3871          
   3872              // If the item doesn't exist in NV memory, create and initialize
   3873              // it with the default value passed in, either defaultTCLK or 0
   3874              rtrn = osal_nv_item_init( (ZCD_NV_TCLK_TABLE_START + i), 
   3875                                         sizeof(APSME_TCLinkKey_t), &tcLinkKey);
   3876               
   3877              if (rtrn == SUCCESS)
   \                     ??APSME_TCLinkKeyInit_0:
   \   000055                ; Setup parameters for call to function osal_nv_item_init
   \   000055   85..82       MOV     DPL,?XSP + 0
   \   000058   85..83       MOV     DPH,?XSP + 1
   \   00005B   8582..       MOV     ?V0 + 0,DPL
   \   00005E   8583..       MOV     ?V0 + 1,DPH
   \   000061   78..         MOV     R0,#?V0 + 0
   \   000063   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000066   7C20         MOV     R4,#0x20
   \   000068   7D00         MOV     R5,#0x0
   \   00006A   7A01         MOV     R2,#0x1
   \   00006C   7B01         MOV     R3,#0x1
   \   00006E   12....       LCALL   ??Subroutine146_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_339:
   \   000071   12....       LCALL   ?DEALLOC_XSTACK8
   \   000074   E9           MOV     A,R1
   \   000075   6003         JZ      $+5
   \   000077   02....       LJMP    ??APSME_TCLinkKeyInit_1 & 0xFFFF
   3878              {
   3879                // set the Frame counters to 0 to existing keys in NV
   3880                osal_nv_read( ( ZCD_NV_TCLK_TABLE_START + i), 0, 
   3881                               sizeof(APSME_TCLinkKey_t), &tcLinkKey );
   \   00007A                ; Setup parameters for call to function osal_nv_read
   \   00007A   78..         MOV     R0,#?V0 + 0
   \   00007C   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00007F   75..20       MOV     ?V0 + 0,#0x20
   \   000082   75..00       MOV     ?V0 + 1,#0x0
   \   000085   78..         MOV     R0,#?V0 + 0
   \   000087   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00008A   12....       LCALL   ?Subroutine76 & 0xFFFF
   \                     ??CrossCallReturnLabel_327:
   \   00008D   12....       LCALL   ?DEALLOC_XSTACK8
   3882                
   3883          #if defined ( NV_RESTORE )
   3884                if (setDefault == TRUE)
   3885                {
   3886                  // clear the value stored in NV  
   3887                  tcLinkKey.txFrmCntr = 0;
   3888                }
   3889                else
   3890                {
   3891                  // increase the value stored in NV  
   3892                  tcLinkKey.txFrmCntr += ( MAX_TCLK_FRAMECOUNTER_CHANGES + 1 );
   3893                }
   3894          #else      
   3895                // Clear the counters if NV_RESTORE is not enabled and this NV item
   3896                // already existed in the NV memory
   3897                tcLinkKey.txFrmCntr = 0;
   \   000090   90....       MOV     DPTR,#__Constant_0
   \   000093   78..         MOV     R0,#?V0 + 0
   \   000095   12....       LCALL   ?L_MOV_X
   \   000098   7418         MOV     A,#0x18
   \   00009A   12....       LCALL   ?XSTACK_DISP0_8
   \   00009D   78..         MOV     R0,#?V0 + 0
   \   00009F   12....       LCALL   ?L_MOV_TO_X
   3898                tcLinkKey.rxFrmCntr = 0;
   \   0000A2   90....       MOV     DPTR,#__Constant_0
   \   0000A5   78..         MOV     R0,#?V0 + 0
   \   0000A7   12....       LCALL   ?L_MOV_X
   \   0000AA   741C         MOV     A,#0x1c
   \   0000AC   12....       LCALL   ?XSTACK_DISP0_8
   \   0000AF   78..         MOV     R0,#?V0 + 0
   \   0000B1   12....       LCALL   ?L_MOV_TO_X
   3899          #endif  // NV_RESTORE
   3900          
   3901                osal_nv_write( ( ZCD_NV_TCLK_TABLE_START + i), 0,
   3902                                sizeof(APSME_TCLinkKey_t), &tcLinkKey );
   \   0000B4                ; Setup parameters for call to function osal_nv_write
   \   0000B4   85..82       MOV     DPL,?XSP + 0
   \   0000B7   85..83       MOV     DPH,?XSP + 1
   \   0000BA   8582..       MOV     ?V0 + 0,DPL
   \   0000BD   8583..       MOV     ?V0 + 1,DPH
   \   0000C0   78..         MOV     R0,#?V0 + 0
   \   0000C2   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000C5   75..20       MOV     ?V0 + 0,#0x20
   \   0000C8   75..00       MOV     ?V0 + 1,#0x0
   \   0000CB   78..         MOV     R0,#?V0 + 0
   \   0000CD   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000D0   7C00         MOV     R4,#0x0
   \   0000D2   7D00         MOV     R5,#0x0
   \   0000D4   7A01         MOV     R2,#0x1
   \   0000D6   7B01         MOV     R3,#0x1
   \   0000D8   12....       LCALL   ??Subroutine110_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_180:
   \   0000DB   12....       LCALL   ?DEALLOC_XSTACK8
   3903                
   3904                // set initial values for counters in RAM
   3905                TCLinkKeyFrmCntr[i].txFrmCntr = tcLinkKey.txFrmCntr;
   \   0000DE   7418         MOV     A,#0x18
   \   0000E0   12....       LCALL   ?XSTACK_DISP0_8
   \   0000E3   78..         MOV     R0,#?V0 + 0
   \   0000E5   12....       LCALL   ?L_MOV_X
   \   0000E8   90....       MOV     DPTR,#TCLinkKeyFrmCntr
   \   0000EB   78..         MOV     R0,#?V0 + 0
   \   0000ED   12....       LCALL   ?L_MOV_TO_X
   3906                TCLinkKeyFrmCntr[i].rxFrmCntr = tcLinkKey.rxFrmCntr;    
   \   0000F0   741C         MOV     A,#0x1c
   \   0000F2   12....       LCALL   ?XSTACK_DISP0_8
   \   0000F5   78..         MOV     R0,#?V0 + 0
   \   0000F7   12....       LCALL   ?L_MOV_X
   \   0000FA   90....       MOV     DPTR,#(TCLinkKeyFrmCntr + 4)
   \   0000FD   78..         MOV     R0,#?V0 + 0
   \   0000FF   12....       LCALL   ?L_MOV_TO_X
   3907              }
   3908            }
   3909              
   3910            // clear copy of key in RAM
   3911            osal_memset( &tcLinkKey, 0x00, sizeof(APSME_TCLinkKey_t) );
   \                     ??APSME_TCLinkKeyInit_1:
   \   000102                ; Setup parameters for call to function osal_memset
   \   000102   7C20         MOV     R4,#0x20
   \   000104   7D00         MOV     R5,#0x0
   \   000106   7900         MOV     R1,#0x0
   \   000108   85..82       MOV     DPL,?XSP + 0
   \   00010B   85..83       MOV     DPH,?XSP + 1
   \   00010E   AA82         MOV     R2,DPL
   \   000110   AB83         MOV     R3,DPH
   \   000112   12....       LCALL   ??osal_memset?relay
   3912          
   3913          }
   \   000115   02....       LJMP    ?Subroutine5 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine76:
   \   000000   7C00         MOV     R4,#0x0
   \   000002   7D00         MOV     R5,#0x0
   \   000004   7A01         MOV     R2,#0x1
   \   000006   7B01         MOV     R3,#0x1
   \   000008                REQUIRE ??Subroutine145_0
   \   000008                ; // Fall through to label ??Subroutine145_0
   3914          
   3915          /******************************************************************************
   3916           * @fn          APSME_TCLinkKeySync
   3917           *
   3918           * @brief       Sync Trust Center LINK key data.
   3919           *
   3920           * @param       srcAddr - [in] srcAddr
   3921           * @param       si      - [in, out] SSP_Info_t
   3922           *
   3923           * @return      ZStatus_t
   3924           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine45:
   \   000000   EE           MOV     A,R6
   \   000001                REQUIRE ??Subroutine135_0
   \   000001                ; // Fall through to label ??Subroutine135_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine135_0:
   \   000000   2412         ADD     A,#0x12
   \   000002                REQUIRE ??Subroutine136_0
   \   000002                ; // Fall through to label ??Subroutine136_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3925          ZStatus_t APSME_TCLinkKeySync( uint16 srcAddr, SSP_Info_t* si )
   \                     APSME_TCLinkKeySync:
   3926          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 32
   \   000005   74E0         MOV     A,#-0x20
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0 + 0,R2
   \   00000C   8B..         MOV     ?V0 + 1,R3
   \   00000E   EC           MOV     A,R4
   \   00000F   FE           MOV     R6,A
   \   000010   ED           MOV     A,R5
   \   000011   FF           MOV     R7,A
   3927            ZStatus_t status = ZSecNoKey;
   3928            uint8 i;
   3929            APSME_TCLinkKey_t tcLinkKey;       
   3930            uint32 *tclkRxFrmCntr;
   3931            
   3932            // Look up the IEEE address of the trust center if it's available
   3933            if ( AddrMgrExtAddrValid( si->extAddr ) == false )
   \   000012                ; Setup parameters for call to function AddrMgrExtAddrValid
   \   000012   12....       LCALL   ?Subroutine101 & 0xFFFF
   \                     ??CrossCallReturnLabel_154:
   \   000015   12....       LCALL   ??AddrMgrExtAddrValid?relay
   \   000018   E9           MOV     A,R1
   \   000019   700F         JNZ     ??APSME_TCLinkKeySync_0
   3934            {
   3935              APSME_LookupExtAddr( srcAddr, si->extAddr );
   \   00001B                ; Setup parameters for call to function APSME_LookupExtAddr
   \   00001B   EE           MOV     A,R6
   \   00001C   2406         ADD     A,#0x6
   \   00001E   FC           MOV     R4,A
   \   00001F   EF           MOV     A,R7
   \   000020   3400         ADDC    A,#0x0
   \   000022   FD           MOV     R5,A
   \   000023   AA..         MOV     R2,?V0 + 0
   \   000025   AB..         MOV     R3,?V0 + 1
   \   000027   12....       LCALL   ??APSME_LookupExtAddr?relay
   3936            }
   3937            
   3938            // Look up the TC link key associated with the device
   3939            // or the default TC link key (extAddr is all FFs), whichever is found
   3940            for( i = 0; i < ZDSECMGR_TC_DEVICE_MAX; i++ )
   3941            {
   3942              // Read entry i of the TC link key table from NV
   3943              osal_nv_read( (ZCD_NV_TCLK_TABLE_START + i), 0, 
   3944                           sizeof(APSME_TCLinkKey_t), &tcLinkKey );
   \                     ??APSME_TCLinkKeySync_0:
   \   00002A                ; Setup parameters for call to function osal_nv_read
   \   00002A   85..82       MOV     DPL,?XSP + 0
   \   00002D   85..83       MOV     DPH,?XSP + 1
   \   000030   8582..       MOV     ?V0 + 0,DPL
   \   000033   8583..       MOV     ?V0 + 1,DPH
   \   000036   78..         MOV     R0,#?V0 + 0
   \   000038   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00003B   75..20       MOV     ?V0 + 0,#0x20
   \   00003E   75..00       MOV     ?V0 + 1,#0x0
   \   000041   78..         MOV     R0,#?V0 + 0
   \   000043   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000046   12....       LCALL   ?Subroutine76 & 0xFFFF
   \                     ??CrossCallReturnLabel_328:
   \   000049   12....       LCALL   ?DEALLOC_XSTACK8
   3945              
   3946              if( AddrMgrExtAddrEqual(si->extAddr, tcLinkKey.extAddr) || 
   3947                  APSME_IsDefaultTCLK(tcLinkKey.extAddr))
   \   00004C                ; Setup parameters for call to function AddrMgrExtAddrEqual
   \   00004C   85..82       MOV     DPL,?XSP + 0
   \   00004F   85..83       MOV     DPH,?XSP + 1
   \   000052   12....       LCALL   ?Subroutine83 & 0xFFFF
   \                     ??CrossCallReturnLabel_128:
   \   000055   7010         JNZ     ??APSME_TCLinkKeySync_1
   \   000057                ; Setup parameters for call to function APSME_IsDefaultTCLK
   \   000057   85..82       MOV     DPL,?XSP + 0
   \   00005A   85..83       MOV     DPH,?XSP + 1
   \   00005D   AA82         MOV     R2,DPL
   \   00005F   AB83         MOV     R3,DPH
   \   000061   12....       LCALL   ??APSME_IsDefaultTCLK?relay
   \   000064   E9           MOV     A,R1
   \   000065   6045         JZ      ??APSME_TCLinkKeySync_2
   3948              {
   3949                tclkRxFrmCntr = &TCLinkKeyFrmCntr[i].rxFrmCntr;
   3950          
   3951                // verify that the incoming frame counter is valid
   3952                if ( si->frmCntr >= *tclkRxFrmCntr )
   \                     ??APSME_TCLinkKeySync_1:
   \   000067   12....       LCALL   ?Subroutine45 & 0xFFFF
   \                     ??CrossCallReturnLabel_277:
   \   00006A   C082         PUSH    DPL
   \   00006C   C083         PUSH    DPH
   \   00006E   90....       MOV     DPTR,#(TCLinkKeyFrmCntr + 4)
   \   000071   78..         MOV     R0,#?V0 + 0
   \   000073   12....       LCALL   ?L_MOV_X
   \   000076   D083         POP     DPH
   \   000078   D082         POP     DPL
   \   00007A   78..         MOV     R0,#?V0 + 0
   \   00007C   12....       LCALL   ?UL_GT_X
   \   00007F   4027         JC      ??APSME_TCLinkKeySync_3
   3953                {
   3954                  // set the keyNvId to use
   3955                  si->keyNvId = (ZCD_NV_TCLK_TABLE_START + i);
   \   000081   12....       LCALL   ?Subroutine44 & 0xFFFF
   3956                  
   3957                  // update the rx frame counter
   3958                  *tclkRxFrmCntr = si->frmCntr + 1;
   \                     ??CrossCallReturnLabel_62:
   \   000084   12....       LCALL   ??Subroutine135_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_276:
   \   000087   C082         PUSH    DPL
   \   000089   C083         PUSH    DPH
   \   00008B   90....       MOV     DPTR,#__Constant_1
   \   00008E   78..         MOV     R0,#?V0 + 0
   \   000090   12....       LCALL   ?L_MOV_X
   \   000093   D083         POP     DPH
   \   000095   D082         POP     DPL
   \   000097   78..         MOV     R0,#?V0 + 0
   \   000099   12....       LCALL   ?L_ADD_X
   \   00009C   90....       MOV     DPTR,#(TCLinkKeyFrmCntr + 4)
   \   00009F   78..         MOV     R0,#?V0 + 0
   \   0000A1   12....       LCALL   ?L_MOV_TO_X
   3959                  
   3960                  status = ZSuccess;
   \   0000A4   7900         MOV     R1,#0x0
   \   0000A6   8019         SJMP    ??APSME_TCLinkKeySync_4
   3961                }
   3962                else
   3963                {
   3964                  status = ZSecOldFrmCount;
   \                     ??APSME_TCLinkKeySync_3:
   \   0000A8   79A2         MOV     R1,#-0x5e
   3965                }
   3966                
   3967                return status;
   \   0000AA   8015         SJMP    ??APSME_TCLinkKeySync_4
   3968              }
   3969            }
   3970            
   3971            // clear copy of key in RAM 
   3972            osal_memset( &tcLinkKey, 0x00, sizeof(APSME_TCLinkKey_t) );
   \                     ??APSME_TCLinkKeySync_2:
   \   0000AC                ; Setup parameters for call to function osal_memset
   \   0000AC   7C20         MOV     R4,#0x20
   \   0000AE   7D00         MOV     R5,#0x0
   \   0000B0   7900         MOV     R1,#0x0
   \   0000B2   85..82       MOV     DPL,?XSP + 0
   \   0000B5   85..83       MOV     DPH,?XSP + 1
   \   0000B8   AA82         MOV     R2,DPL
   \   0000BA   AB83         MOV     R3,DPH
   \   0000BC   12....       LCALL   ??osal_memset?relay
   3973            
   3974            return status;
   \   0000BF   79A1         MOV     R1,#-0x5f
   \                     ??APSME_TCLinkKeySync_4:
   \   0000C1   02....       LJMP    ?Subroutine5 & 0xFFFF
   3975          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine83:
   \   000000   AC82         MOV     R4,DPL
   \   000002   AD83         MOV     R5,DPH
   \   000004   12....       LCALL   ?Subroutine101 & 0xFFFF
   \                     ??CrossCallReturnLabel_155:
   \   000007   12....       LCALL   ??AddrMgrExtAddrEqual?relay
   \   00000A   E9           MOV     A,R1
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine44:
   \   000000   EE           MOV     A,R6
   \   000001   240F         ADD     A,#0xf
   \   000003   F582         MOV     DPL,A
   \   000005   EF           MOV     A,R7
   \   000006   3400         ADDC    A,#0x0
   \   000008   F583         MOV     DPH,A
   \   00000A   7401         MOV     A,#0x1
   \   00000C   F0           MOVX    @DPTR,A
   \   00000D   A3           INC     DPTR
   \   00000E   F0           MOVX    @DPTR,A
   \   00000F   EE           MOV     A,R6
   \   000010   22           RET
   3976          
   3977          /******************************************************************************
   3978           * @fn          APSME_TCLinkKeyLoad
   3979           *
   3980           * @brief       Load Trust Center LINK key data.
   3981           *
   3982           * @param       dstAddr - [in] dstAddr
   3983           * @param       si      - [in, out] SSP_Info_t
   3984           *
   3985           * @return      ZStatus_t
   3986           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3987          ZStatus_t APSME_TCLinkKeyLoad( uint16 dstAddr, SSP_Info_t* si )
   \                     APSME_TCLinkKeyLoad:
   3988          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 45
   \   000005   74D3         MOV     A,#-0x2d
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EC           MOV     A,R4
   \   00000B   FE           MOV     R6,A
   \   00000C   ED           MOV     A,R5
   \   00000D   FF           MOV     R7,A
   3989            uint8              i;
   3990            APSME_TCLinkKey_t  tcLinkKey;
   3991            AddrMgrEntry_t     addrEntry;  
   3992            uint32 *tclkTxFrmCntr;
   3993            
   3994            // Look up the ami of the srcAddr if available
   3995            addrEntry.user    = ADDRMGR_USER_DEFAULT;
   \   00000E   E4           CLR     A
   \   00000F   85..82       MOV     DPL,?XSP + 0
   \   000012   85..83       MOV     DPH,?XSP + 1
   \   000015   F0           MOVX    @DPTR,A
   3996            addrEntry.nwkAddr = dstAddr;
   \   000016   7401         MOV     A,#0x1
   \   000018   12....       LCALL   ?XSTACK_DISP0_8
   \   00001B   12....       LCALL   ?Subroutine29 & 0xFFFF
   3997          
   3998            APSME_LookupExtAddr( dstAddr, si->extAddr );
   \                     ??CrossCallReturnLabel_41:
   \   00001E   EE           MOV     A,R6
   \   00001F   2406         ADD     A,#0x6
   \   000021   F5..         MOV     ?V0 + 0,A
   \   000023   EF           MOV     A,R7
   \   000024   3400         ADDC    A,#0x0
   \   000026   F5..         MOV     ?V0 + 1,A
   \   000028                ; Setup parameters for call to function APSME_LookupExtAddr
   \   000028   AC..         MOV     R4,?V0 + 0
   \   00002A   FD           MOV     R5,A
   \   00002B   12....       LCALL   ??APSME_LookupExtAddr?relay
   3999          
   4000            if ( AddrMgrExtAddrValid( si->extAddr ) == TRUE )
   \   00002E                ; Setup parameters for call to function AddrMgrExtAddrValid
   \   00002E   AA..         MOV     R2,?V0 + 0
   \   000030   AB..         MOV     R3,?V0 + 1
   \   000032   12....       LCALL   ??AddrMgrExtAddrValid?relay
   \   000035   E9           MOV     A,R1
   \   000036   6401         XRL     A,#0x1
   \   000038   7068         JNZ     ??APSME_TCLinkKeyLoad_0
   4001            {
   4002              // Look up the TC link key associated with the device
   4003              // or the master TC link key (ami = 0xFFFF), whichever is found
   4004              for( i = 0; i < ZDSECMGR_TC_DEVICE_MAX; i++ )
   4005              {
   4006                // Read entry i of the TC link key table from NV
   4007                osal_nv_read( (ZCD_NV_TCLK_TABLE_START + i), 0, 
   4008                             sizeof(APSME_TCLinkKey_t), &tcLinkKey );
   \   00003A                ; Setup parameters for call to function osal_nv_read
   \   00003A   740D         MOV     A,#0xd
   \   00003C   12....       LCALL   ?XSTACK_DISP0_8
   \   00003F   8582..       MOV     ?V0 + 0,DPL
   \   000042   8583..       MOV     ?V0 + 1,DPH
   \   000045   78..         MOV     R0,#?V0 + 0
   \   000047   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00004A   75..20       MOV     ?V0 + 0,#0x20
   \   00004D   75..00       MOV     ?V0 + 1,#0x0
   \   000050   78..         MOV     R0,#?V0 + 0
   \   000052   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000055   12....       LCALL   ?Subroutine76 & 0xFFFF
   \                     ??CrossCallReturnLabel_329:
   \   000058   12....       LCALL   ?DEALLOC_XSTACK8
   4009                
   4010                if( AddrMgrExtAddrEqual(si->extAddr, tcLinkKey.extAddr) || 
   4011                   APSME_IsDefaultTCLK(tcLinkKey.extAddr))
   \   00005B                ; Setup parameters for call to function AddrMgrExtAddrEqual
   \   00005B   740D         MOV     A,#0xd
   \   00005D   12....       LCALL   ?XSTACK_DISP0_8
   \   000060   12....       LCALL   ?Subroutine83 & 0xFFFF
   \                     ??CrossCallReturnLabel_129:
   \   000063   700F         JNZ     ??APSME_TCLinkKeyLoad_1
   \   000065                ; Setup parameters for call to function APSME_IsDefaultTCLK
   \   000065   740D         MOV     A,#0xd
   \   000067   12....       LCALL   ?XSTACK_DISP0_8
   \   00006A   AA82         MOV     R2,DPL
   \   00006C   AB83         MOV     R3,DPH
   \   00006E   12....       LCALL   ??APSME_IsDefaultTCLK?relay
   \   000071   E9           MOV     A,R1
   \   000072   602E         JZ      ??APSME_TCLinkKeyLoad_0
   4012                {
   4013                  tclkTxFrmCntr = &TCLinkKeyFrmCntr[i].txFrmCntr;
   4014                  
   4015                  // set the keyNvId to use
   4016                  si->keyNvId = (ZCD_NV_TCLK_TABLE_START + i);
   \                     ??APSME_TCLinkKeyLoad_1:
   \   000074   12....       LCALL   ?Subroutine44 & 0xFFFF
   4017                  
   4018                  // update link key related fields
   4019                  si->keyID   = SEC_KEYID_LINK;
   \                     ??CrossCallReturnLabel_63:
   \   000077   240E         ADD     A,#0xe
   \   000079   12....       LCALL   ??Subroutine136_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_275:
   \   00007C   E4           CLR     A
   \   00007D   F0           MOVX    @DPTR,A
   4020                  si->frmCntr = *tclkTxFrmCntr;
   \   00007E   90....       MOV     DPTR,#TCLinkKeyFrmCntr
   \   000081   78..         MOV     R0,#?V0 + 0
   \   000083   12....       LCALL   ?L_MOV_X
   \   000086   12....       LCALL   ?Subroutine45 & 0xFFFF
   \                     ??CrossCallReturnLabel_278:
   \   000089   78..         MOV     R0,#?V0 + 0
   \   00008B   12....       LCALL   ?L_MOV_TO_X
   4021                
   4022                  // update outgoing frame counter
   4023                  (*tclkTxFrmCntr)++;
   \   00008E   90....       MOV     DPTR,#__Constant_1
   \   000091   78..         MOV     R0,#?V0 + 0
   \   000093   12....       LCALL   ?L_MOV_X
   \   000096   90....       MOV     DPTR,#TCLinkKeyFrmCntr
   \   000099   78..         MOV     R0,#?V0 + 0
   \   00009B   12....       LCALL   ?L_ADD_TO_X
   4024                  
   4025          #if defined ( NV_RESTORE )
   4026                  // write periodically to NV
   4027                  if ( !(*tclkTxFrmCntr % MAX_TCLK_FRAMECOUNTER_CHANGES) )
   4028                  {
   4029                    // set the flag to write key to NV
   4030                    TCLinkKeyFrmCntr[i].pendingFlag = TRUE;
   4031                    
   4032                    // Notify the ZDApp that the frame counter has changed.
   4033                    osal_set_event( ZDAppTaskID, ZDO_TCLK_FRAMECOUNTER_CHANGE );
   4034                  }        
   4035          #endif
   4036                  
   4037                  return ZSuccess;
   \   00009E   7900         MOV     R1,#0x0
   \   0000A0   8033         SJMP    ??APSME_TCLinkKeyLoad_2
   4038                }
   4039              }
   4040            }
   4041              
   4042            // If no TC link key found, remove the device from the address manager
   4043            if ( AddrMgrEntryLookupNwk( &addrEntry ) == TRUE )
   \                     ??APSME_TCLinkKeyLoad_0:
   \   0000A2                ; Setup parameters for call to function AddrMgrEntryLookupNwk
   \   0000A2   85..82       MOV     DPL,?XSP + 0
   \   0000A5   85..83       MOV     DPH,?XSP + 1
   \   0000A8   AA82         MOV     R2,DPL
   \   0000AA   AB83         MOV     R3,DPH
   \   0000AC   12....       LCALL   ??AddrMgrEntryLookupNwk?relay
   \   0000AF   E9           MOV     A,R1
   \   0000B0   6401         XRL     A,#0x1
   \   0000B2   700D         JNZ     ??APSME_TCLinkKeyLoad_3
   4044            {
   4045              AddrMgrEntryRelease( &addrEntry );
   \   0000B4                ; Setup parameters for call to function AddrMgrEntryRelease
   \   0000B4   85..82       MOV     DPL,?XSP + 0
   \   0000B7   85..83       MOV     DPH,?XSP + 1
   \   0000BA   AA82         MOV     R2,DPL
   \   0000BC   AB83         MOV     R3,DPH
   \   0000BE   12....       LCALL   ??AddrMgrEntryRelease?relay
   4046            }
   4047            
   4048              // clear copy of key in RAM 
   4049            osal_memset( &tcLinkKey, 0x00, sizeof(APSME_TCLinkKey_t) );
   \                     ??APSME_TCLinkKeyLoad_3:
   \   0000C1                ; Setup parameters for call to function osal_memset
   \   0000C1   7C20         MOV     R4,#0x20
   \   0000C3   7D00         MOV     R5,#0x0
   \   0000C5   7900         MOV     R1,#0x0
   \   0000C7   740D         MOV     A,#0xd
   \   0000C9   12....       LCALL   ?XSTACK_DISP0_8
   \   0000CC   AA82         MOV     R2,DPL
   \   0000CE   AB83         MOV     R3,DPH
   \   0000D0   12....       LCALL   ??osal_memset?relay
   4050          
   4051            return ZSecNoKey;
   \   0000D3   79A1         MOV     R1,#-0x5f
   \                     ??APSME_TCLinkKeyLoad_2:
   \   0000D5   742D         MOV     A,#0x2d
   \   0000D7   02....       LJMP    ??Subroutine128_0 & 0xFFFF
   4052          }
   4053          
   4054          /******************************************************************************
   4055           * @fn          APSME_IsDefaultTCLK
   4056           *
   4057           * @brief       Return true or false based on the extended address.  If the 
   4058           *              input ext address is all FFs, it means the trust center link
   4059           *              assoiciated with the address is the default trust center link key
   4060           *
   4061           * @param       extAddr - [in] extended address
   4062           *
   4063           * @return      uint8 TRUE/FALSE
   4064           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   4065          uint8 APSME_IsDefaultTCLK( uint8 *extAddr )
   \                     APSME_IsDefaultTCLK:
   4066          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   4067            uint8 i = 0;
   \   000004   7C00         MOV     R4,#0x0
   4068            
   4069            if( extAddr == NULL )
   \   000006   EA           MOV     A,R2
   \   000007   7001         JNZ     ??APSME_IsDefaultTCLK_0
   \   000009   EB           MOV     A,R3
   \                     ??APSME_IsDefaultTCLK_0:
   \   00000A   701A         JNZ     ??APSME_IsDefaultTCLK_1
   4070            {
   4071              return FALSE;
   \                     ??APSME_IsDefaultTCLK_2:
   \   00000C   7900         MOV     R1,#0x0
   \   00000E   801F         SJMP    ??APSME_IsDefaultTCLK_3
   4072            }
   4073            
   4074            while( i++ < Z_EXTADDR_LEN )
   4075            {
   4076              if( *extAddr++ != 0xFF )
   \                     ??APSME_IsDefaultTCLK_4:
   \   000010   EA           MOV     A,R2
   \   000011   F8           MOV     R0,A
   \   000012   EB           MOV     A,R3
   \   000013   F9           MOV     R1,A
   \   000014   8882         MOV     DPL,R0
   \   000016   8983         MOV     DPH,R1
   \   000018   A3           INC     DPTR
   \   000019   AA82         MOV     R2,DPL
   \   00001B   AB83         MOV     R3,DPH
   \   00001D   8882         MOV     DPL,R0
   \   00001F   8983         MOV     DPH,R1
   \   000021   E0           MOVX    A,@DPTR
   \   000022   64FF         XRL     A,#0xff
   \   000024   70E6         JNZ     ??APSME_IsDefaultTCLK_2
   4077              {
   4078                return FALSE;
   4079              }
   4080            }
   \                     ??APSME_IsDefaultTCLK_1:
   \   000026   EC           MOV     A,R4
   \   000027   0C           INC     R4
   \   000028   C3           CLR     C
   \   000029   9408         SUBB    A,#0x8
   \   00002B   40E3         JC      ??APSME_IsDefaultTCLK_4
   4081            
   4082            return TRUE;
   \   00002D   7901         MOV     R1,#0x1
   \                     ??APSME_IsDefaultTCLK_3:
   \   00002F   02....       LJMP    ??Subroutine125_0 & 0xFFFF
   4083          }
   4084          
   4085          /******************************************************************************
   4086           * @fn          ZDSecMgrNwkKeyInit
   4087           *
   4088           * @brief       Initialize the NV items for 
   4089           *                  ZCD_NV_NWKKEY, 
   4090           *                  ZCD_NV_NWK_ACTIVE_KEY_INFO and 
   4091           *                  ZCD_NV_NWK_ALTERN_KEY_INFO 
   4092           *               
   4093           * @param       setDefault
   4094           *
   4095           * @return      none
   4096           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   4097          void ZDSecMgrNwkKeyInit(uint8 setDefault)
   \                     ZDSecMgrNwkKeyInit:
   4098          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 38
   \   000005   74DA         MOV     A,#-0x26
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   4099            uint8 status;
   4100            nwkKeyDesc nwkKey;
   4101          
   4102            // Initialize NV items for NWK key, this structure contains the frame counter
   4103            // and is only used when NV_RESTORE is enabled
   4104            nwkActiveKeyItems keyItems;  
   4105              
   4106            osal_memset( &keyItems, 0, sizeof( nwkActiveKeyItems ) );
   \   00000A                ; Setup parameters for call to function osal_memset
   \   00000A   7C15         MOV     R4,#0x15
   \   00000C   7D00         MOV     R5,#0x0
   \   00000E   7900         MOV     R1,#0x0
   \   000010   7411         MOV     A,#0x11
   \   000012   12....       LCALL   ?XSTACK_DISP0_8
   \   000015   AA82         MOV     R2,DPL
   \   000017   AB83         MOV     R3,DPH
   \   000019   12....       LCALL   ??osal_memset?relay
   4107            
   4108            status = osal_nv_item_init( ZCD_NV_NWKKEY, sizeof(nwkActiveKeyItems), (void *)&keyItems );
   4109          
   4110          #if defined ( NV_RESTORE )
   4111            // reset the values of NV items if NV_RESTORE is not enabled
   4112            if ((status == SUCCESS) && (setDefault == TRUE))
   4113            {
   4114              // clear NV data to default values
   4115              osal_nv_write( ZCD_NV_NWKKEY, 0, sizeof(nwkActiveKeyItems), &keyItems );
   4116            }
   4117          #else
   4118            (void)setDefault;   // to eliminate compiler warning
   4119            
   4120            // reset the values of NV items if NV_RESTORE is not enabled
   4121            if (status == SUCCESS)
   \   00001C                ; Setup parameters for call to function osal_nv_item_init
   \   00001C   7411         MOV     A,#0x11
   \   00001E   12....       LCALL   ?XSTACK_DISP0_8
   \   000021   8582..       MOV     ?V0 + 0,DPL
   \   000024   8583..       MOV     ?V0 + 1,DPH
   \   000027   78..         MOV     R0,#?V0 + 0
   \   000029   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00002C   7C15         MOV     R4,#0x15
   \   00002E   7D00         MOV     R5,#0x0
   \   000030   7A82         MOV     R2,#-0x7e
   \   000032   12....       LCALL   ?Subroutine38 & 0xFFFF
   \                     ??CrossCallReturnLabel_335:
   \   000035   12....       LCALL   ?DEALLOC_XSTACK8
   \   000038   E9           MOV     A,R1
   \   000039   701E         JNZ     ??ZDSecMgrNwkKeyInit_0
   4122            {
   4123              osal_nv_write( ZCD_NV_NWKKEY, 0, sizeof(nwkActiveKeyItems), &keyItems );
   \   00003B                ; Setup parameters for call to function osal_nv_write
   \   00003B   78..         MOV     R0,#?V0 + 0
   \   00003D   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000040   75..15       MOV     ?V0 + 0,#0x15
   \   000043   75..00       MOV     ?V0 + 1,#0x0
   \   000046   78..         MOV     R0,#?V0 + 0
   \   000048   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00004B   7C00         MOV     R4,#0x0
   \   00004D   7D00         MOV     R5,#0x0
   \   00004F   7A82         MOV     R2,#-0x7e
   \   000051   7B00         MOV     R3,#0x0
   \   000053   12....       LCALL   ??Subroutine110_0 & 0xFFFF
   4124            }
   \                     ??CrossCallReturnLabel_181:
   \   000056   12....       LCALL   ?DEALLOC_XSTACK8
   4125          #endif // defined (NV_RESTORE)    
   4126          
   4127            // Initialize NV items for NWK Active and Alternate keys. These items are used 
   4128            // all the time, independently of NV_RESTORE being set or not
   4129            osal_memset( &nwkKey, 0x00, sizeof(nwkKey) );
   \                     ??ZDSecMgrNwkKeyInit_0:
   \   000059                ; Setup parameters for call to function osal_memset
   \   000059   7C11         MOV     R4,#0x11
   \   00005B   7D00         MOV     R5,#0x0
   \   00005D   7900         MOV     R1,#0x0
   \   00005F   85..82       MOV     DPL,?XSP + 0
   \   000062   85..83       MOV     DPH,?XSP + 1
   \   000065   12....       LCALL   ?Subroutine41 & 0xFFFF
   4130          
   4131            status = osal_nv_item_init( ZCD_NV_NWK_ACTIVE_KEY_INFO, sizeof(nwkKey), &nwkKey);
   4132            
   4133          #if defined ( NV_RESTORE )
   4134            // reset the values of NV items if NV_RESTORE is not enabled
   4135            if ((status == SUCCESS) && (setDefault == TRUE))
   4136            {
   4137              // clear NV data to default values
   4138              osal_nv_write( ZCD_NV_NWK_ACTIVE_KEY_INFO, 0, sizeof(nwkKey), &nwkKey );
   4139            }
   4140          #else
   4141            // reset the values of NV items if NV_RESTORE is not enabled
   4142            if (status == SUCCESS)
   \                     ??CrossCallReturnLabel_59:
   \   000068   8582..       MOV     ?V0 + 0,DPL
   \   00006B   8583..       MOV     ?V0 + 1,DPH
   \   00006E   78..         MOV     R0,#?V0 + 0
   \   000070   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000073   7C11         MOV     R4,#0x11
   \   000075   7D00         MOV     R5,#0x0
   \   000077   7A3A         MOV     R2,#0x3a
   \   000079   12....       LCALL   ?Subroutine38 & 0xFFFF
   \                     ??CrossCallReturnLabel_336:
   \   00007C   12....       LCALL   ?DEALLOC_XSTACK8
   \   00007F   E9           MOV     A,R1
   \   000080   701E         JNZ     ??ZDSecMgrNwkKeyInit_1
   4143            {
   4144              osal_nv_write( ZCD_NV_NWK_ACTIVE_KEY_INFO, 0, sizeof(nwkKey), &nwkKey );
   \   000082                ; Setup parameters for call to function osal_nv_write
   \   000082   78..         MOV     R0,#?V0 + 0
   \   000084   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000087   75..11       MOV     ?V0 + 0,#0x11
   \   00008A   75..00       MOV     ?V0 + 1,#0x0
   \   00008D   78..         MOV     R0,#?V0 + 0
   \   00008F   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000092   7C00         MOV     R4,#0x0
   \   000094   7D00         MOV     R5,#0x0
   \   000096   7A3A         MOV     R2,#0x3a
   \   000098   7B00         MOV     R3,#0x0
   \   00009A   12....       LCALL   ??Subroutine110_0 & 0xFFFF
   4145            }
   \                     ??CrossCallReturnLabel_182:
   \   00009D   12....       LCALL   ?DEALLOC_XSTACK8
   4146          #endif // defined (NV_RESTORE)    
   4147            
   4148            status = osal_nv_item_init( ZCD_NV_NWK_ALTERN_KEY_INFO, sizeof(nwkKey), &nwkKey );
   4149            
   4150          #if defined ( NV_RESTORE )
   4151            // reset the values of NV items if NV_RESTORE is not enabled
   4152            if ((status == SUCCESS) && (setDefault == TRUE))
   4153            {
   4154              // clear NV data to default values
   4155              osal_nv_write( ZCD_NV_NWK_ALTERN_KEY_INFO, 0, sizeof(nwkKey), &nwkKey );
   4156            }
   4157          #else
   4158            // reset the values of NV items if NV_RESTORE is not enabled
   4159            if (status == SUCCESS)
   \                     ??ZDSecMgrNwkKeyInit_1:
   \   0000A0                ; Setup parameters for call to function osal_nv_item_init
   \   0000A0   85..82       MOV     DPL,?XSP + 0
   \   0000A3   85..83       MOV     DPH,?XSP + 1
   \   0000A6   8582..       MOV     ?V0 + 0,DPL
   \   0000A9   8583..       MOV     ?V0 + 1,DPH
   \   0000AC   78..         MOV     R0,#?V0 + 0
   \   0000AE   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000B1   7C11         MOV     R4,#0x11
   \   0000B3   7D00         MOV     R5,#0x0
   \   0000B5   7A3B         MOV     R2,#0x3b
   \   0000B7   12....       LCALL   ?Subroutine38 & 0xFFFF
   \                     ??CrossCallReturnLabel_337:
   \   0000BA   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000BD   E9           MOV     A,R1
   \   0000BE   701E         JNZ     ??ZDSecMgrNwkKeyInit_2
   4160            {
   4161              osal_nv_write( ZCD_NV_NWK_ALTERN_KEY_INFO, 0, sizeof(nwkKey), &nwkKey );
   \   0000C0                ; Setup parameters for call to function osal_nv_write
   \   0000C0   78..         MOV     R0,#?V0 + 0
   \   0000C2   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000C5   75..11       MOV     ?V0 + 0,#0x11
   \   0000C8   75..00       MOV     ?V0 + 1,#0x0
   \   0000CB   78..         MOV     R0,#?V0 + 0
   \   0000CD   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000D0   7C00         MOV     R4,#0x0
   \   0000D2   7D00         MOV     R5,#0x0
   \   0000D4   7A3B         MOV     R2,#0x3b
   \   0000D6   7B00         MOV     R3,#0x0
   \   0000D8   12....       LCALL   ??Subroutine110_0 & 0xFFFF
   4162            }
   \                     ??CrossCallReturnLabel_183:
   \   0000DB   12....       LCALL   ?DEALLOC_XSTACK8
   4163          #endif // defined (NV_RESTORE)
   4164          
   4165          }
   \                     ??ZDSecMgrNwkKeyInit_2:
   \   0000DE   7426         MOV     A,#0x26
   \   0000E0   02....       LJMP    ??Subroutine118_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine38:
   \   000000   7B00         MOV     R3,#0x0
   \   000002                REQUIRE ??Subroutine146_0
   \   000002                ; // Fall through to label ??Subroutine146_0
   4166          
   4167          /*********************************************************************
   4168           * @fn          ZDSecMgrReadKeyFromNv
   4169           *
   4170           * @brief       Looks for a specific key in NV based on Index value
   4171           *
   4172           * @param   keyNvId - Index of key to look in NV
   4173           *                    valid values are:
   4174           *                    ZCD_NV_NWK_ACTIVE_KEY_INFO    
   4175           *                    ZCD_NV_NWK_ALTERN_KEY_INFO 
   4176           *                    ZCD_NV_TCLK_TABLE_START + <offset_in_table>
   4177           *                    ZCD_NV_APS_LINK_KEY_DATA_START + <offset_in_table>
   4178           *                    ZCD_NV_MASTER_KEY_DATA_START + <offset_in_table>
   4179           *                    ZCD_NV_PRECFGKEY
   4180           *
   4181           * @param  *keyinfo - Data is read into this buffer.
   4182           *
   4183           * @return  SUCCESS if NV data was copied to the keyinfo parameter .
   4184           *          Otherwise, NV_OPER_FAILED for failure.
   4185           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   4186          ZStatus_t ZDSecMgrReadKeyFromNv(uint16 keyNvId, void *keyinfo)
   \                     ZDSecMgrReadKeyFromNv:
   4187          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   4188            if ((keyNvId == ZCD_NV_NWK_ACTIVE_KEY_INFO) ||
   4189                (keyNvId == ZCD_NV_NWK_ALTERN_KEY_INFO))
   \   000005   743A         MOV     A,#0x3a
   \   000007   6A           XRL     A,R2
   \   000008   7001         JNZ     ??ZDSecMgrReadKeyFromNv_0
   \   00000A   EB           MOV     A,R3
   \                     ??ZDSecMgrReadKeyFromNv_0:
   \   00000B   6008         JZ      ??ZDSecMgrReadKeyFromNv_1
   \   00000D   743B         MOV     A,#0x3b
   \   00000F   6A           XRL     A,R2
   \   000010   7001         JNZ     ??ZDSecMgrReadKeyFromNv_2
   \   000012   EB           MOV     A,R3
   \                     ??ZDSecMgrReadKeyFromNv_2:
   \   000013   7021         JNZ     ??ZDSecMgrReadKeyFromNv_3
   4190            {
   4191              // get NWK active or alternate key from NV
   4192              return (osal_nv_read(keyNvId, 
   4193                                   osal_offsetof(nwkKeyDesc, key), 
   4194                                   SEC_KEY_LEN, 
   4195                                   keyinfo));
   \                     ??ZDSecMgrReadKeyFromNv_1:
   \   000015                ; Setup parameters for call to function osal_nv_read
   \   000015   8C..         MOV     ?V0 + 0,R4
   \   000017   8D..         MOV     ?V0 + 1,R5
   \   000019   78..         MOV     R0,#?V0 + 0
   \   00001B   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00001E   75..10       MOV     ?V0 + 0,#0x10
   \   000021   75..00       MOV     ?V0 + 1,#0x0
   \   000024   78..         MOV     R0,#?V0 + 0
   \   000026   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000029   7C01         MOV     R4,#0x1
   \                     ??ZDSecMgrReadKeyFromNv_4:
   \   00002B   7D00         MOV     R5,#0x0
   4196            }
   \                     ??ZDSecMgrReadKeyFromNv_5:
   \   00002D   12....       LCALL   ??Subroutine145_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_333:
   \   000030   12....       LCALL   ?DEALLOC_XSTACK8
   \   000033   02....       LJMP    ??ZDSecMgrReadKeyFromNv_6 & 0xFFFF
   4197            else if ((keyNvId >= ZCD_NV_TCLK_TABLE_START) &&
   4198                     (keyNvId < (ZCD_NV_TCLK_TABLE_START + ZDSECMGR_TC_DEVICE_MAX)))
   \                     ??ZDSecMgrReadKeyFromNv_3:
   \   000036   74FF         MOV     A,#-0x1
   \   000038   2A           ADD     A,R2
   \   000039   F8           MOV     R0,A
   \   00003A   74FE         MOV     A,#-0x2
   \   00003C   3B           ADDC    A,R3
   \   00003D   F9           MOV     R1,A
   \   00003E   E8           MOV     A,R0
   \   00003F   7001         JNZ     ??ZDSecMgrReadKeyFromNv_7
   \   000041   E9           MOV     A,R1
   \                     ??ZDSecMgrReadKeyFromNv_7:
   \   000042   7018         JNZ     ??ZDSecMgrReadKeyFromNv_8
   4199            {
   4200              // Read entry keyNvId of the TC link key table from NV. keyNvId should be
   4201              // ZCD_NV_TCLK_TABLE_START + <offset_in_table>
   4202              return (osal_nv_read(keyNvId, 
   4203                                   osal_offsetof(APSME_TCLinkKey_t, key), 
   4204                                   SEC_KEY_LEN, 
   4205                                   keyinfo));
   \   000044                ; Setup parameters for call to function osal_nv_read
   \   000044   8C..         MOV     ?V0 + 0,R4
   \   000046   8D..         MOV     ?V0 + 1,R5
   \   000048   78..         MOV     R0,#?V0 + 0
   \   00004A   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00004D   75..10       MOV     ?V0 + 0,#0x10
   \   000050   75..00       MOV     ?V0 + 1,#0x0
   \   000053   78..         MOV     R0,#?V0 + 0
   \   000055   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000058   7C08         MOV     R4,#0x8
   \   00005A   80CF         SJMP    ??ZDSecMgrReadKeyFromNv_4
   4206            }
   4207            else if ((keyNvId >= ZCD_NV_APS_LINK_KEY_DATA_START) &&
   4208                     (keyNvId < (ZCD_NV_APS_LINK_KEY_DATA_START + ZDSECMGR_ENTRY_MAX)))
   \                     ??ZDSecMgrReadKeyFromNv_8:
   \   00005C   19           DEC     R1
   \   00005D   C3           CLR     C
   \   00005E   E8           MOV     A,R0
   \   00005F   9403         SUBB    A,#0x3
   \   000061   E9           MOV     A,R1
   \   000062   9400         SUBB    A,#0x0
   \   000064   501A         JNC     ??ZDSecMgrReadKeyFromNv_9
   4209            {
   4210              // Read entry keyNvId of the APS link key table from NV. keyNvId should be
   4211              // ZCD_NV_APS_LINK_KEY_DATA_START + <offset_in_table>
   4212              return (osal_nv_read(keyNvId, 
   4213                                   osal_offsetof(APSME_LinkKeyData_t, key), 
   4214                                   SEC_KEY_LEN, 
   4215                                   keyinfo));
   \   000066                ; Setup parameters for call to function osal_nv_read
   \   000066   8C..         MOV     ?V0 + 0,R4
   \   000068   8D..         MOV     ?V0 + 1,R5
   \   00006A   78..         MOV     R0,#?V0 + 0
   \   00006C   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00006F   75..10       MOV     ?V0 + 0,#0x10
   \   000072   75..00       MOV     ?V0 + 1,#0x0
   \   000075   78..         MOV     R0,#?V0 + 0
   \   000077   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00007A   7C00         MOV     R4,#0x0
   \   00007C   7D00         MOV     R5,#0x0
   \                     ??ZDSecMgrReadKeyFromNv_10:
   \   00007E   80AD         SJMP    ??ZDSecMgrReadKeyFromNv_5
   4216            }
   4217            else if ((keyNvId >= ZCD_NV_MASTER_KEY_DATA_START) &&
   4218                     (keyNvId < (ZCD_NV_MASTER_KEY_DATA_START + ZDSECMGR_MASTERKEY_MAX)))
   \                     ??ZDSecMgrReadKeyFromNv_9:
   \   000080   19           DEC     R1
   \   000081   C3           CLR     C
   \   000082   E8           MOV     A,R0
   \   000083   9403         SUBB    A,#0x3
   \   000085   E9           MOV     A,R1
   \   000086   9400         SUBB    A,#0x0
   \   000088   5018         JNC     ??ZDSecMgrReadKeyFromNv_11
   4219            {
   4220              // Read entry keyNvId of the MASTER key table from NV. keyNvId should be
   4221              // ZCD_NV_MASTER_KEY_DATA_START + <offset_in_table>
   4222              return (osal_nv_read(keyNvId, 
   4223                                   osal_offsetof(ZDSecMgrMasterKeyData_t, key), 
   4224                                   SEC_KEY_LEN, 
   4225                                   keyinfo));
   \   00008A                ; Setup parameters for call to function osal_nv_read
   \   00008A   8C..         MOV     ?V0 + 0,R4
   \   00008C   8D..         MOV     ?V0 + 1,R5
   \   00008E   78..         MOV     R0,#?V0 + 0
   \   000090   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000093   75..10       MOV     ?V0 + 0,#0x10
   \   000096   75..00       MOV     ?V0 + 1,#0x0
   \   000099   78..         MOV     R0,#?V0 + 0
   \   00009B   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00009E   7C02         MOV     R4,#0x2
   \   0000A0   8089         SJMP    ??ZDSecMgrReadKeyFromNv_4
   4226            }
   4227            else if (keyNvId == ZCD_NV_PRECFGKEY)
   \                     ??ZDSecMgrReadKeyFromNv_11:
   \   0000A2   7462         MOV     A,#0x62
   \   0000A4   6A           XRL     A,R2
   \   0000A5   7001         JNZ     ??ZDSecMgrReadKeyFromNv_12
   \   0000A7   EB           MOV     A,R3
   \                     ??ZDSecMgrReadKeyFromNv_12:
   \   0000A8   701E         JNZ     ??ZDSecMgrReadKeyFromNv_13
   4228            {
   4229              // Read entry keyNvId of the Preconfig key from NV. 
   4230              return (osal_nv_read(keyNvId, 
   4231                                   0, 
   4232                                   SEC_KEY_LEN, 
   4233                                   keyinfo));
   \   0000AA                ; Setup parameters for call to function osal_nv_read
   \   0000AA   8C..         MOV     ?V0 + 0,R4
   \   0000AC   8D..         MOV     ?V0 + 1,R5
   \   0000AE   78..         MOV     R0,#?V0 + 0
   \   0000B0   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000B3   75..10       MOV     ?V0 + 0,#0x10
   \   0000B6   75..00       MOV     ?V0 + 1,#0x0
   \   0000B9   78..         MOV     R0,#?V0 + 0
   \   0000BB   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000BE   7C00         MOV     R4,#0x0
   \   0000C0   7D00         MOV     R5,#0x0
   \   0000C2   7A62         MOV     R2,#0x62
   \   0000C4   7B00         MOV     R3,#0x0
   \   0000C6   80B6         SJMP    ??ZDSecMgrReadKeyFromNv_10
   4234            }
   4235            
   4236            return NV_OPER_FAILED;
   \                     ??ZDSecMgrReadKeyFromNv_13:
   \   0000C8   790A         MOV     R1,#0xa
   \                     ??ZDSecMgrReadKeyFromNv_6:
   \   0000CA   02....       LJMP    ??Subroutine119_0 & 0xFFFF
   4237          }
   4238          
   4239          /******************************************************************************
   4240           * @fn          ZDSecMgrApsLinkKeyInit
   4241           *
   4242           * @brief       Initialize the NV table for Application link keys
   4243           *           
   4244           * @param       none
   4245           *
   4246           * @return      none
   4247           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   4248          void ZDSecMgrApsLinkKeyInit(void)
   \                     ZDSecMgrApsLinkKeyInit:
   4249          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 24
   \   000005   74E8         MOV     A,#-0x18
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   4250            APSME_LinkKeyData_t pApsLinkKey;
   4251            uint8 i;
   4252            uint8 status;
   4253            
   4254            // Initialize all NV items for APS link key, if not exist already.
   4255            osal_memset( &pApsLinkKey, 0x00, sizeof(APSME_LinkKeyData_t) );
   \   00000A                ; Setup parameters for call to function osal_memset
   \   00000A   7C18         MOV     R4,#0x18
   \   00000C   7D00         MOV     R5,#0x0
   \   00000E   7900         MOV     R1,#0x0
   \   000010   85..82       MOV     DPL,?XSP + 0
   \   000013   85..83       MOV     DPH,?XSP + 1
   \   000016   AA82         MOV     R2,DPL
   \   000018   AB83         MOV     R3,DPH
   \   00001A   12....       LCALL   ??osal_memset?relay
   4256            
   4257            for( i = 0; i < ZDSECMGR_ENTRY_MAX; i++ )
   \   00001D   7E00         MOV     R6,#0x0
   4258            {
   4259              status = osal_nv_item_init( (ZCD_NV_APS_LINK_KEY_DATA_START + i), 
   4260                                         sizeof(APSME_LinkKeyData_t), &pApsLinkKey );
   4261              
   4262          #if defined ( NV_RESTORE )
   4263              (void)status;   // to eliminate compiler warning
   4264          #else
   4265              // reset the values of NV items if NV_RESTORE is not enabled
   4266              if (status == SUCCESS)
   \                     ??ZDSecMgrApsLinkKeyInit_0:
   \   00001F                ; Setup parameters for call to function osal_nv_item_init
   \   00001F   85..82       MOV     DPL,?XSP + 0
   \   000022   85..83       MOV     DPH,?XSP + 1
   \   000025   8582..       MOV     ?V0 + 0,DPL
   \   000028   8583..       MOV     ?V0 + 1,DPH
   \   00002B   78..         MOV     R0,#?V0 + 0
   \   00002D   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000030   7C18         MOV     R4,#0x18
   \   000032   7D00         MOV     R5,#0x0
   \   000034   8E..         MOV     ?V0 + 0,R6
   \   000036   7401         MOV     A,#0x1
   \   000038   25..         ADD     A,?V0 + 0
   \   00003A   FA           MOV     R2,A
   \   00003B   7402         MOV     A,#0x2
   \   00003D   3400         ADDC    A,#0x0
   \   00003F   FB           MOV     R3,A
   \   000040   12....       LCALL   ??Subroutine146_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_340:
   \   000043   12....       LCALL   ?DEALLOC_XSTACK8
   \   000046   E9           MOV     A,R1
   \   000047   702B         JNZ     ??ZDSecMgrApsLinkKeyInit_1
   4267              {
   4268                osal_nv_write( (ZCD_NV_APS_LINK_KEY_DATA_START + i), 0, 
   4269                              sizeof(APSME_LinkKeyData_t), &pApsLinkKey );
   \   000049                ; Setup parameters for call to function osal_nv_write
   \   000049   85..82       MOV     DPL,?XSP + 0
   \   00004C   8582..       MOV     ?V0 + 0,DPL
   \   00004F   78..         MOV     R0,#?V0 + 0
   \   000051   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000054   75..18       MOV     ?V0 + 0,#0x18
   \   000057   75..00       MOV     ?V0 + 1,#0x0
   \   00005A   78..         MOV     R0,#?V0 + 0
   \   00005C   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00005F   7C00         MOV     R4,#0x0
   \   000061   7D00         MOV     R5,#0x0
   \   000063   8E..         MOV     ?V0 + 0,R6
   \   000065   7401         MOV     A,#0x1
   \   000067   25..         ADD     A,?V0 + 0
   \   000069   FA           MOV     R2,A
   \   00006A   7402         MOV     A,#0x2
   \   00006C   3400         ADDC    A,#0x0
   \   00006E   12....       LCALL   ??Subroutine109_0 & 0xFFFF
   4270                
   4271              }
   4272          #endif // defined (NV_RESTORE)
   4273            }
   \                     ??CrossCallReturnLabel_177:
   \   000071   12....       LCALL   ?DEALLOC_XSTACK8
   \                     ??ZDSecMgrApsLinkKeyInit_1:
   \   000074   0E           INC     R6
   \   000075   EE           MOV     A,R6
   \   000076   C3           CLR     C
   \   000077   9403         SUBB    A,#0x3
   \   000079   40A4         JC      ??ZDSecMgrApsLinkKeyInit_0
   4274          }
   \   00007B   7418         MOV     A,#0x18
   \   00007D   02....       LJMP    ??Subroutine118_0 & 0xFFFF
   4275          
   4276          /******************************************************************************
   4277           * @fn          ZDSecMgrInitNVKeyTables
   4278           *
   4279           * @brief       Initialize the NV table for All keys: NWK, Master, TCLK and APS
   4280           *           
   4281           * @param       setDefault - TRUE to set default values 
   4282           *
   4283           * @return      none
   4284           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   4285          void ZDSecMgrInitNVKeyTables(uint8 setDefault)
   \                     ZDSecMgrInitNVKeyTables:
   4286          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   E9           MOV     A,R1
   \   000006   FE           MOV     R6,A
   4287            ZDSecMgrNwkKeyInit(setDefault);
   \   000007                ; Setup parameters for call to function ZDSecMgrNwkKeyInit
   \   000007   12....       LCALL   ??ZDSecMgrNwkKeyInit?relay
   4288            ZDSecMgrMasterKeyInit();
   \   00000A                ; Setup parameters for call to function ZDSecMgrMasterKeyInit
   \   00000A   12....       LCALL   ??ZDSecMgrMasterKeyInit?relay
   4289            ZDSecMgrApsLinkKeyInit();
   \   00000D                ; Setup parameters for call to function ZDSecMgrApsLinkKeyInit
   \   00000D   12....       LCALL   ??ZDSecMgrApsLinkKeyInit?relay
   4290            APSME_TCLinkKeyInit(setDefault);
   \   000010                ; Setup parameters for call to function APSME_TCLinkKeyInit
   \   000010   EE           MOV     A,R6
   \   000011   F9           MOV     R1,A
   \   000012   12....       LCALL   ??APSME_TCLinkKeyInit?relay
   4291          }
   \   000015   02....       LJMP    ??Subroutine133_0 & 0xFFFF
   4292          
   4293          /******************************************************************************
   4294           * @fn          ZDSecMgrSaveApsLinkKey
   4295           *
   4296           * @brief       Save APS Link Key to NV. It will loop through all the keys  
   4297           *              to see which one to save.
   4298           *           
   4299           * @param       none
   4300           *
   4301           * @return      none
   4302           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   4303          void ZDSecMgrSaveApsLinkKey(void)
   \                     ZDSecMgrSaveApsLinkKey:
   4304          {
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 0
   4305            APSME_LinkKeyData_t *pKeyData = NULL;
   4306            int i;
   4307            
   4308            pKeyData = (APSME_LinkKeyData_t *)osal_mem_alloc(sizeof(APSME_LinkKeyData_t));
   \   000005                ; Setup parameters for call to function osal_mem_alloc
   \   000005   12....       LCALL   ?Subroutine75 & 0xFFFF
   4309            
   4310            if (pKeyData != NULL)
   \                     ??CrossCallReturnLabel_116:
   \   000008   7001         JNZ     ??ZDSecMgrSaveApsLinkKey_0
   \   00000A   EB           MOV     A,R3
   \                     ??ZDSecMgrSaveApsLinkKey_0:
   \   00000B   7003         JNZ     $+5
   \   00000D   02....       LJMP    ??CrossCallReturnLabel_57 & 0xFFFF
   4311            {          
   4312              // checks all pending flags to know which one to save
   4313              for (i = 0; i < ZDSECMGR_ENTRY_MAX; i++)
   \   000010   7E00         MOV     R6,#0x0
   \   000012   7F00         MOV     R7,#0x0
   4314              {
   4315                if (ApsLinkKeyFrmCntr[i].pendingFlag == TRUE)
   \                     ??ZDSecMgrSaveApsLinkKey_1:
   \   000014   EE           MOV     A,R6
   \   000015   F8           MOV     R0,A
   \   000016   EF           MOV     A,R7
   \   000017   F9           MOV     R1,A
   \   000018   E8           MOV     A,R0
   \   000019   75F009       MOV     B,#0x9
   \   00001C   A4           MUL     AB
   \   00001D   F8           MOV     R0,A
   \   00001E   AAF0         MOV     R2,B
   \   000020   75F009       MOV     B,#0x9
   \   000023   E9           MOV     A,R1
   \   000024   A4           MUL     AB
   \   000025   2A           ADD     A,R2
   \   000026   F9           MOV     R1,A
   \   000027   E8           MOV     A,R0
   \   000028   24..         ADD     A,#((ApsLinkKeyFrmCntr + 8) & 0xff)
   \   00002A   F582         MOV     DPL,A
   \   00002C   E9           MOV     A,R1
   \   00002D   34..         ADDC    A,#(((ApsLinkKeyFrmCntr + 8) >> 8) & 0xff)
   \   00002F   F583         MOV     DPH,A
   \   000031   E0           MOVX    A,@DPTR
   \   000032   6401         XRL     A,#0x1
   \   000034   6003         JZ      $+5
   \   000036   02....       LJMP    ??ZDSecMgrSaveApsLinkKey_2 & 0xFFFF
   4316                {
   4317                  // retrieve key from NV
   4318                  if (osal_nv_read(ZCD_NV_APS_LINK_KEY_DATA_START + i, 0, 
   4319                                   sizeof(APSME_LinkKeyData_t), pKeyData) == SUCCESS)
   \   000039                ; Setup parameters for call to function osal_nv_read
   \   000039   78..         MOV     R0,#?V0 + 2
   \   00003B   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00003E   75..18       MOV     ?V0 + 0,#0x18
   \   000041   75..00       MOV     ?V0 + 1,#0x0
   \   000044   78..         MOV     R0,#?V0 + 0
   \   000046   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000049   7C00         MOV     R4,#0x0
   \   00004B   7D00         MOV     R5,#0x0
   \   00004D   7401         MOV     A,#0x1
   \   00004F   2E           ADD     A,R6
   \   000050   FA           MOV     R2,A
   \   000051   7402         MOV     A,#0x2
   \   000053   3F           ADDC    A,R7
   \   000054   FB           MOV     R3,A
   \   000055   12....       LCALL   ??Subroutine145_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_334:
   \   000058   12....       LCALL   ?DEALLOC_XSTACK8
   \   00005B   E9           MOV     A,R1
   \   00005C   706C         JNZ     ??ZDSecMgrSaveApsLinkKey_2
   4320                  {                
   4321                    pKeyData->txFrmCntr = ApsLinkKeyFrmCntr[i].txFrmCntr;
   \   00005E   EE           MOV     A,R6
   \   00005F   F8           MOV     R0,A
   \   000060   EF           MOV     A,R7
   \   000061   F9           MOV     R1,A
   \   000062   E8           MOV     A,R0
   \   000063   75F009       MOV     B,#0x9
   \   000066   A4           MUL     AB
   \   000067   F8           MOV     R0,A
   \   000068   AAF0         MOV     R2,B
   \   00006A   75F009       MOV     B,#0x9
   \   00006D   E9           MOV     A,R1
   \   00006E   A4           MUL     AB
   \   00006F   2A           ADD     A,R2
   \   000070   F9           MOV     R1,A
   \   000071   E8           MOV     A,R0
   \   000072   24..         ADD     A,#(ApsLinkKeyFrmCntr & 0xff)
   \   000074   F8           MOV     R0,A
   \   000075   E9           MOV     A,R1
   \   000076   34..         ADDC    A,#((ApsLinkKeyFrmCntr >> 8) & 0xff)
   \   000078   F9           MOV     R1,A
   \   000079   88..         MOV     ?V0 + 0,R0
   \   00007B   89..         MOV     ?V0 + 1,R1
   \   00007D   8882         MOV     DPL,R0
   \   00007F   F583         MOV     DPH,A
   \   000081   78..         MOV     R0,#?V0 + 4
   \   000083   12....       LCALL   ?L_MOV_X
   \   000086   E5..         MOV     A,?V0 + 2
   \   000088   2410         ADD     A,#0x10
   \   00008A   12....       LCALL   ??Subroutine139_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_288:
   \   00008D   12....       LCALL   ?L_MOV_TO_X
   4322                    pKeyData->rxFrmCntr = ApsLinkKeyFrmCntr[i].rxFrmCntr;
   \   000090   85..82       MOV     DPL,?V0 + 0
   \   000093   8983         MOV     DPH,R1
   \   000095   A3           INC     DPTR
   \   000096   A3           INC     DPTR
   \   000097   A3           INC     DPTR
   \   000098   A3           INC     DPTR
   \   000099   78..         MOV     R0,#?V0 + 4
   \   00009B   12....       LCALL   ?L_MOV_X
   \   00009E   12....       LCALL   ?Subroutine42 & 0xFFFF
   \                     ??CrossCallReturnLabel_290:
   \   0000A1   12....       LCALL   ?L_MOV_TO_X
   4323                    
   4324                    // Write the APS link key back to the NV
   4325                    osal_nv_write(ZCD_NV_APS_LINK_KEY_DATA_START + i, 0, 
   4326                                  sizeof(APSME_LinkKeyData_t), pKeyData);
   \   0000A4                ; Setup parameters for call to function osal_nv_write
   \   0000A4   78..         MOV     R0,#?V0 + 2
   \   0000A6   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000A9   75..18       MOV     ?V0 + 4,#0x18
   \   0000AC   75..00       MOV     ?V0 + 5,#0x0
   \   0000AF   78..         MOV     R0,#?V0 + 4
   \   0000B1   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000B4   12....       LCALL   ?Subroutine36 & 0xFFFF
   \                     ??CrossCallReturnLabel_171:
   \   0000B7   12....       LCALL   ?DEALLOC_XSTACK8
   4327                    
   4328                    // clear the pending write flag
   4329                    ApsLinkKeyFrmCntr[i].pendingFlag = FALSE;
   \   0000BA   E4           CLR     A
   \   0000BB   85..82       MOV     DPL,?V0 + 0
   \   0000BE   85..83       MOV     DPH,?V0 + 1
   \   0000C1   A3           INC     DPTR
   \   0000C2   A3           INC     DPTR
   \   0000C3   A3           INC     DPTR
   \   0000C4   A3           INC     DPTR
   \   0000C5   A3           INC     DPTR
   \   0000C6   A3           INC     DPTR
   \   0000C7   A3           INC     DPTR
   \   0000C8   A3           INC     DPTR
   \   0000C9   F0           MOVX    @DPTR,A
   4330                  }
   4331                }
   4332              }
   \                     ??ZDSecMgrSaveApsLinkKey_2:
   \   0000CA   12....       LCALL   ?Subroutine34 & 0xFFFF
   \                     ??CrossCallReturnLabel_49:
   \   0000CD   A2D2         MOV     C,0xD0 /* PSW */.2
   \   0000CF   65D0         XRL     A,PSW
   \   0000D1   33           RLC     A
   \   0000D2   5003         JNC     $+5
   \   0000D4   02....       LJMP    ??ZDSecMgrSaveApsLinkKey_1 & 0xFFFF
   4333              
   4334              // clear copy of key in RAM 
   4335              osal_memset( pKeyData, 0x00, sizeof(APSME_LinkKeyData_t) );
   \   0000D7                ; Setup parameters for call to function osal_memset
   \   0000D7   12....       LCALL   ?Subroutine40 & 0xFFFF
   4336              
   4337              osal_mem_free(pKeyData);
   4338            }  
   4339          }
   \                     ??CrossCallReturnLabel_57:
   \   0000DA   02....       LJMP    ?Subroutine7 & 0xFFFF
   4340          
   4341          /******************************************************************************
   4342           * @fn          ZDSecMgrSaveTCLinkKey
   4343           *
   4344           * @brief       Save TC Link Key to NV. It will loop through all the keys 
   4345           *              to see which one to save.
   4346           *           
   4347           * @param       none
   4348           *
   4349           * @return      none
   4350           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   4351          void ZDSecMgrSaveTCLinkKey(void)
   \                     ZDSecMgrSaveTCLinkKey:
   4352          {
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 0
   4353            APSME_TCLinkKey_t *pKeyData = NULL;
   4354            int i;
   4355            
   4356            pKeyData = (APSME_TCLinkKey_t *)osal_mem_alloc(sizeof(APSME_TCLinkKey_t));
   \   000005                ; Setup parameters for call to function osal_mem_alloc
   \   000005   7A20         MOV     R2,#0x20
   \   000007   12....       LCALL   ?Subroutine80 & 0xFFFF
   4357            
   4358            if (pKeyData != NULL)
   \                     ??CrossCallReturnLabel_122:
   \   00000A   7001         JNZ     ??ZDSecMgrSaveTCLinkKey_0
   \   00000C   EB           MOV     A,R3
   \                     ??ZDSecMgrSaveTCLinkKey_0:
   \   00000D   607E         JZ      ??ZDSecMgrSaveTCLinkKey_1
   4359            {          
   4360              for( i = 0; i < ZDSECMGR_TC_DEVICE_MAX; i++ )
   4361              {
   4362                if (TCLinkKeyFrmCntr[i].pendingFlag == TRUE)
   \   00000F   90....       MOV     DPTR,#(TCLinkKeyFrmCntr + 8)
   \   000012   E0           MOVX    A,@DPTR
   \   000013   6401         XRL     A,#0x1
   \   000015   7062         JNZ     ??ZDSecMgrSaveTCLinkKey_2
   4363                {
   4364                  if (osal_nv_read(ZCD_NV_TCLK_TABLE_START + i, 0, 
   4365                                   sizeof(APSME_TCLinkKey_t), pKeyData) == SUCCESS)
   \   000017                ; Setup parameters for call to function osal_nv_read
   \   000017   78..         MOV     R0,#?V0 + 0
   \   000019   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00001C   75..20       MOV     ?V0 + 2,#0x20
   \   00001F   75..00       MOV     ?V0 + 3,#0x0
   \   000022   78..         MOV     R0,#?V0 + 2
   \   000024   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000027   12....       LCALL   ?Subroutine76 & 0xFFFF
   \                     ??CrossCallReturnLabel_330:
   \   00002A   12....       LCALL   ?DEALLOC_XSTACK8
   \   00002D   E9           MOV     A,R1
   \   00002E   7049         JNZ     ??ZDSecMgrSaveTCLinkKey_2
   4366                  {                
   4367                    pKeyData->txFrmCntr = TCLinkKeyFrmCntr[i].txFrmCntr;
   \   000030   90....       MOV     DPTR,#TCLinkKeyFrmCntr
   \   000033   78..         MOV     R0,#?V0 + 4
   \   000035   12....       LCALL   ?L_MOV_X
   \   000038   E5..         MOV     A,?V0 + 0
   \   00003A   2418         ADD     A,#0x18
   \   00003C   F582         MOV     DPL,A
   \   00003E   E5..         MOV     A,?V0 + 1
   \   000040   12....       LCALL   ??Subroutine140_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_285:
   \   000043   12....       LCALL   ?L_MOV_TO_X
   4368                    pKeyData->rxFrmCntr = TCLinkKeyFrmCntr[i].rxFrmCntr;
   \   000046   90....       MOV     DPTR,#(TCLinkKeyFrmCntr + 4)
   \   000049   78..         MOV     R0,#?V0 + 4
   \   00004B   12....       LCALL   ?L_MOV_X
   \   00004E   E5..         MOV     A,?V0 + 0
   \   000050   241C         ADD     A,#0x1c
   \   000052   F582         MOV     DPL,A
   \   000054   E5..         MOV     A,?V0 + 1
   \   000056   12....       LCALL   ??Subroutine140_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_286:
   \   000059   12....       LCALL   ?L_MOV_TO_X
   4369                    
   4370                    // Write the TC link key back to the NV
   4371                    osal_nv_write(ZCD_NV_TCLK_TABLE_START + i, 0, 
   4372                                  sizeof(APSME_TCLinkKey_t), pKeyData);
   \   00005C                ; Setup parameters for call to function osal_nv_write
   \   00005C   78..         MOV     R0,#?V0 + 0
   \   00005E   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000061   78..         MOV     R0,#?V0 + 2
   \   000063   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000066   7C00         MOV     R4,#0x0
   \   000068   7D00         MOV     R5,#0x0
   \   00006A   7A01         MOV     R2,#0x1
   \   00006C   7B01         MOV     R3,#0x1
   \   00006E   12....       LCALL   ??Subroutine110_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_184:
   \   000071   12....       LCALL   ?DEALLOC_XSTACK8
   4373                    
   4374                    // clear the pending write flag
   4375                    TCLinkKeyFrmCntr[i].pendingFlag = FALSE;
   \   000074   E4           CLR     A
   \   000075   90....       MOV     DPTR,#(TCLinkKeyFrmCntr + 8)
   \   000078   F0           MOVX    @DPTR,A
   4376                  }
   4377                }
   4378              }
   4379                // clear copy of key in RAM 
   4380              osal_memset( pKeyData, 0x00, sizeof(APSME_TCLinkKey_t) );
   \                     ??ZDSecMgrSaveTCLinkKey_2:
   \   000079                ; Setup parameters for call to function osal_memset
   \   000079   7C20         MOV     R4,#0x20
   \   00007B   7D00         MOV     R5,#0x0
   \   00007D   7900         MOV     R1,#0x0
   \   00007F   AA..         MOV     R2,?V0 + 0
   \   000081   AB..         MOV     R3,?V0 + 1
   \   000083   12....       LCALL   ??osal_memset?relay
   4381              
   4382              osal_mem_free(pKeyData);
   \   000086                ; Setup parameters for call to function osal_mem_free
   \   000086   AA..         MOV     R2,?V0 + 0
   \   000088   AB..         MOV     R3,?V0 + 1
   \   00008A   12....       LCALL   ??osal_mem_free?relay
   4383            }
   4384          }
   \                     ??ZDSecMgrSaveTCLinkKey_1:
   \   00008D   02....       LJMP    ?Subroutine7 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine53:
   \   000000   12....       LCALL   ?Subroutine92 & 0xFFFF
   \                     ??CrossCallReturnLabel_218:
   \   000003   E4           CLR     A
   \   000004   F0           MOVX    @DPTR,A
   \   000005   22           RET

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for ZDSecMgrAppKeyType>`:
   \   000000   03           DB 3

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_0:
   \   000000   00000000     DD 0

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_1:
   \   000000   01000000     DD 1

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrMasterKeyInit?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrMasterKeyInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrAddrStore?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAddrStore

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrExtAddrStore?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrExtAddrStore

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrExtAddrLookup?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrExtAddrLookup

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrMasterKeyLookup?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrMasterKeyLookup

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrMasterKeyStore?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrMasterKeyStore

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrEntryInit?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEntryInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrEntryLookup?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEntryLookup

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrEntryLookupAMI?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEntryLookupAMI

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrEntryLookupExt?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEntryLookupExt

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrEntryLookupExtGetIndex?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEntryLookupExtGetIndex

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrEntryFree?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEntryFree

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrEntryNew?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEntryNew

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrCtrlInit?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrCtrlInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrCtrlRelease?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrCtrlRelease

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrCtrlLookup?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrCtrlLookup

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrCtrlSet?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrCtrlSet

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrCtrlAdd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrCtrlAdd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrCtrlTerm?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrCtrlTerm

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrCtrlReset?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrCtrlReset

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrMasterKeyLoad?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrMasterKeyLoad

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrAppKeyGet?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAppKeyGet

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrAppKeyReq?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAppKeyReq

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrEstablishKey?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEstablishKey

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrSendMasterKey?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrSendMasterKey

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrSendNwkKey?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrSendNwkKey

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceEntryRemove?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceEntryRemove

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceRemoveByExtAddr?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceRemoveByExtAddr

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrAddrMgrUpdate?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAddrMgrUpdate

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceEntryAdd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceEntryAdd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceCtrlHandler?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceCtrlHandler

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceCtrlSetup?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceCtrlSetup

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceCtrlUpdate?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceCtrlUpdate

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??APSME_SKA_TimerExpired?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    APSME_SKA_TimerExpired

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceRemove?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceRemove

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceValidateSKKE?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceValidateSKKE

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceValidateRM?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceValidateRM

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceValidateCM?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceValidateCM

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceValidate?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceValidate

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceJoin?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceJoin

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceJoinDirect?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceJoinDirect

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceJoinFwd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceJoinFwd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceNew?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceNew

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrAssocDeviceAuth?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAssocDeviceAuth

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrAuthInitiate?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAuthInitiate

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrAuthNwkKey?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAuthNwkKey

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrInit?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrConfig?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrConfig

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrPermitJoining?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrPermitJoining

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrPermitJoiningTimeout?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrPermitJoiningTimeout

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrNewDeviceEvent?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrNewDeviceEvent

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrEvent?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEvent

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrEstablishKeyCfm?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEstablishKeyCfm

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrTCExtAddrCheck?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrTCExtAddrCheck

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrTCDataLoad?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrTCDataLoad

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrEstablishKeyInd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEstablishKeyInd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrTransportKeyInd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrTransportKeyInd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrUpdateDeviceInd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrUpdateDeviceInd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrRemoveDeviceInd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrRemoveDeviceInd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrRequestKeyInd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrRequestKeyInd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrSwitchKeyInd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrSwitchKeyInd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrAuthenticateInd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAuthenticateInd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrAuthenticateCfm?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAuthenticateCfm

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrUpdateNwkKey?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrUpdateNwkKey

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrSwitchNwkKey?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrSwitchNwkKey

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrAppKeyTypeSet?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAppKeyTypeSet

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??APSME_MasterKeyGet?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    APSME_MasterKeyGet

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??APSME_LinkKeySet?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    APSME_LinkKeySet

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrAuthenticationSet?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAuthenticationSet

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrAuthenticationCheck?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAuthenticationCheck

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??APSME_LinkKeyNVIdGet?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    APSME_LinkKeyNVIdGet

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??APSME_IsLinkKeyValid?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    APSME_IsLinkKeyValid

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??APSME_KeyFwdToChild?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    APSME_KeyFwdToChild

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrAddLinkKey?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAddLinkKey

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrSetDefaultNV?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrSetDefaultNV

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrAPSRemove?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAPSRemove

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??APSME_TCLinkKeyInit?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    APSME_TCLinkKeyInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??APSME_TCLinkKeySync?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    APSME_TCLinkKeySync

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??APSME_TCLinkKeyLoad?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    APSME_TCLinkKeyLoad

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??APSME_IsDefaultTCLK?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    APSME_IsDefaultTCLK

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrNwkKeyInit?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrNwkKeyInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrReadKeyFromNv?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrReadKeyFromNv

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrApsLinkKeyInit?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrApsLinkKeyInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrInitNVKeyTables?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrInitNVKeyTables

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrSaveApsLinkKey?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrSaveApsLinkKey

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrSaveTCLinkKey?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrSaveTCLinkKey
   4385          
   4386          #if defined ( NV_RESTORE )
   4387          /******************************************************************************
   4388           * @fn          ZDSecMgrClearNVKeyValues
   4389           *
   4390           * @brief       If NV_RESTORE is enabled and the status of the network needs 
   4391           *              default values this fuction clears ZCD_NV_NWKKEY, 
   4392           *              ZCD_NV_NWK_ACTIVE_KEY_INFO and ZCD_NV_NWK_ALTERN_KEY_INFO link 
   4393           *           
   4394           * @param       none
   4395           *
   4396           * @return      none
   4397           */
   4398          void ZDSecMgrClearNVKeyValues(void)
   4399          {
   4400            nwkActiveKeyItems keyItems;
   4401            nwkKeyDesc nwkKey;
   4402          
   4403            osal_memset(&keyItems, 0x00, sizeof(nwkActiveKeyItems));
   4404          
   4405            osal_nv_write(ZCD_NV_NWKKEY, 0, sizeof(nwkActiveKeyItems), &keyItems);
   4406          
   4407            // Initialize NV items for NWK Active and Alternate keys. 
   4408            osal_memset( &nwkKey, 0x00, sizeof(nwkKeyDesc) );
   4409          
   4410            osal_nv_write(ZCD_NV_NWK_ACTIVE_KEY_INFO, 0, sizeof(nwkKeyDesc), &nwkKey);
   4411          
   4412            osal_nv_write(ZCD_NV_NWK_ALTERN_KEY_INFO, 0, sizeof(nwkKeyDesc), &nwkKey);
   4413          }
   4414          #endif // defined ( NV_RESTORE )
   4415          
   4416          /******************************************************************************
   4417          ******************************************************************************/
   4418          

   Maximum stack usage in bytes:

     Function                       ISTACK PSTACK XSTACK
     --------                       ------ ------ ------
     APSME_IsDefaultTCLK                2      0     57
     APSME_IsLinkKeyValid               0      0     37
       -> osal_memset                   0      0     66
       -> APSME_LinkKeyNVIdGet          0      0     66
       -> osal_mem_alloc                0      0     66
       -> osal_nv_read                  0      0     74
       -> osal_memcmp                   0      0     72
     APSME_KeyFwdToChild                0      0      9
       -> AssocGetWithExt               0      0     18
       -> ZDSecMgrAssocDeviceAuth       0      0     18
     APSME_LinkKeyNVIdGet               0      0     44
       -> ZDSecMgrEntryLookupExt        0      0     22
     APSME_LinkKeySet                   0      0     40
       -> ZDSecMgrEntryLookupExtGetIndex
                                        0      0     44
       -> osal_mem_alloc                0      0     40
       -> osal_nv_read                  0      0     48
       -> osal_memcpy                   0      0     46
       -> osal_nv_write                 0      0     48
       -> osal_memset                   0      0     40
       -> osal_mem_free                 0      0     40
     APSME_MasterKeyGet                 0      0     11
       -> ZDSecMgrExtAddrLookup         0      0     22
       -> ZDSecMgrMasterKeyLookup       0      0     22
     APSME_SKA_TimerExpired             0      0      9
       -> ZDSecMgrDeviceCtrlUpdate      0      0     18
     APSME_TCLinkKeyInit                0      0     57
       -> osal_memset                   0      0     88
       -> osal_memset                   0      0     88
       -> osal_memcpy                   0      0     94
       -> osal_nv_item_init             0      0     92
       -> osal_nv_read                  0      0     96
       -> osal_nv_write                 0      0     96
       -> osal_memset                   0      0     88
     APSME_TCLinkKeyLoad                1      0     61
       -> APSME_LookupExtAddr           0      0    114
       -> AddrMgrExtAddrValid           0      0    114
       -> osal_nv_read                  0      0    122
       -> AddrMgrExtAddrEqual           0      0    114
       -> APSME_IsDefaultTCLK           0      0    114
       -> AddrMgrEntryLookupNwk         0      0    114
       -> AddrMgrEntryRelease           0      0    114
       -> osal_memset                   0      0    114
     APSME_TCLinkKeySync                2      0     48
       -> AddrMgrExtAddrValid           0      0     88
       -> APSME_LookupExtAddr           0      0     88
       -> osal_nv_read                  0      0     96
       -> AddrMgrExtAddrEqual           0      0     88
       -> APSME_IsDefaultTCLK           0      0     88
       -> osal_memset                   0      0     88
     ZDSecMgrAPSRemove                  2      0     12
       -> ZDSecMgrDeviceRemove          4      0     20
     ZDSecMgrAddLinkKey                 0      0     20
       -> ZDSecMgrAddrStore             0      0     36
       -> ZDSecMgrEntryLookupAMI        0      0     32
       -> ZDSecMgrEntryNew              0      0     32
       -> APSME_LinkKeySet              0      0     32
     ZDSecMgrAddrMgrUpdate              1      0     35
       -> AddrMgrEntryGet               0      0     44
       -> AddrMgrEntryUpdate            0      0     44
     ZDSecMgrAddrStore                  1      0     55
       -> AddrMgrExtAddrSet             0      0     44
       -> AddrMgrEntryUpdate            0      0     44
     ZDSecMgrAppKeyGet                  1      0     17
       -> SSP_GetTrueRand               0      0     18
     ZDSecMgrAppKeyReq                  1      0     48
       -> APSME_LookupNwkAddr           0      0     96
       -> APSME_LookupExtAddr           0      0     96
       -> SSP_GetTrueRand               0      0     96
       -> APSME_TransportKeyReq         0      0     96
       -> APSME_TransportKeyReq         0      0     96
       -> osal_memset                   0      0     96
     ZDSecMgrAppKeyTypeSet              2      0      0
     ZDSecMgrApsLinkKeyInit             0      0     47
       -> osal_memset                   0      0     68
       -> osal_nv_item_init             0      0     72
       -> osal_nv_write                 0      0     76
     ZDSecMgrAssocDeviceAuth            2      0     35
     ZDSecMgrAuthInitiate               1      0     16
       -> APSME_LookupNwkAddr           0      0     32
       -> APSME_AuthenticateReq         0      0     32
     ZDSecMgrAuthNwkKey                 2      0     26
       -> osal_set_event                4      0      0
     ZDSecMgrAuthenticateCfm            2      0      0
       -> osal_set_event                4      0      0
     ZDSecMgrAuthenticateInd            1      0     29
       -> AddrMgrExtAddrSet             0      0     58
       -> AddrMgrEntryUpdate            0      0     58
       -> APSME_AuthenticateReq         0      0     58
     ZDSecMgrAuthenticationCheck        0      0      0
     ZDSecMgrAuthenticationSet          1      0     11
       -> ZDSecMgrEntryLookupExt        0      0     22
     ZDSecMgrConfig                     2      0      0
       -> APSME_SecurityNM              4      0      0
     ZDSecMgrCtrlAdd                    0      0     27
       -> ZDSecMgrCtrlSet               0      0     28
     ZDSecMgrCtrlInit                   3      0      0
       -> osal_mem_alloc                4      0      0
     ZDSecMgrCtrlLookup                 0      0     22
     ZDSecMgrCtrlRelease                3      0      0
     ZDSecMgrCtrlReset                  0      0     27
       -> ZDSecMgrCtrlLookup            0      0     24
       -> ZDSecMgrCtrlSet               0      0     28
       -> ZDSecMgrCtrlAdd               0      0     24
     ZDSecMgrCtrlSet                    1      0     23
     ZDSecMgrCtrlTerm                   3      0     11
       -> ZDSecMgrCtrlLookup            4      0      4
     ZDSecMgrDeviceCtrlHandler          1      0     42
       -> ZDSecMgrSendMasterKey         0      0     18
       -> ZDSecMgrEstablishKey          0      0     18
       -> osal_start_timerEx            0      0     18
       -> ZDSecMgrSendNwkKey            0      0     18
     ZDSecMgrDeviceCtrlSetup            3      0      0
       -> ZDSecMgrDeviceCtrlHandler     4      0      0
     ZDSecMgrDeviceCtrlUpdate           1      0     22
       -> ZDSecMgrEntryLookupExt        0      0     26
       -> ZDSecMgrCtrlLookup            0      0     26
     ZDSecMgrDeviceEntryAdd             0      0     43
       -> ZDSecMgrEntryLookup           0      0     26
       -> ZDSecMgrDeviceEntryRemove     0      0     26
       -> ZDSecMgrEntryLookupAMI        0      0     26
       -> ZDSecMgrAddrMgrUpdate         0      0     26
       -> ZDSecMgrEntryLookupAMI        0      0     26
       -> ZDSecMgrEntryNew              0      0     26
       -> ZDSecMgrAddrMgrUpdate         0      0     26
       -> ZDSecMgrCtrlAdd               0      0     26
       -> ZDSecMgrCtrlReset             0      0     26
     ZDSecMgrDeviceEntryRemove          0      0     22
       -> ZDSecMgrCtrlTerm              0      0     18
       -> ZDSecMgrEntryFree             0      0     18
     ZDSecMgrDeviceJoin                 0      0     24
       -> ZDSecMgrDeviceValidate        0      0     24
       -> ZDSecMgrAddrStore             0      0     28
       -> ZDSecMgrSendNwkKey            0      0     24
       -> ZDSecMgrDeviceRemove          0      0     24
     ZDSecMgrDeviceJoinDirect           0      0      9
       -> ZDSecMgrDeviceJoin            0      0     18
       -> AssocGetWithShort             0      0     18
       -> ZDSecMgrAssocDeviceAuth       0      0     18
     ZDSecMgrDeviceJoinFwd              3      0      8
       -> APSME_UpdateDeviceReq         4      0     16
     ZDSecMgrDeviceNew                  2      0     35
       -> ZDSecMgrDeviceJoinDirect      4      0      0
     ZDSecMgrDeviceRemove               1      0     38
       -> NLME_GetShortAddr             0      0     38
       -> AssocGetWithExt               0      0     38
       -> NLME_LeaveReq                 0      0     38
       -> APSME_RemoveDeviceReq         0      0     38
     ZDSecMgrDeviceRemoveByExtAddr      0      0     11
       -> ZDSecMgrEntryLookupExt        0      0     22
       -> ZDSecMgrDeviceEntryRemove     0      0     22
     ZDSecMgrDeviceValidate             3      0     12
       -> ZDSecMgrDeviceValidateRM      4      0      0
     ZDSecMgrDeviceValidateCM           0      0     33
       -> osal_memcpy                   0      0     66
       -> ZDSecMgrAddrStore             0      0     64
       -> ZDSecMgrMasterKeyLoad         0      0     60
       -> ZDSecMgrDeviceEntryAdd        0      0     60
       -> osal_memset                   0      0     60
     ZDSecMgrDeviceValidateRM           2      0      0
     ZDSecMgrDeviceValidateSKKE         0      0     40
       -> ZDSecMgrExtAddrLookup         0      0     26
       -> ZDSecMgrMasterKeyLookup       0      0     26
       -> ZDSecMgrDeviceEntryAdd        0      0     26
     ZDSecMgrEntryFree                  0      0     27
       -> osal_mem_alloc                0      0     28
       -> osal_memset                   0      0     28
       -> osal_nv_write                 0      0     36
       -> osal_mem_free                 0      0     28
     ZDSecMgrEntryInit                  2      0      0
       -> osal_mem_alloc                4      0      0
     ZDSecMgrEntryLookup                1      0     35
       -> AddrMgrEntryLookupNwk         0      0     44
     ZDSecMgrEntryLookupAMI             0      0     25
     ZDSecMgrEntryLookupExt             0      0     24
       -> ZDSecMgrExtAddrLookup         0      0     22
       -> ZDSecMgrEntryLookupAMI        0      0     22
     ZDSecMgrEntryLookupExtGetIndex     0      0     34
       -> ZDSecMgrExtAddrLookup         0      0     24
     ZDSecMgrEntryNew                   1      0     25
     ZDSecMgrEstablishKey               1      0     26
       -> NLME_GetShortAddr             0      0     34
       -> APSME_EstablishKeyReq         0      0     34
     ZDSecMgrEstablishKeyCfm            2      0      0
       -> ZDSecMgrDeviceCtrlUpdate      4      0      0
     ZDSecMgrEstablishKeyInd            1      0     27
       -> ZDSecMgrTCDataLoad            0      0     54
       -> ZDSecMgrTCExtAddrCheck        0      0     54
       -> ZDSecMgrDeviceValidateSKKE
                                        0      0     54
       -> APSME_EstablishKeyRsp         0      0     54
     ZDSecMgrEvent                      1      0     33
       -> AddrMgrEntryGet               0      0     66
       -> ZDSecMgrDeviceCtrlHandler     0      0     66
       -> osal_start_timerEx            0      0     66
     ZDSecMgrExtAddrLookup              1      0     36
       -> AddrMgrExtAddrSet             0      0     44
       -> AddrMgrEntryLookupExt         0      0     44
     ZDSecMgrExtAddrStore               1      0     24
       -> AddrMgrExtAddrSet             0      0     44
       -> AddrMgrEntryUpdate            0      0     44
     ZDSecMgrInit                       2      0      0
       -> APSME_SecurityNM              4      0      0
     ZDSecMgrInitNVKeyTables            0      0      9
       -> ZDSecMgrNwkKeyInit            0      0     18
       -> ZDSecMgrMasterKeyInit         0      0     18
       -> ZDSecMgrApsLinkKeyInit        0      0     18
       -> APSME_TCLinkKeyInit           0      0     18
     ZDSecMgrMasterKeyInit              0      0     41
       -> osal_memset                   0      0     56
       -> osal_nv_item_init             0      0     60
       -> osal_nv_write                 0      0     64
     ZDSecMgrMasterKeyLoad              0      0     48
       -> ZDSecMgrExtAddrLookup         0      0     28
       -> ZDSecMgrMasterKeyLookup       0      0     28
       -> osal_nv_write                 0      0     36
       -> ZDSecMgrMasterKeyStore        0      0     28
     ZDSecMgrMasterKeyLookup            0      0     77
       -> osal_nv_read                  0      0     72
       -> osal_memset                   0      0     64
       -> osal_memset                   0      0     64
     ZDSecMgrMasterKeyStore             0      0     68
       -> osal_nv_read                  0      0     74
       -> osal_memcpy                   0      0     72
       -> osal_memset                   0      0     66
       -> osal_nv_write                 0      0     74
       -> osal_memset                   0      0     66
       -> osal_memset                   0      0     66
     ZDSecMgrNewDeviceEvent             1      0     35
       -> AssocMatchDeviceStatus        0      0     70
       -> ZDSecMgrAssocDeviceAuth       0      0     70
       -> AddrMgrEntryGet               0      0     70
       -> NLME_GetShortAddr             0      0     70
       -> ZDSecMgrDeviceNew             0      0     70
       -> AssocRemove                   0      0     70
     ZDSecMgrNwkKeyInit                 0      0     61
       -> osal_memset                   0      0     96
       -> osal_nv_item_init             0      0    100
       -> osal_nv_write                 0      0    104
       -> osal_memset                   0      0     96
       -> osal_nv_item_init             0      0    100
       -> osal_nv_write                 0      0    104
       -> osal_nv_item_init             0      0    100
       -> osal_nv_write                 0      0    104
     ZDSecMgrPermitJoining              2      0      0
     ZDSecMgrPermitJoiningTimeout       2      0      0
     ZDSecMgrReadKeyFromNv              0      0     40
       -> osal_nv_read                  0      0     28
       -> osal_nv_read                  0      0     28
       -> osal_nv_read                  0      0     28
       -> osal_nv_read                  0      0     28
       -> osal_nv_read                  0      0     28
     ZDSecMgrRemoveDeviceInd            0      0     19
       -> APSME_LookupNwkAddr           0      0     38
       -> NLME_GetShortAddr             0      0     38
       -> ZDSecMgrDeviceRemove          0      0     38
     ZDSecMgrRequestKeyInd              2      0      0
       -> ZDSecMgrAppKeyReq             4      0      0
     ZDSecMgrSaveApsLinkKey             1      0     20
       -> osal_mem_alloc                0      0     32
       -> osal_nv_read                  0      0     40
       -> osal_nv_write                 0      0     40
       -> osal_memset                   0      0     32
       -> osal_mem_free                 0      0     32
     ZDSecMgrSaveTCLinkKey              0      0     20
       -> osal_mem_alloc                0      0     32
       -> osal_nv_read                  0      0     40
       -> osal_nv_write                 0      0     40
       -> osal_memset                   0      0     32
       -> osal_mem_free                 0      0     32
     ZDSecMgrSendMasterKey              1      0     54
       -> ZDSecMgrMasterKeyLookup       0      0     82
       -> osal_nv_read                  0      0     90
       -> osal_memset                   0      0     82
       -> NLME_GetShortAddr             0      0     82
       -> APSME_TransportKeyReq         0      0     82
       -> osal_memset                   0      0     82
     ZDSecMgrSendNwkKey                 1      0     56
       -> NLME_ReadNwkKeyInfo           0      0     88
       -> osal_memset                   0      0     80
       -> NLME_GetShortAddr             0      0     80
       -> NLME_GetShortAddr             0      0     80
       -> APSME_TransportKeyReq         0      0     80
       -> osal_memset                   0      0     80
     ZDSecMgrSetDefaultNV               0      0     23
       -> osal_nv_write                 0      0     46
       -> osal_memset                   0      0     38
       -> osal_nv_write                 0      0     46
       -> osal_mem_alloc                0      0     38
       -> osal_memset                   0      0     38
       -> osal_nv_write                 0      0     46
       -> osal_mem_free                 0      0     38
     ZDSecMgrSwitchKeyInd               2      0      0
       -> SSP_SwitchNwkKey              4      0      0
       -> ZDApp_NVUpdate                4      0      0
     ZDSecMgrSwitchNwkKey               1      0     12
       -> APSME_SwitchKeyReq            0      0     24
       -> SSP_SwitchNwkKey              0      0     24
       -> ZDApp_NVUpdate                0      0     24
     ZDSecMgrTCDataLoad                 0      0     61
       -> ZDSecMgrAddrStore             0      0     66
       -> ZDSecMgrMasterKeyLookup       0      0     62
       -> osal_memcpy                   0      0     68
       -> ZDSecMgrMasterKeyStore        0      0     62
       -> osal_memset                   0      0     62
     ZDSecMgrTCExtAddrCheck             0      0     44
       -> AddrMgrExtAddrLookup          0      0     34
       -> AddrMgrExtAddrEqual           0      0     34
     ZDSecMgrTransportKeyInd            0      0     26
       -> ZDSecMgrTCDataLoad            0      0     52
       -> ZDSecMgrReadKeyFromNv         0      0     52
       -> SSP_UpdateNwkKey              0      0     52
       -> SSP_SwitchNwkKey              0      0     52
       -> osal_memset                   0      0     52
       -> SSP_UpdateNwkKey              0      0     52
       -> SSP_SwitchNwkKey              0      0     52
       -> ZDSecMgrAuthNwkKey            0      0     52
     ZDSecMgrUpdateDeviceInd            2      0     10
       -> ZDSecMgrDeviceJoin            4      0     20
     ZDSecMgrUpdateNwkKey               1      0     23
       -> APSME_TransportKeyReq         0      0     46
       -> SSP_UpdateNwkKey              0      0     46
       -> ZDApp_NVUpdate                0      0     46


   Segment part sizes:

     Function/Label                         Bytes
     --------------                         -----
     ZDSecMgrTCExtAddr                         8
     ZDSecMgrTCMasterKey                      16
     ZDSecMgrTCAuthenticated                   1
     ZDSecMgrTCDataLoaded                      1
     ZDSecMgrEntries                           2
     ZDSecMgrCtrlData                          2
     ZDSecMgrPermitJoiningEnabled              1
     ZDSecMgrPermitJoiningTimed                1
     TrustCenterLinkKey                       32
     ApsLinkKeyFrmCntr                        27
     TCLinkKeyFrmCntr                          9
     ZDSecMgrMasterKeyInit                   117
     ?Subroutine39                             4
     ??Subroutine105_0                         8
     ??Subroutine108_0                         1
     ??Subroutine109_0                         1
     ??Subroutine110_0                         6
     ??Subroutine118_0                         3
     ??Subroutine119_0                         5
     ?Subroutine34                            16
     ??Subroutine146_0                         6
     ZDSecMgrAddrStore                        55
     ?Subroutine74                            10
     ?Subroutine49                            19
     ?Subroutine30                            13
     ?Subroutine8                              5
     ?Subroutine89                            18
     ?Subroutine12                             4
     ??Subroutine106_0                         5
     ??Subroutine107_0                         6
     ?Subroutine29                             6
     ?Subroutine87                             6
     ??Subroutine132_0                         3
     ??Subroutine133_0                         5
     ?Subroutine94                             6
     ZDSecMgrExtAddrStore                     54
     ZDSecMgrExtAddrLookup                    61
     ZDSecMgrMasterKeyLookup                 155
     ?Subroutine2                              5
     ?Subroutine79                            15
     ?Subroutine37                            22
     ??Subroutine113_0                         4
     ??Subroutine145_0                         6
     ZDSecMgrMasterKeyStore                  246
     ?Subroutine3                             10
     ?Subroutine78                             4
     ??Subroutine121_0                         6
     ZDSecMgrEntryInit                        72
     ?Subroutine77                            30
     ?Subroutine18                             5
     ?Subroutine99                            16
     ??Subroutine125_0                         7
     ZDSecMgrEntryLookup                     140
     ?Subroutine35                             4
     ?Subroutine98                             7
     ?Subroutine58                             5
     ?Subroutine96                            13
     ?Subroutine103                            6
     ?Subroutine16                             4
     ??Subroutine127_0                         4
     ??Subroutine138_0                         8
     ?Subroutine102                            8
     ZDSecMgrEntryLookupAMI                  108
     ?Subroutine61                             9
     ZDSecMgrEntryLookupExt                   60
     ??Subroutine117_0                         5
     ?Subroutine1                              2
     ??Subroutine131_0                         2
     ??Subroutine142_0                         5
     ?Subroutine65                             7
     ZDSecMgrEntryLookupExtGetIndex          130
     ?Subroutine63                            11
     ?Subroutine0                              2
     ??Subroutine123_0                         4
     ??Subroutine144_0                         4
     ZDSecMgrEntryFree                        92
     ?Subroutine104                            2
     ?Subroutine82                            13
     ?Subroutine75                            13
     ZDSecMgrEntryNew                        145
     ZDSecMgrCtrlInit                         70
     ZDSecMgrCtrlRelease                      18
     ZDSecMgrCtrlLookup                      141
     ZDSecMgrCtrlSet                          91
     ?Subroutine26                             5
     ?Subroutine86                            12
     ZDSecMgrCtrlAdd                         143
     ??Subroutine129_0                         5
     ZDSecMgrCtrlTerm                         41
     ??Subroutine111_0                         6
     ?Subroutine81                            11
     ZDSecMgrCtrlReset                        84
     ZDSecMgrMasterKeyLoad                    93
     ?Subroutine48                            10
     ??Subroutine120_0                         8
     ?Subroutine68                             7
     ?Subroutine91                             6
     ZDSecMgrAppKeyType                        1
     ZDSecMgrAppKeyGet                        53
     ?Subroutine66                             5
     ZDSecMgrAppKeyReq                       237
     ?Subroutine71                             8
     ??Subroutine122_0                         2
     ??Subroutine124_0                         6
     ?Subroutine19                             6
     ?Subroutine21                             7
     ?Subroutine84                            13
     ?Subroutine46                            12
     ZDSecMgrEstablishKey                     94
     ?Subroutine31                             3
     ??Subroutine112_0                         6
     ??Subroutine114_0                         5
     ?Subroutine100                           22
     ?Subroutine51                             2
     ?Subroutine90                            12
     ZDSecMgrSendMasterKey                   238
     ?Subroutine11                             4
     ?Subroutine72                             5
     ?Subroutine23                            11
     ??Subroutine126_0                         6
     ?Subroutine95                             1
     ??Subroutine130_0                         8
     ?Subroutine22                             6
     ?Subroutine52                             9
     ZDSecMgrSendNwkKey                      261
     ?Subroutine33                             3
     ?Subroutine20                             8
     ?Subroutine62                             4
     ZDSecMgrDeviceEntryRemove                22
     ZDSecMgrDeviceRemoveByExtAddr            35
     ?Subroutine69                             7
     ZDSecMgrAddrMgrUpdate                    66
     ZDSecMgrDeviceEntryAdd                  181
     ?Subroutine6                              8
     ?Subroutine64                             8
     ?Subroutine59                            13
     ?Subroutine97                             8
     ZDSecMgrDeviceCtrlHandler               141
     ?Subroutine92                             2
     ??Subroutine115_0                        12
     ?Subroutine54                             5
     ?Subroutine43                            11
     ?Subroutine24                             9
     ZDSecMgrDeviceCtrlSetup                  71
     ??Subroutine116_0                         4
     ZDSecMgrDeviceCtrlUpdate                110
     ?Subroutine9                              5
     ?Subroutine55                             6
     ?Subroutine27                             4
     APSME_SKA_TimerExpired                   20
     ZDSecMgrDeviceRemove                    156
     ?Subroutine28                            14
     ?Subroutine70                             7
     ??Subroutine143_0                         2
     ZDSecMgrDeviceValidateSKKE               45
     ?Subroutine60                            13
     ZDSecMgrDeviceValidateRM                 17
     ZDSecMgrDeviceValidateCM                133
     ?Subroutine50                            16
     ??Subroutine128_0                         3
     ZDSecMgrDeviceValidate                   46
     ZDSecMgrDeviceJoin                       75
     ZDSecMgrDeviceJoinDirect                 35
     ZDSecMgrDeviceJoinFwd                   154
     ?Subroutine17                            15
     ZDSecMgrDeviceNew                         9
     ZDSecMgrAssocDeviceAuth                  25
     ZDSecMgrAuthInitiate                     66
     ZDSecMgrAuthNwkKey                       26
     ?Subroutine4                              7
     ZDSecMgrInit                              2
     ZDSecMgrConfig                            2
     ZDSecMgrPermitJoining                    42
     ZDSecMgrPermitJoiningTimeout             24
     ZDSecMgrNewDeviceEvent                  184
     ?Subroutine32                             3
     ?Subroutine67                             4
     ZDSecMgrEvent                           233
     ?Subroutine47                             6
     ?Subroutine93                            38
     ?Subroutine15                             4
     ?Subroutine85                             4
     ZDSecMgrEstablishKeyCfm                  21
     ZDSecMgrTCExtAddrCheck                   63
     ZDSecMgrTCDataLoad                      140
     ZDSecMgrEstablishKeyInd                 185
     ?Subroutine25                            13
     ?Subroutine13                            13
     ??Subroutine134_0                         6
     ?Subroutine88                            10
     ??Subroutine136_0                         3
     ??Subroutine137_0                         5
     ZDSecMgrTransportKeyInd                 212
     ?Subroutine101                            9
     ?Subroutine10                             2
     ZDSecMgrUpdateDeviceInd                  49
     ZDSecMgrRemoveDeviceInd                  71
     ?Subroutine14                             7
     ZDSecMgrRequestKeyInd                    36
     ZDSecMgrSwitchKeyInd                     23
     ZDSecMgrAuthenticateInd                 108
     ZDSecMgrAuthenticateCfm                  50
     ZDSecMgrUpdateNwkKey                    109
     ZDSecMgrSwitchNwkKey                     42
     ZDSecMgrAppKeyTypeSet                    26
     APSME_MasterKeyGet                       61
     APSME_LinkKeySet                        304
     ?Subroutine7                              5
     ?Subroutine42                             4
     ??Subroutine139_0                         4
     ??Subroutine140_0                         7
     ?Subroutine57                             6
     ??Subroutine141_0                         6
     ?Subroutine56                             9
     ?Subroutine73                             8
     ?Subroutine40                            21
     ZDSecMgrAuthenticationSet                38
     ZDSecMgrAuthenticationCheck               5
     APSME_LinkKeyNVIdGet                     61
     APSME_IsLinkKeyValid                    153
     ?Subroutine41                            14
     APSME_KeyFwdToChild                      73
     ZDSecMgrAddLinkKey                      140
     ?Subroutine36                            10
     ZDSecMgrSetDefaultNV                    198
     ?Subroutine80                            11
     ZDSecMgrAPSRemove                        71
     ?Subroutine5                              2
     APSME_TCLinkKeyInit                     280
     ?Subroutine76                             8
     ?Subroutine45                             1
     ??Subroutine135_0                         2
     APSME_TCLinkKeySync                     196
     ?Subroutine83                            12
     ?Subroutine44                            17
     APSME_TCLinkKeyLoad                     218
     APSME_IsDefaultTCLK                      50
     ZDSecMgrNwkKeyInit                      227
     ?Subroutine38                             2
     ZDSecMgrReadKeyFromNv                   205
     ZDSecMgrApsLinkKeyInit                  128
     ZDSecMgrInitNVKeyTables                  24
     ZDSecMgrSaveApsLinkKey                  221
     ZDSecMgrSaveTCLinkKey                   144
     ?Subroutine53                             6
     ?<Initializer for ZDSecMgrAppKeyType>     1
     __Constant_0                              4
     __Constant_1                              4
     ??ZDSecMgrMasterKeyInit?relay             6
     ??ZDSecMgrAddrStore?relay                 6
     ??ZDSecMgrExtAddrStore?relay              6
     ??ZDSecMgrExtAddrLookup?relay             6
     ??ZDSecMgrMasterKeyLookup?relay           6
     ??ZDSecMgrMasterKeyStore?relay            6
     ??ZDSecMgrEntryInit?relay                 6
     ??ZDSecMgrEntryLookup?relay               6
     ??ZDSecMgrEntryLookupAMI?relay            6
     ??ZDSecMgrEntryLookupExt?relay            6
     ??ZDSecMgrEntryLookupExtGetIndex?relay    6
     ??ZDSecMgrEntryFree?relay                 6
     ??ZDSecMgrEntryNew?relay                  6
     ??ZDSecMgrCtrlInit?relay                  6
     ??ZDSecMgrCtrlRelease?relay               6
     ??ZDSecMgrCtrlLookup?relay                6
     ??ZDSecMgrCtrlSet?relay                   6
     ??ZDSecMgrCtrlAdd?relay                   6
     ??ZDSecMgrCtrlTerm?relay                  6
     ??ZDSecMgrCtrlReset?relay                 6
     ??ZDSecMgrMasterKeyLoad?relay             6
     ??ZDSecMgrAppKeyGet?relay                 6
     ??ZDSecMgrAppKeyReq?relay                 6
     ??ZDSecMgrEstablishKey?relay              6
     ??ZDSecMgrSendMasterKey?relay             6
     ??ZDSecMgrSendNwkKey?relay                6
     ??ZDSecMgrDeviceEntryRemove?relay         6
     ??ZDSecMgrDeviceRemoveByExtAddr?relay     6
     ??ZDSecMgrAddrMgrUpdate?relay             6
     ??ZDSecMgrDeviceEntryAdd?relay            6
     ??ZDSecMgrDeviceCtrlHandler?relay         6
     ??ZDSecMgrDeviceCtrlSetup?relay           6
     ??ZDSecMgrDeviceCtrlUpdate?relay          6
     ??APSME_SKA_TimerExpired?relay            6
     ??ZDSecMgrDeviceRemove?relay              6
     ??ZDSecMgrDeviceValidateSKKE?relay        6
     ??ZDSecMgrDeviceValidateRM?relay          6
     ??ZDSecMgrDeviceValidateCM?relay          6
     ??ZDSecMgrDeviceValidate?relay            6
     ??ZDSecMgrDeviceJoin?relay                6
     ??ZDSecMgrDeviceJoinDirect?relay          6
     ??ZDSecMgrDeviceJoinFwd?relay             6
     ??ZDSecMgrDeviceNew?relay                 6
     ??ZDSecMgrAssocDeviceAuth?relay           6
     ??ZDSecMgrAuthInitiate?relay              6
     ??ZDSecMgrAuthNwkKey?relay                6
     ??ZDSecMgrInit?relay                      6
     ??ZDSecMgrConfig?relay                    6
     ??ZDSecMgrPermitJoining?relay             6
     ??ZDSecMgrPermitJoiningTimeout?relay      6
     ??ZDSecMgrNewDeviceEvent?relay            6
     ??ZDSecMgrEvent?relay                     6
     ??ZDSecMgrEstablishKeyCfm?relay           6
     ??ZDSecMgrTCExtAddrCheck?relay            6
     ??ZDSecMgrTCDataLoad?relay                6
     ??ZDSecMgrEstablishKeyInd?relay           6
     ??ZDSecMgrTransportKeyInd?relay           6
     ??ZDSecMgrUpdateDeviceInd?relay           6
     ??ZDSecMgrRemoveDeviceInd?relay           6
     ??ZDSecMgrRequestKeyInd?relay             6
     ??ZDSecMgrSwitchKeyInd?relay              6
     ??ZDSecMgrAuthenticateInd?relay           6
     ??ZDSecMgrAuthenticateCfm?relay           6
     ??ZDSecMgrUpdateNwkKey?relay              6
     ??ZDSecMgrSwitchNwkKey?relay              6
     ??ZDSecMgrAppKeyTypeSet?relay             6
     ??APSME_MasterKeyGet?relay                6
     ??APSME_LinkKeySet?relay                  6
     ??ZDSecMgrAuthenticationSet?relay         6
     ??ZDSecMgrAuthenticationCheck?relay       6
     ??APSME_LinkKeyNVIdGet?relay              6
     ??APSME_IsLinkKeyValid?relay              6
     ??APSME_KeyFwdToChild?relay               6
     ??ZDSecMgrAddLinkKey?relay                6
     ??ZDSecMgrSetDefaultNV?relay              6
     ??ZDSecMgrAPSRemove?relay                 6
     ??APSME_TCLinkKeyInit?relay               6
     ??APSME_TCLinkKeySync?relay               6
     ??APSME_TCLinkKeyLoad?relay               6
     ??APSME_IsDefaultTCLK?relay               6
     ??ZDSecMgrNwkKeyInit?relay                6
     ??ZDSecMgrReadKeyFromNv?relay             6
     ??ZDSecMgrApsLinkKeyInit?relay            6
     ??ZDSecMgrInitNVKeyTables?relay           6
     ??ZDSecMgrSaveApsLinkKey?relay            6
     ??ZDSecMgrSaveTCLinkKey?relay             6

 
 9 980 bytes in segment BANKED_CODE
   516 bytes in segment BANK_RELAYS
    16 bytes in segment CODE_C
     1 byte  in segment XDATA_I
     1 byte  in segment XDATA_ID
     8 bytes in segment XDATA_ROM_C
    84 bytes in segment XDATA_Z
 
 10 513 bytes of CODE  memory
      0 bytes of CONST memory (+ 8 bytes shared)
     85 bytes of XDATA memory

Errors: none
Warnings: none
